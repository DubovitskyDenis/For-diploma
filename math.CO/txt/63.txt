singularity
confinement
pentagram
map
max
glick
abstract
pentagram
map
introduced
schwartz
birational
map
conﬁguration
space
polygons
projective
plane
study
singularities
iterates
pentagram
map
show
typical
singularity
disappears
ﬁnite
number
iterations
conﬁne-
ment
phenomenon
ﬁrst
discovered
schwartz
provide
method
bypass
singular
patch
directly
constructing
ﬁrst
subsequent
iterate
well-deﬁned
singular
locus
consideration
key
ingredient
construction
notion
decorated
twisted
polygon
extension
pentagram
map
corresponding
decorated
conﬁguration
space
contents
introduction
pentagram
map
background
-polynomials
singularity
patterns
straightedge
constructions
ﬁrst
attempt
5.1.
map
5.2.
map
3,5
3.5,4.5
decorated
polygons
degenerations
7.1.
triangles
7.2.
complete
quadrilaterals
7.3.
degenerate
polygons
main
algorithm
appendix
basic
constructions
references
introduction
pentagram
map
introduced
schwartz
geometric
construction
produces
one
polygon
another
successive
applications
operation
figure
deﬁne
discrete
dynamical
system
received
considerable
date
october
2018
2010
mathematics
subject
classiﬁcation
05a15
51a05
37j35
key
words
phrases
pentagram
map
singularity
conﬁnement
alternating
sign
matrix
dec-
orated
polygon
partially
supported
nsf
grants
dms-0943832
dms-1101152
max
glick
attention
recent
years
see
e.g.
due
integrability
properties
connections
moduli
spaces
cluster
algebras
paper
devoted
study
singularity
conﬁnement
pentagram
map
phenomenon
ﬁrst
observed
experimentally
schwartz
informally
speaking
singularity
map
point
said
conﬁned
higher
iterate
map
well-deﬁned
point
investigate
singularities
pentagram
map
prove
conﬁnement
several
cases
figure
three
iterations
pentagram
map
space
9-gons
pentagram
map
typically
deﬁned
objects
called
twisted
polygons
de-
ﬁned
schwartz
twisted
polygon
sequence
i∈z
points
projective
plane
periodic
modulo
projective
transformation
i.e.
ai+n
place
additional
restriction
every
quadruple
consecutive
points
general
position
two
twisted
polygons
said
projectively
equivalent
exists
projective
transformation
let
denote
space
twisted
n-gons
modulo
projective
equivalence
convenient
also
allow
twisted
polygons
indexed
instead
modulo
projective
let
equivalence
denote
space
twisted
n-gons
indexed
pentagram
map
denoted
inputs
twisted
polygon
constructs
new
note
indexed
vice
versa
pentagram
map
preserves
←−−−−−→
ai−
ai+
←−−−−−→
ai−
ai+
twisted
polygon
deﬁned
indexed
projective
equivalence
induces
maps
schwartz
gives
coordinates
x2n
deﬁned
generically
naturally
ordered
cyclically
let
xi+2n
expressed
coordinates
maps
take
simple
form
proposition
1.1
suppose
x2n
x-coordinates
1.1
xj−1
xj+1
1−xj−3xj−2
1−xj+1xj+2
1−xj+3xj+2
1−xj−1xj−2
even
odd
singularity
confinement
pentagram
map
alternately
1.2
xj+1
xj−1
1−xj+3xj+2
1−xj−1xj−2
1−xj−3xj−2
1−xj+1xj+2
even
odd
interested
kth
iterate
pentagram
map
deﬁned
depending
takes
form
image
either
parity
1.1
1.2
rational
map
purpose
paper
better
understand
singularities
pentagram
map
iterates
let
singular
point
pentagram
map
typically
singular
point
less
phenomenon
known
singularity
conﬁnement
identiﬁed
grammaticos
ramani
papageorgiou
feature
common
many
discrete
integrable
systems
pentagram
map
discrete
integrable
system
proven
ovsienko
schwartz
tabachnikov
soloviev
singularity
conﬁnement
holds
setting
observed
experimentally
schwartz
current
paper
seeks
understand
singularity
conﬁnement
pentagram
map
algebraic
geometric
perspective
algebraically
1.2
suggests
polygon
singular
point
pentagram
map
whenever
x2i
x2i+1
check
many
steps
singularity
persists
one
must
determine
rational
expression
vanishing
denominator
given
point
use
generating
function
formulas
denominators
better
understand
occurs
discover
behavior
singularity
seems
depend
set
integers
x2i
x2i+1
call
type
singularity
attempt
understand
singularity
conﬁnement
holds
generic
polygons
given
type
simplest
case
consists
single
element
event
singularity
conﬁned
two
iterations
i.e
singular
point
generally
suppose
ﬁnite
arithmetic
progression
common
diﬀerence
equal
prove
generic
singularities
types
conﬁned
steps
size
arithmetic
progression
complete
understanding
situation
singularity
types
number
sides
polygon
odd
show
singularity
conﬁnement
holds
generically
every
type
except
worst
case
addition
upper
bound
number
iterations
singularities
last
case
even
seems
complicated
conjectural
answer
types
exhibit
singularity
conﬁnement
geometric
perspective
condition
x2i
x2i+1
indicates
triple
vertices
ai−2
ai+2
collinear
although
one
construct
case
result
violate
condition
quadruples
consecutive
vertices
general
position
bi+
collinear
making
impossible
carry
construction
notion
singularity
conﬁnement
also
geometric
interpretation
singularity
vanishes
steps
one
approximate
nonsingular
polygons
apply
construction
take
limit
ﬁnd
since
fact
bi−
bi−
bi+
max
glick
regular
point
result
procedure
depend
approximations
main
result
geometric
side
straightedge
construction
ﬁrst
deﬁned
iterate
polygon
certain
singularity
types
basic
idea
ﬁrst
order
family
approximations
nonsingular
polygons
data
needed
accomplish
encoded
collection
points
lines
call
decoration
done
iterates
become
well-deﬁned
determine
iterate
procedure
constructs
intermediate
polygons
one
one
paper
organized
follows
section
reviews
previous
work
pen-
tagram
map
including
non-recursive
formula
rational
map
coordinates
map
factors
polynomials
properties
given
section
section
identiﬁes
hierarchy
singularity
types
pentagram
map
establishes
generic
polygons
types
exhibit
singularity
conﬁne-
ment
remainder
paper
addresses
problem
moving
past
singularities
constructing
singular
point
m−1
approach
works
simplest
singularity
type
given
section
along
discussion
limitations
handling
severe
singularities
section
introduces
decorated
polygons
serve
underlying
objects
main
construction
section
develop
procedure
iterated
main
construction
section
states
main
construction
discusses
needed
prove
correctness
given
singularity
type
algorithms
stated
explicitly
contain
steps
nontrivial
accomplish
via
straightedge
construction
appendix
ﬁll
details
steps
following
notation
used
throughout
mod
let
denote
arithmetic
progression
twisted
polygons
denoted
capital
letters
individual
vertices
indexed
either
sides
polygon
i.e
lines
passing
two
consecutive
vertices
denoted
corresponding
lowercase
letter
indexed
using
opposite
indexing
scheme
instance
twisted
polygon
indexed
vertices
denoted
sides
denoted
←−−−−−→
aj+
aj−
acknowledgments
thank
pavlo
pylyavskyy
sergei
tabachnikov
partic-
ularly
sergey
fomin
many
valuable
discussions
course
project
grateful
richard
schwartz
introduced
problem
explained
previous
work
area
pentagram
map
background
cross
ratio
four
real
numbers
deﬁned
deﬁnition
extends
projective
line
gives
projective
invariant
four
points
interested
taking
cross
ratio
four
collinear
points
singularity
confinement
pentagram
map
ak+2
ak+1
ak−2
ak−1
figure
points
involved
deﬁnitions
x2k
x2k+1
projective
plane
dually
cross
ratio
four
lines
intersecting
common
point
consistent
notation
let
denote
cross
ratio
taken
diﬀerent
order
let
twisted
polygon
x-coordinates
deﬁned
schwartz
follows
index
let
x2k
ak−2
ak−1
x2k+1
ak+2
ak+1
←−−−→
akak+1
←−−−→
ak−1ak
←−−−−−→
ak−2ak−1
←−−−−−→
ak−2ak−1
←−−−−−→
ak+1ak+2
see
figure
xj+2n
mentioned
introduction
x2n
give
set
coordinates
←−−−−−→
ak+1ak+2
work
related
quantities
called
y-parameters
denoted
parameters
deﬁned
−xjxj+1
xjxj+1
−xjxj+1
xjxj+1
even
odd
even
odd
yj+2n
due
analogous
property
how-
ever
y2n
give
set
coordinates
satisfy
single
relation
y1y2
y2n
y-parameters
equivalently
deﬁned
using
cross
ratios
see
figure
index
2.1
2.2
y2k
cid:16
y2k+1
ak+1
←−−−→
akak−2
←−−−→
akak−1
←−−−→
akak+1
←−−−→
akak+2
cid:17
←−−−−−→
ak−2ak−1
←−−−→
akak+1
←−−−→
akak+1
←−−−−−→
ak+2ak+3
max
glick
ak+2
ak+1
ak+3
ak+2
ak+1
ak−2
ak−1
ak−2
ak−1
figure
lines
points
used
deﬁnitions
y2k
left
y2k+1
right
y-parameters
transform
pentagram
map
according
-pattern
dynamics
certain
cluster
algebra
used
results
fomin
zelevinsky
give
formulas
iterates
pentagram
map
terms
-polynomials
cluster
algebra
deﬁned
recursively
fj,0
2.3
k+1
fj−3
kfj+3
kfj−1
kfj+1
k−1
y3i+j
yi=−k
theorem
2.1
theorem
4.2
theorem
1.2
let
2.4
2.5


=

xj−3k
k−1
yi=−k
xj+3k
k−1
yi=−k
fj−2
k−1fj+1
yj+1+3i
fj+2
k−1fj−3
yj+1+3i
fj−3
k−1fj+2
fj+1
k−1fj−2
even
odd
fj−1
kfj+1
fj−3
kfj+3
k−1
fj−3
k−1fj+3
k−1
fj−1
k−1fj+1
k−1
even
odd
-polynomials
polynomials
hence
laurent
polynomials
positive
coeﬃcients
simple
combinatorial
description
generating
functions
order
ideals
certain
posets
ﬁrst
studied
elkies
kuperberg
larsen
propp
speciﬁcally
let
set
triples
|r|
|s|
mod
2|s|
2|r|
note
qk+1
disjoint
let
qk+1
∪qk
deﬁne
partial
order
saying
covers
t+1
|r′
−r|+|s′
−s|
singularity
confinement
pentagram
map
-2,2
0,0,2
0,2,2
-1,1
0,1,1
-1,1
0,1,1
0,0,0
-1,0
-1,1,0
-1,0
1,1,0
-1,0
1,0
-1,0
1,0
-2,0
0,0
2,0
figure
poset
left
right
partial
order
restricts
partial
order
let
denote
set
order
ideals
hasse
diagrams
given
figure
theorem
2.2
theorem
6.6
2.6
xi∈j
y3r+s+j
-polynomials
according
1.1
1.2
pentagram
map
singularities
polygons
xjxj+1
i.e.
according
2.4
iterate
singularity
whenever
k−1
section
examine
circumstances
certain
forces
-polynomial
vanish
results
along
lines
indicate
many
steps
given
singularity
persists
purpose
section
relax
assumptions
yi+2n
y1y2
y2n
instead
consider
polynomials
countable
collection
variables
way
notation
let
k|s
polynomial
obtained
substituting
alternating
sign
matrix
square
matrix
non-zero
entries
row
column
alternate
sign
sum
entries
row
column
let
asm
denote
set
alternating
sign
matrices
elkies
kuperberg
larsen
propp
establish
connections
alternat-
ing
sign
matrices
posets
speciﬁcally
give
bijection
asm
alternating
sign
matrices
asm
asm
called
compatible
corresponding
order
ideals
qk+1
property
order
ideal
qk+1
compatible
pairs
alternating
sign
matrices
bijection
max
glick
explicitly
state
bijection
asm
instead
list
needed
properties
bijection
following
two
lemmas
statements
easily
deduced
results
lemma
3.1.
let
asm
suppose
entries
equal
namely
entries
alternating
sign
matrices
asm
compatible
moreover
exist
order
ideal
qk+1
elements
qk+1
map
i+j−k−1
−i+j
sends
order
ideal
qk+1
corresponds
matrix
compatible
way
notation
let
asm
matrix
corresponding
order
ideal
lemma
lemma
3.2.
let
asm
suppose
a11
akk
implies
a1k
ak1
let
asm
identical
except
corners
let
let
order
ideals
corresponding
respectively
contains
exactly
one
element
|r|
|s|
mod
let
qk+1
order
ideals
corresponding
respectively
contains
exactly
one
element
|r|
|s|
mod
deﬁne
weight
alternating
sign
matrix
respect
integer
order
ideal
corresponding
2.6
y3r+s+j
=xa
sum
compatible
pairs
asm
asm
recall
mod
therefore
monomial
mod
mod
monomial
proposition
3.3
3.1
xa∈asm
yail=1
yj+2i+4l−3k−3
proof
need
show
ﬁxed
asm
yail=1
yj+2i+4l−3k−3
sum
compatible
lemma
3.1
sides
terms
number
moreover
lowest
degree
term
singularity
confinement
pentagram
map
sides
let
order
ideal
corresponding
ail
lemma
3.1
says
possible
add
get
new
order
ideal
corresponding
matrix
compatible
computing
y3r+s+j
yj+2i+4l−3k−3
lemma
3.1
done
arbitrary
subsets
set
proposition
follows
cid:3


let
set
integers
say
matrix
asm
avoids
ail
range
index
takes
values
array
...
...
...
3.2
hence
avoids
entries
equal
avoid
entries
array
contained
let
set
integers
use
3.1
compute
k|s
substi-
tuting
asm
avoid
corresponding
term
sum
factor
hence
whole
term
vanish
k|s
corollary
3.4.
fix
let
mod
3.3
k|s
=xa
yail=1
yj+2i+4l−3k−3
sum
asm
avoid
particular
exists
k|s
unfortunately
exist
matrices
asm
avoiding
safe
conclude
k|s
indeed
recall
monomial
mod
substitute
sign
introduced
therefore
possible
diﬀerent
terms
3.3
cancel
least
conclude
k|s
exists
unique
avoiding
proposition
3.5.
fix
let
either
k|s
proof
suppose
consists
precisely
elements
row
3.2
every
asm
must
least
one
entry
equal
row
deﬁnition
alternating
sign
matrices
corollary
3.4
k|s
similarly
corresponds
column
3.2
result
holds
cid:3
max
glick
lemma
3.6.
fix
let
odd
even
even
mod
mod
=
set
entries
3.2
contained
j+l−2k
j+l+σ
j+l+2k
corresponds
permutation
matrix
proof
consider
knight
path
matrix
starts
entry
ﬁrst
column
moves
one
column
right
two
rows
step
suppose
rows
ordered
cyclically
whenever
knight
passes
top
matrix
wraps
around
bottom
continue
knight
reaches
last
column
placing
everywhere
visits
one
possible
resulting
matrix


wrap
arounds
divide
path
three
segments
one
might
length
zero
entries
3.2
constant
along
segment
diﬀer
consecutive
segments
odd
result
permutation
matrix
correspond
entries
array
equal
one
check
set
values
arise
manner
precisely
even
resulting
matrix
permutation
matrix
one
obtained
shifting
middle
segment
either
one
row
instance
following
example
middle
segment
shifted




eﬀect
corresponding
entry
array
accounted
adding
cid:3
proposition
3.7.
fix
let
lemma
3.6.
let
permutation
matrix
conclusion
lemma
3.6.
k|s
yj+l−2k
yj+l+σ
yj+l+2k
nonnegative
integers
particular
k|s
singularity
confinement
pentagram
map
proof
lemma
3.6
entries
3.2
contained
except
correspond-
ing
one
hand
means
avoids
hand
let
asm
matrix
avoiding
column
must
least
one
entry
equal
occur
away
elements
column
must
exactly
one
must
place
column
single
fact
hence
element
asm
avoiding
proposition
follows
corollary
3.4
sizes
three
segments
knight
path
deﬁned
proof
lemma
3.6
cid:3
corollary
3.8.
fix
let
k|s
proof
contained
corresponding
one
proposition
3.7.
fewer
substitutions
made
k|s
remains
nonzero
cid:3
corollary
3.9.
let
ﬁnite
arithmetic
sequence
|s|
consecutive
terms
diﬀer
elements
parity
k|s
proof
may
assume
without
loss
generality
indices
y-variables
depends
case
contained
corollary
3.8
still
k|s
cid:3
proposition
3.5
corollary
3.9
give
complete
picture
k|s
form
use
results
prove
conﬁnement
certain
singularity
types
next
section
assume
large
relative
|s|
relations
among
y-variables
enter
play
contrast
following
proposition
pertains
severe
singularity
type
reintroduce
relations
point
proposition
3.10.
suppose
odd
assume
yi+2n
y2n
let
odd
evaluated
input
provided
proof
first
suppose
implies
odd
even
proposition
3.7
moreover
choose
mod
mod
proposition
3.7
max
glick
monomial
y2n
since
zero
let
case
even
odd
since
yi+2n
consider
entries
3.2
modulo
example
result


since
odd
row
column
contains
single
repeat
namely
ﬁrst
last
entry
interested
matrices
asm
whose
avoid
hence
correspond
elements
array
equal
two
cases
corner
entries
array
nonzero
situation
example
always
single
row
column
interior
array
start
end
every
row
column
single
unique
alternating
sign
matrix
avoiding
case
everywhere
array
single
needed
matrix
corresponding
example


matrix
always
entries
equal
corollary
3.4
n+2
monomial
lastly
still
assuming
corner
entries
array
equal
case
looks
like


singularity
confinement
pentagram
map
general
two
alternating
sign
matrices
avoiding
permu-
tation
matrices




call
respectively
let
corollary
3.4
n+1
lemma
3.2
determines
order
ideals
corresponding
relate
using
result
one
check
weights
related
y1y3
y2n−1
yn+1
y2y4
y2n−2
n+2
consequently
y0y1
y2n−1
ny0
y2y4
y2n−2
n+1
y0y1y2
y2n−1
y2n−2
n+1
n+2
cid:3
let
let
singularity
patterns
y2i
y2j
reason
diﬀerent
notation
follows
lemma
4.1
lemma
7.2
let
ai−2
ai+2
collinear
aj−2
aj+2
concurrent
deﬁne
way
subvarieties
let
=\i∈s
=\i∈s
max
glick
instance
3,5
x3∩x5
set
twisted
polygons
collinear
y2i
therefore
replace
2.4
k|2s
restricted
polynomials
nonzero
corresponding
iterate
pentagram
map
deﬁned
generically
theorem
4.2.
let
n/3
let
cid:20
cid:21
map
singular
m+2
nonsingular
generic
moreover
m+2
words
theorem
says
twisted
polygon
ai−
m+1
ai−
m−1
ai−
m−3
ai+
m+1
collinear
singular
point
ﬁrst
iterates
pentagram
map
moreover
generic
singular
point
m+2
sides
m+2
pass
alternately
two
points
bi−
m+3
bi−
m+1
bi−
m−1
bi+
m+3
lemma
4.3.
m|2s
2s′
proof
suppose
2s′
hence
proposition
3.5
m|2s
cid:3
lemma
4.4.
k|2s
odd
proof
would
seem
follow
immediately
corollary
3.9.
diﬃculty
assumption
yi+2n
relaxed
section
recall
depends
total
consecutive
variables
assuming
n/3
follows
assuming
yi+2n
eﬀect
y-variables
appearing
cid:3
proof
theorem
4.2.
lemma
4.3
2.4
m+1
singular
lemma
applied
smaller
implies
also
singular
let
lemma
4.4
shows
none
factors
expression
2.4
identically
zero
hence
2.4
deﬁnes
m+2
generically
remains
show
image
let
m+2
deﬁned
let
let
given
lemma
4.3
f2j
therefore
2.3
f2j−3
m+1f2j+3
m+1
m2j
m+1f2j−1
m+1f2j+1
m+1
rearranging
using
2.5
m2j
m+1
f2j−3
m+1f2j+3
m+1
f2j−1
m+1f2j+1
m+1
y2j
singularity
confinement
pentagram
map
justiﬁed
m+2
deﬁned
factors
divided
nonzero
y2j
desired
cid:3
roles
interchanged
theorem
4.2.
apparently
instance
projective
duality
theorem
4.5.
let
theorem
4.2.
map
singular
m+2
nonsingular
generic
moreover
m+2
proof
proof
essentially
obtained
switching
throughout
proofs
theorem
4.2
lemmas
diﬀerence
proof
uti-
lizes
diﬀerent
cases
proposition
3.5
corollary
3.9
namely
cases
involving
arithmetic
sequences
common
diﬀerence
cid:3
singularity
conﬁnement
arithmetic
sequence
whose
terms
diﬀer
generally
disjoint
union
sequences
far
apart
corresponding
singularities
aﬀect
hence
singularity
conﬁnement
holds
number
steps
needed
get
past
singularity
dictated
length
largest
disjoint
sequences
singularity
types
form
instance
consider
theorem
4.5
deﬁned
generically
3,4
7,8
one
check
singular
although
another
step
suﬃce
move
past
singularity
general
types
diﬃcult
predict
many
steps
corresponding
singularities
last
however
would
seem
singularity
conﬁnement
hold
outside
exceptional
cases
odd
exceptional
type
moreover
generic
corresponding
singularity
lasts
steps
establish
considering
worst
case
|s|
proposition
4.6.
suppose
odd
let
n+1
nonsingular
generic
proof
suppose
without
loss
generality
y2n−2
always
yj+2n
y1y2
y2n
proposition
3.10
implies
generically
odd
therefore
n+1
generically
deﬁned
2.4
cid:3
remark
4.7.
fact
proposition
3.10
says
namely
relevant
polynomials
never
vanish
unless
assumption
quadruples
consecutive
vertices
general
position
forces
nonzero
singularities
n+1
occur
y2n
hence
n+1
restricts
regular
map
corollary
4.8.
suppose
odd
n+1
nonsingular
generic
proof
since
exists
|s′|
since
n+1
nonsingular
generic
particular
map
deﬁned
proposition
4.6.
necessarily
also
follows
n+1
deﬁned
generically
cid:3
max
glick
course
general
usually
case
deﬁned
corollary
ensures
steps
suﬃcient
appears
also
true
even
outside
exceptional
cases
state
conjecture
conjecture
4.9.
suppose
even
singularity
conﬁnement
holds
generically
unless
whenever
singularity
conﬁnement
holds
type
exists
generic
singularities
type
last
steps
i.e
singular
m+1
remark
4.10.
cases
singularity
conﬁnement
fails
hold
quite
ex-
treme
vertices
lying
two
lines
follows
vertices
equal
even
say
contains
half
vertices
collinear
contained
common
line
amazingly
even
ﬁnite
number
iterations
takes
theorem
theorem
7.9
similar
results
likely
hold
exceptional
singularity
types
straightedge
constructions
first
attempt
let
singular
point
remainder
paper
focuses
problem
constructing
one
possible
approach
would
compute
x-coordinates
plug
2.4
2.6
ﬁnd
x-coordinates
use
construct
process
would
computationally
expensive
number
terms
grows
superexponentially
point
approach
drawback
ignores
geometry
pentagram
map
alternative
could
choose
one-parameter
family
twisted
polygons
varying
continuously
regular
point
small
obtain
iterating
geometric
con-
struction
deﬁning
continuity
given
limt→0
found
numerically
method
perhaps
feasible
involves
limiting
proce-
dure
satisfying
would
ﬁnite
construction
preferably
one
carried
straightedge
alone
case
pentagram
map
section
introduce
iterative
approach
ﬁnding
straightedge
construction
works
simple
situations
idea
attempt
make
sense
polygon
despite
presence
singularity
let
ﬁxing
let
appropriate
index
let
lim
t→0
say
well-deﬁned
limit
always
exists
independent
choice
curve
deﬁne
sides
way
fact
possible
well-deﬁned
despite
singularity
confinement
pentagram
map
singularity
would
simply
indicate
resulting
polygon
fails
satisfy
property
quadruples
consecutive
vertices
general
position
needed
x-coordinates
deﬁned
suppose
singular
point
addition
assume
vertices
sides
well-deﬁned
possible
construct
components
intermediate
polygons
successively
ideally
individual
side
vertex
constructed
simple
procedure
depending
nearby
objects
basic
local
rules
usual
deﬁnition
pentagram
map
namely
index
←−−−−→
ai−1ai+1
bj−
bj+
bj+
index
rules
work
ai−1
ai+1
bj−
respectively
rules
needed
handle
cases
next
simplest
rule
involves
triple
ratios
six
point
analogue
cross
ratios
deﬁnition
5.1.
let
points
plane
collinear
collinear
collinear
triple
ratio
points
deﬁned
instance
lies
negative
otherwise
refers
ratio
two
lengths
taken
positive
need
following
properties
triple
ratios
found
instance
proposition
5.2
triple
ratios
invariant
projective
transformations
ceva
theorem
lines
concurrent
menelaus
theorem
collinear
proposition
5.3.
suppose
regular
point
let
bi−
bi−
bi+
bi+
proof
triple
ratio
makes
sense
satisﬁes
condition
menelaus
theorem
clear
figure
cid:3
imagine
continuously
deforming
polygons
six
points
collinear
relation
holds
polygons
deformed
continues
hold
limit
particular
ﬁve
points
well-deﬁned
collinear
generically
sixth
also
well-deﬁned
unique
point
line
max
glick
bi+
bi−
bi−
bi+
figure
menelaus
theorem
bi−
index
bi−
bi+
bi+
bj−
bj+
bj−
bj+
figure
conﬁguration
lines
dual
conﬁguration
points
figure
relation
holds
stated
rule
bi−
collinear
index
bi−
bi+
bi+
5.1
tripleconjugate
bi−
bi−
bi+
bi+
tripleconjugate
function
inputs
ﬁve
collinear
points
outputs
unique
point
common
line
ordered
sextuple
sides
bj−
bj+
bj−
dences
vertices
bi−
analogous
rule
index
sides
bj−
concurrent
bi+
bi−
bi+
bj+
satisfy
inci-
see
figure
get
bj+
bj+
bj−
5.2
tripleconjugate
bj−
bj+
bj+
bj−
singularity
confinement
pentagram
map
b4.5
b5.5
b1.5
b0.5
b7.5
b6.5
b2.5
b3.5
figure
construction
rules
already
enough
handle
singularities
simplest
type
full
construction
described
next
subsection
following
subsection
explains
diﬃculty
handling
complicated
singularities
5.1.
map
case
theorem
4.2
says
restricts
rational
map
assume
without
loss
generality
throughout
subsection
assume
let
since
collinear
let
denote
line
containing
following
denote
elements
respectively
start
constructing
done
via
usual
pentagram
map
note
←−−−−→
ai−1ai+1
bj−
construct
therefore
b1.5
b2.5
b3.5
b4.5
lie
moreover
∩bj+
b2.5
b3.5
let
common
point
construction
shown
figure
generically
bj−1
bj+1
sides
constructed
←−−−−−→
bj−1bj+1
note
c2.5
c3.5
hence
use
c2.5
c3.5
construct
however
b1.5
b2.5
b3,5
b4.5
lie
rule
5.1
applies
tripleconjugate
b1.5
b2.5
b4.5
b3.5
usual
←−−−−→
ci+
ci−
particular
c1.5
c2.5
←−−−→
b0.5b2.5
b2.5
c3.5
c4.5
←−−−→
b3.5b5.5
b3.5
figure
shows
construction
max
glick
b1.5
b4.5
b0.5
b7.5
b6.5
b5.5
figure
construction
b2.5
b3.5
d4.5
d1.5
d5.5
d2.5
d3.5
d7.5
d0.5
d6.5
figure
construction
last
diﬃculty
constructing
side
since
however
c1.5
c2.5
c3.5
c4.5
pass
5.2
tripleconjugate
c1.5
c3.5
c4.5
c2.5
particular
contains
letting
ci−1
ci+1
contains
contains
well
veriﬁes
finally
construction
vertices
constructed
dj−
given
figure
full
construction
summarized
algorithm
dj+
remark
5.4.
algorithms
paper
carried
straightedge
con-
structions
completely
apparent
algorithm
details
provided
surrounding
text
and/or
appendix
example
algorithm
uses
function
tripleconjugate
construction
given
algorithm
appendix
addition
usual
operations
projective
singularity
confinement
pentagram
map
algorithm
require
collinear
←−−−−→
ai−1ai+1
end
bj−
bj+
end
←−−−−−→
bj−1bj+1
end
ci−
ci+
end
tripleconjugate
b1.5
b2.5
b4.5
b3.5
←−−−−→
ci−1ci+1
end
tripleconjugate
c1.5
c3.5
c4.5
c2.5
dj−
dj+
end
return
geometry
ﬁnding
line
two
points
intersection
point
two
lines
assume
primitive
function
randompoint
returns
next
arbitrarily
long
sequence
points
plane
algorithms
claimed
behave
correctly
generic
choices
points
convenience
deﬁne
←−−−−−−−−−−−−−−−−−−−−−−→
randompoint
randompoint
randomline
randompointon
randomline
randomlinethrough
←−−−−−−−−−−−→
randompoint
5.2.
map
3,5
3.5,4.5
next
simplest
case
the-
orem
4.2
concerns
singularity
disappears
four
steps
speciﬁcally
taking
map
3,5
3.5,4.5
suppose
3,5
means
collinear
let
common
line
3.5,4.5
i.e.
e1.5
e3.5
e5.5
concurrent
e2.5
e4.5
e6.5
also
concurrent
attempt
successively
construct
intermediate
polygons
namely
however
case
polygons
completely
well-deﬁned
let
range
respectively
constructions
follow
illustrated
figures
10–13
constructed
using
standard
pentagram
map
case
three
sides
equal
namely
result
six
max
glick
b1.5
b0.5
b7.5
b6.5
b8.5
figure
10.
construction
3,5
b2.5
b3.5
b4.5
b5.5
b1.5
b0.5
b6.5
b7.5
b8.5
figure
11.
construction
3,5
b2.5
b3.5
b4.5
b5.5
d1.5
d0.5
d6.5
d7.5
d8.5
figure
12.
construction
3,5
d2.5
d4.5
d3.5
d5.5
singularity
confinement
pentagram
map
d1.5
d7.5
d6.5
d0.5
d8.5
figure
13.
construction
3,5
d2.5
d4.5
d3.5
d5.5
consecutive
vertices
b1.5
b2.5
b6.5
lie
moreover
b2.5
b3.5
b4.5
b5.5
sides
←−−−−−→
bj−1bj+1
deﬁned
although
c2.5
c3.5
c4.5
c5.5
equal
ﬁrst
problems
arise
constructing
vertices
general
depends
vertices
original
polygon
assumption
irrelevant
construction
puts
context
previous
subsection
tripleconjugate
b1.5
b2.5
b4.5
b3.5
symmetry
similar
construction
tripleconjugate
b3.5
b4.5
b6.5
b5.5
situation
complicated
ordinarily
would
use
fact
b2.5
b3.5
b5.5
b4.5
solve
however
b2.5
b3.5
b5.5
b4.5
triple
ratio
comes
0/0
use
method
construct
fact
turns
simply
well-deﬁned
fact
intermediate
vertex
well-deﬁned
causes
great
diﬃculty
current
approach
devising
straightedge
constructions
following
sections
demonstrate
enriching
input
ﬁrst-order
data
counteracts
diﬃculty
leads
general
algorithm
moving
ﬁnish
describing
construction
particular
present
context
works
around
matter
max
glick
dj+
recall
sides
c2.5
c5.5
equal
vertices
←−→
lie
line
know
c4c6
even
though
well-deﬁned
rest
sides
constructed
similarly
note
also
equals
sides
generic
construct
dj−
3.5
4.5.
two
vertices
work
backwards
know
ultimately
e1.5
e3.5
e5.5
concurrent
e1.5
e3.5
d2.5
e3.5
e5.5
d4.5
d4.5
d2.5
similarly
fact
e2.5
e4.5
e6.5
concurrent
implies
d3.5
d5.5
←−→
c2c4
←−−−−−→
dj−1dj+1
besides
3.5
4.5.
usual
construction
fails
e3.5
d2.5
d4.5
construction
involving
triple
conjugates
also
fails
however
e3.5
certainly
well-deﬁned
side
trial
error
discovered
following
construction
e3.5
symmetry
one
e4.5
ﬁnal
step
let
proposition
5.5.
assumptions
subsection
←−−−−−−−−−−−−−−→
←−−−−−−→
c6.5
←−−−−−−−−−−−−−−→
←−−−−−−→
c1.5
e3.5
e4.5
remark
5.6.
principle
results
like
proposition
5.5
proven
computation-
ally
instances
unaware
illuminating
proof
simply
fall
back
sort
reasoning
computations
required
generally
quite
tedious
tend
omit
decorated
polygons
let
twisted
polygon
singular
point
explained
previous
section
attempt
deﬁne
limit
curve
space
polygons
passing
saw
section
5.2
result
sometimes
depends
choice
curve
suggests
dif-
ferent
approach
constructing
ﬁrst
nonsingular
iterate
start
ﬁxing
arbitrarily
one-parameter
family
respect
choice
interme-
diate
polygons
well-deﬁned
constructing
turn
eventually
get
since
singular
point
ﬁnal
result
depend
choice
working
actual
curves
would
diﬃcult
however
actually
matter
ﬁrst
order
behavior
curve
near
information
encoded
using
geometric
data
call
decorations
let
point
projective
plane
let
smooth
curve
deﬁne
associated
decoration
denoted
tangent
line
lim
t→0
←−−→
deﬁned
line
passing
token
line
projective
plane
thought
point
dual
plane
given
curve
point
deﬁne
singularity
confinement
pentagram
map
figure
14.
decorated
triangle
decoration
lim
t→0
deﬁned
point
lying
finally
let
twisted
polygon
curve
space
twisted
polygons
determines
curve
plane
vertex
curve
dual
plane
side
deﬁne
decorations
individual
objects
deﬁnition
6.1.
decorated
polygon
twisted
polygon
together
dec-
orations
vertices
sides
induced
curve
space
twisted
polygons
decorated
polygons
denoted
appropriate
script
letter
instance
underlying
polygon
decorated
polygon
called
possible
diﬀerent
curves
give
rise
decorated
polygon
corresponds
whole
class
curves
call
curve
class
representative
remark
6.2.
deﬁnition
6.1
refers
space
twisted
polygons
confused
spaces
projective
equivalence
classes
twisted
polygons
general
working
actual
polygons
instead
equivalence
classes
polygons
remainder
paper
given
collection
geometric
objects
satisfy
certain
incidences
e.g
vertices
sides
polygon
consistent
choice
decorations
objects
may
satisfy
relations
simplest
example
relation
occurs
closed
triangle
proposition
6.3.
△abc
let
see
figure
let
curves
vertices
use
deﬁne
←−−−−→
curves
corresponding
sides
e.g
corresponding
decorations
satisfy
6.1
max
glick
figure
15.
points
lines
involved
lemma
6.4
lemma
6.4.
let
△a′b′c
another
triangle
←−→
a′b′
see
figure
←−→
b′c
←−→
a′c
6.2
←−→
aa′
←−→
bb′
proof
see
remark
5.6
cid:3
proof
proposition
6.3.
lemma
6.4
take
consider
limit
goes
limit
vertices
sides
△a′b′c
approach
counterparts
△abc
deﬁnition
aa′
approaches
similarly
vertices
sides
limit
6.2
precisely
6.1
cid:3
remark
6.5.
relation
similar
6.1
among
decorations
closed
n-gon
moreover
relation
holds
hence
one
pick
vertex
decorations
sides
decorations
way
around
independently
last
decoration
determined
space
decorations
ﬁxed
polygon
dimension
one
check
space
naturally
corresponds
projectivized
tangent
space
within
space
closed
n-gons
similar
statement
probably
true
twisted
polygons
understand
relations
among
individual
decorations
next
proposition
shows
repeated
applications
6.1
used
extend
pentagram
map
decorated
polygons
proposition
6.6.
let
curve
space
polygons
let
let
corresponding
decorations
respectively
uniquely
determined
proof
given
index
consider
triangle
vertices
ai−1
ai+1
see
figure
three
vertices
two
sides
coming
←−−−−→
last
side
ai−1ai+1
applying
proposition
6.3
triangle
expresses
terms
next
consider
triangle
vertices
aj−
index
see
figure
two
vertices
one
sides
belong
aj+
singularity
confinement
pentagram
map
ai−
ai+
ai−1
ai+1
figure
16.
triangle
used
compute
aj−
aj+
bj−
bj+
figure
17.
triangle
used
compute
two
sides
fact
sides
namely
←−−−→
aj−
←−−−→
aj+
bj+
bj−
decorated
previous
step
another
application
proposition
6.3
determines
cid:3
procedure
construct
thought
lift
pentagram
map
space
decorated
polygons
distinguish
operation
original
map
write
construction
deﬁning
given
algorithm
algorithm
←−−−−→
ai−1ai+1
decorateside
end
decoratevertex
bj+
bj−
end
return
max
glick
subroutines
decorateside
decoratevertex
build
triangles
figures
respectively
use
6.1
compute
desired
decoration
remark
6.7.
using
decorated
polygons
map
tools
straightedge
constructions
however
likely
interesting
objects
study
right
immediate
questions
come
mind
would
good
set
coordinates
space
decorated
polygons
coordinates
map
take
nice
form
deﬁne
discrete
integrable
system
degenerations
saw
previous
section
6.1
identity
needed
apply
pentagram
map
generic
decorated
polygon
however
motivation
introducing
decorations
handle
degenerate
cases
section
introduce
methods
eventually
used
apply
pentagram
map
large
class
degenerate
polygons
everything
expressed
terms
local
rules
involving
triangles
complete
quadrilaterals
7.1.
triangles
let
curves
plane
passing
points
time
assume
points
general
position
let
denote
sides
triangle
form
allow
collinear
even
equal
however
assume
limits
lim
t→0
lim
t→0
lim
t→0
exist
assume
limits
deﬁning
decorations
exist
well
proposition
6.3
allow
collinear
however
continuity
6.1
still
holds
present
context
proposition
7.1.
assume
decorations
triangle
generic
i.e
dis-
tinct
vertices
sides
triangle
vertex
uniquely
determined
sides
vertices
corresponding
decorations
proof
assume
two
cases
depending
equals
sides
general
p1p2
p2p3
p3p4
p4p5
p5p6
p6p1
p1p2
p2p3
p3p4
p4p1
singularity
confinement
pentagram
map
figure
18.
complete
quadrilateral
6.1
simpliﬁes
7.1
note
dependence
disappeared
identity
determines
given
geometric
data
alternately
suppose
whenever
p1p2
p2p3
p1p2
p2p1
p3p4
p4p5
p3p4
p4p3
p5p6
p6p1
p5p6
p6p5
consequently
6.1
becomes
construct
cid:3
sum
triangle
6.1
used
construct
vertex
downside
identity
longer
used
determine
decoration
fact
independent
rest
triangle
need
data
construct
vertex
decorations
degeneracies
occur
7.2.
complete
quadrilaterals
complete
quadrilateral
projective
conﬁgura-
tion
consisting
four
lines
called
sides
general
position
together
six
points
called
vertices
intersect
call
sides
call
vertices
figure
18.
triangles
deﬁne
degenerate
complete
quadrilaterals
conﬁgura-
tions
obtained
limit
ordinary
complete
quadrilaterals
precisely
let
smooth
curves
deﬁne
com-
plete
quadrilateral
time
let
sides
could
equal
assume
decorations
deﬁned
max
glick
proposition
7.2.
consider
degenerate
complete
quadrilateral
vertex
decoration
uniquely
determined
vertices
sides
decorations
proof
menelaus
theorem
according
appendix
constructed
vertices
using
construction
figure
23.
idea
present
construction
build
conﬁguration
ﬁgure
time
choose
generically
plane
point
lines
reason
names
clear
shortly
deﬁne
←−−→
note
lim
t→0
lim
t→0
←−−→
cc∗
justiﬁes
notation
similar
remarks
hold
deﬁning
←−−−−→
←−−−−−→
←−−−−→
←−−−−→
particular
get
time
conﬁguration
figure
23.
collinear
proof
fact
given
appendix
generalizes
show
collinear
let
denote
common
line
←−−−−→
way
notation
let
←−−−−−→
←−−−−→
←−−−−→
given
decorations
outset
chose
arbitrarily
decorations
generic
triangle
knowing
ﬁve
six
decorations
determines
sixth
proposition
6.3.
fact
used
ﬁnd
missing
decorations
conﬁguration
start
use
ﬁrst
triangle
figure
second
triangle
ﬁnd
decorations
found
ﬁnd
third
triangle
ﬁgure
used
determine
similar
method
used
ﬁnd
finally
use
ﬁrst
triangle
figure
ﬁnd
cid:3
triangle
ﬁnd
7.3.
degenerate
polygons
degenerate
polygon
sequences
points
interlacing
sequence
lines
occur
limits
vertices
sides
respectively
twisted
polygons
precisely
twisted
polygon
appropriate
limits
deﬁned
get
degenerate
polygon
vertices
limt→0
sides
limt→0
fixing
curve
get
decorations
using
understanding
degenerate
triangles
complete
quadrilaterals
ready
state
version
works
degenerate
polygons
explained
algorithm
requires
two
consecutive
iterates
pentagram
map
input
output
iterate
follows
two
new
singularity
confinement
pentagram
map
figure
19.
triangles
used
ﬁnd
ﬁnally
figure
20.
triangles
used
ﬁnd
procedure
called
˜t2
given
algorithm
algorithm
ranges
index
set
ranges
index
set
description
subroutines
appearing
algorithm
follow
algorithm
˜t2
constructside2
end
decorateside2
end
constructvertex2
end
decoratevertex2
end
return
max
glick
bi−
bi+
ci−
ci+
figure
21.
triangle
used
constructvertex2
outline
algorithm
original
version
first
sides
constructed
side
decorations
vertices
ﬁnally
vertex
decorations
individual
step
though
made
complicated
possibility
degeneracies
subroutine
constructvertex2
works
triangle
pictured
figure
21.
components
triangle
besides
already
constructed
hence
proposition
7.1
always
possible
construct
ci+
subroutine
decoratevertex2
begins
triangle
ci−
ci+
6.1
used
compute
otherwise
data
needed
consider
complete
quadrilateral
figure
assuming
two
sides
namely
ci−
equal
forces
ﬁve
vertices
lie
common
line
generically
ﬁve
vertices
distinct
forcing
two
remaining
sides
namely
bi−1
bi+1
complete
quadrilateral
equal
ci−
puts
situation
proposition
7.2.
vertices
besides
sides
decorated
already
procedure
determine
decoration
ci+
used
fact
two
sides
complete
quadrilateral
equal
generically
must
equal
however
non-generic
example
fails
arise
practice
instance
figures
c3.5
c4.5
diﬀerent
situations
decoratevertex2
simply
return
random
decoration
i.e.
random
line
passing
subroutines
constructside2
decorateside2
behave
like
constructvertex2
decoratevertex2
respectively
diﬀerence
operate
conﬁg-
urations
projectively
dual
ones
figures
first
figure
shows
triangle
used
constructside2
procedure
constructs
dual
manner
constructvertex2
ﬁnds
figure
21.
similarly
figure
contains
conﬁguration
projectively
dual
com-
via
projective
plete
quadrilateral
figure
decorateside2
ﬁnd
dual
construction
used
decoratevertex2
case
decoratevertex2
outputs
random
line
analogous
case
decorateside2
currently
justiﬁed
however
cases
covered
propositions
7.1
7.2.
hence
following
correctness
property
algorithm
singularity
confinement
pentagram
map
bj−
bj+
bj−1
bj+1
figure
22.
triangle
used
constructside2
proposition
7.3.
let
curve
space
twisted
polygons
generic
away
let
let
decorated
polygons
associated
curves
suppose
7.2
7.3
bj−1
bj+1
aj−
aj+
bj−1
ci−
ci+
bi−1
bi+1
ci−
run
vertex
indices
respectively
˜t2
speciﬁcally
7.2
fails
decorateside2
chooses
random
decoration
7.3
fails
decoratevertex2
chooses
ran-
dom
decoration
otherwise
algorithm
˜t2
behaves
deterministically
correctly
main
algorithm
goal
main
algorithm
construct
usual
construction
fails
i.e
singular
point
various
according
previous
section
typically
possible
construct
decorate
given
corresponding
decorations
even
singularities
arise
main
construction
given
algorithm
simply
iterates
procedure
algorithm
main
decoraterandomly
iterates
iterates
iterates
˜t2
iterates
iterates
end
iterates
return
given
singularity
conﬁnement
holds
let
smallest
positive
integer
generically
deﬁned
want
say
generic
main
algorithm
given
input
produces
simplest
singularity
types
result
follows
propositions
6.6
7.3.
max
glick
complicated
diﬃculty
arises
assumptions
7.2
7.3
proposition
7.3
hold
every
step
hence
applications
˜t2
main
algorithm
produce
random
decorations
prove
correctness
algorithm
necessary
determine
steps
occurs
demonstrate
outcome
independent
random
choices
focus
attention
types
covered
theorem
4.2.
taking
convenience
theorem
let
suppose
generic
tracing
beginning
main
algorithm
let
decoration
let
let
˜t2
since
lie
common
line
say
follows
see
e.g
figures
−m+1/2
m−1/2
consequently
condition
7.3
holds
−m+1
m−1
fails
assuming
corresponding
decorated
randomly
establish
main
m+2
need
prove
two
facts
ﬁrst
output
algorithm
depend
decorations
chosen
randomly
given
check
computationally
showing
choice
decorations
possible
appropriate
choice
representative
second
fact
violations
7.2
7.3
occur
computing
iterates
last
step
given
suﬃces
check
fact
true
single
follows
generic
examples
general
proof
necessary
facts
veriﬁed
hold
ﬁrst
several
values
assuming
repeatedly
apply
proposition
7.3
conclude
iterates
decoration
corresponding
curve
curve
last
step
condition
7.2
fail
places
iterates
randomly
decorated
sides
however
sides
iterates
correct
proving
underlying
polygon
fact
m+2
hence
get
main
algorithm
works
correctly
polygons
type
small
expect
result
holds
remark
8.1.
main
algorithm
stated
without
regard
particular
singularity
type
hence
potential
work
greater
generality
discussed
experiments
indicate
algorithm
work
many
singularity
types
simplest
types
fails
similar
appendix
basic
constructions
appendix
states
proves
straightedge
constructions
primitives
used
algorithms
throughout
paper
ﬁrst
namely
tripleconjugate
given
algorithm
construction
shown
pavlo
pylyavskyy
algorithm
constructs
points
menelaus
conﬁguration
see
figure
therefore
applying
projective
transformation
may
assume
point
inﬁnity
←−→
dd′
pass
point
must
parallel
lines
←−→
←−→
bb′
singularity
confinement
pentagram
map
algorithm
tripleconjugate
randompoint
randompointon
return
←−→
b′d′
←−→
figure
23.
construction
tripleconjugate
therefore
△abb′
similar
△acc
△ecc
′d′
d′e
follows
also
△edd′
similar
desired
next
algorithm
inputs
four
points
one
line
three
points
another
exists
unique
projective
transformation
ﬁrst
line
second
taking
algorithm
returns
result
applying
projective
transformation
algorithm
projectivetransformation
aa′
randomlinethrough
randompointon
b′′
d′′
return
←−→
b′′b′
←−→
d′′q
←−→
′′c
←−→
a′b′
algorithm
selects
line
point
projection
onto
sends
images
called
b′′
respectively
max
glick
b′′
figure
24.
part
construction
used
projectivetransformation
constructed
projection
onto
target
line
sends
b′′
necessarily
ﬁxing
see
figure
hence
composition
two
projections
desired
projective
transformation
applying
gives
output
cross
ratios
invariant
projective
transformation
hence
unique
point
line
containing
property
use
construction
ﬁnd
point
satisfying
7.1
appears
complicated
situation
one
cross
ratios
inverted
also
points
lines
involved
identity
expressed
terms
points
alone
using
fact
line
reciprocal
eliminated
reordering
via
property
another
component
several
algorithms
involves
ﬁnding
one
point
line
6.1
terms
others
similar
remarks
possible
cast
problem
involving
points
alone
namely
construct
points
assuming
points
assumed
collinear
triples
required
deﬁnition
triple
ratios
lemma
a.1
←−−−−−−−−→
see
figure
proof
point
particular
chosen
ceva
theorem
guarantees
cid:3
light
lemma
easy
construct
point
singularity
confinement
pentagram
map
figure
25.
construction
point
satisfying
algorithm
projectivetransformation2
←−−−−−−−−→
←−−−−−−−−−−→
←−→
b′e′
←−→
a′d′
←−→
a′e′
projectivetransformation
return
references
elkies
kuperberg
larsen
propp
alternating-sign
matrices
domino
tilings
algebraic
combin
1992
111–132
fomin
zelevinsky
cluster
algebras
coeﬃcients
compos
math
143
2007
112–164
glick
pentagram
map
y-patterns
adv
math
227
2011
1019–1045
grammaticos
ramani
papageorgiou
integrable
mappings
painlev´e
property
phys
rev
lett
1991
1825–1828
ovsienko
schwartz
tabachnikov
pentagram
map
discrete
integrable
system
comm
math
phys
299
2010
409-446
ovsienko
schwartz
tabachnikov
liouville-arnold
integrability
pentagram
map
closed
polygons
arxiv:1107.3633
richter-gibert
perspectives
projective
geometry
guided
tour
real
complex
geometry
springer
heidelberg
2011
schwartz
discrete
monodromy
pentagrams
method
condensation
fixed
point
theory
appl
2008
379–409
schwartz
pentagram
map
experiment
math
1992
71–81
soloviev
integrability
pentagram
map
arxiv:1106.3950.
department
mathematics
university
michigan
ann
arbor
48109
usa
e-mail
address
maxglick
umich.edu
