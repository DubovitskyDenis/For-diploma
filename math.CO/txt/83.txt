pattern
avoidance
ternary
trees
nathan
gabriel1
department
mathematics
rice
university
houston
77251
usa
katherine
peske1
department
mathematics
computer
science
concordia
college
moorhead
56562
usa
lara
pudwell1
department
mathematics
computer
science
valparaiso
university
valparaiso
46383
usa
lara.pudwell
valpo.edu
samuel
tay1
department
mathematics
kenyon
college
gambier
43022
usa
abstract
paper
considers
enumeration
ternary
trees
i.e.
rooted
ordered
trees
vertex
children
avoiding
contiguous
ternary
tree
pattern
begin
ﬁnding
recurrence
relations
several
simple
tree
patterns
complex
trees
compute
generating
functions
extending
known
algorithm
pattern-avoiding
binary
trees
next
present
alternate
one-dimensional
notation
trees
use
ﬁnd
bijections
explain
certain
pairs
tree
patterns
yield
avoidance
generating
function
finally
compare
bijections
known
replacement
rules
binary
trees
generalize
bijections
larger
class
trees
1partially
supported
nsf
grant
dms-0851721
introduction
notion
one
object
avoiding
another
studied
permutations
words
parti-
tions
graphs
although
pattern
avoidance
proven
useful
language
describe
connections
various
combinatorial
objects
also
attracted
broad
interest
pure
enumerative
topic
one
combinatorial
problem
received
much
attention
recent
years
count
number
permutations
length
avoiding
certain
smaller
permutation
permutation
avoiding
permutation
means
subsequence
order-isomorphic
although
classical
case
permutation
pattern
problem
allows
given
subsequence
special
case
attacked
successfully
via
variety
techniques
studying
contains
consecutive
subpermutation
latter
question
answered
variety
techniques
including
inclusion-exclusion
also
exist
algorithmic
techniques
goulden-jackson
cluster
method
approach
question
using
generating
functions
two
natural
questions
arise
given
permutation
many
permutations
length
avoid
two
forbidden
permutations
avoidance
generating
function
paper
consider
analogous
questions
plane
trees
trees
paper
rooted
ordered
focus
ternary
trees
trees
vertex
ordered
children
vertex
children
leaf
vertex
children
internal
vertex
ternary
tree
internal
vertices
leaves
number
2k+1
oeis
a001764
clear
exist
ternary
trees
trees
odd
number
leaves
ﬁrst
ternary
trees
depicted
figure
conceptually
plane
tree
avoids
tree
pattern
instance
anywhere
inside
pattern
avoidance
vertex-labeled
trees
studied
various
contexts
steyaert
flajolet
flajolet
sipala
steyaert
flajolet
sedgewick
dotsenko
recently
khoroshkin
piontkovski
considered
generating
functions
general
unlabeled
trees
diﬀerent
context
2010
rowland
explored
contiguous
pattern
avoidance
binary
trees
rooted
ordered
trees
vertex
children
two
motivations
choosing
particular
trees
ﬁrst
clear
natural
deﬁnition
means
rooted
ordered
tree
contain
contiguous
ordered
pattern
unclear
general
trees
second
natural
bijection
n-leaf
binary
trees
n-vertex
trees
study
two
main
objectives
first
developed
algorithm
ﬁnd
generating
function
number
n-leaf
binary
trees
avoiding
given
tree
pattern
adapted
count
number
occurrences
given
pattern
second
determined
equivalence
classes
binary
tree
patterns
classifying
two
trees
equivalent
number
n-leaf
binary
trees
avoid
avoid
completed
classiﬁcation
binary
trees
eight
leaves
using
classes
develop
replacement
bijections
equivalent
binary
trees
paper
extend
rowland
work
exploring
pattern
avoidance
ternary
trees
cases
general
m-ary
trees
trees
vertex
children
ﬁrst
compute
recurrence
relations
count
trees
avoid
ternary
tree
patterns
seven
leaves
next
adapt
rowland
algorithm
ﬁnd
functional
equations
avoidance
generating
functions
arbitrary
ternary
tree
patterns
finally
give
bijections
trees
avoiding
several
pairs
equivalent
tree
patterns
begin
generalizing
process
general
case
m-ary
trees
appendix
contains
equivalence
classes
ternary
tree
patterns
nine
leaves
found
using
maple
package
ternarytrees
maple
package
given
third
author
website
http
//faculty.valpo.edu/lpudwell/maple.html
1.1
deﬁnitions
notation
following
rowland
deﬁnition
avoidance
ternary
tree
contains
tree
pattern
contiguous
rooted
ordered
subtree
conversely
avoids
subtree
example
consider
three
trees
shown
figure
contains
pattern
occurs
beginning
center
child
root
see
bolded
subtree
however
avoids
vertex
children
extending
left
center
children
figure
three
ternary
trees
deﬁne
avt
set
n-leaf
ternary
trees
avoid
pattern
avt
|avt
particularly
interested
determining
generating
function
n=0
avt
various
patterns
explore
particular
ternary
tree
patterns
list
7-leaf
ternary
trees
note
however
left–right
reﬂection
avt
avtr
symmetry
left–right
reﬂections
omitted
label
trees
double
subscript
notation
ﬁrst
subscript
gives
number
leaves
tree
second
subscript
distinguishes
distinct
tree
patterns
depth
use
labels
throughout
remainder
paper
recurrences
simple
tree
patterns
section
ﬁnd
recurrence
relations
number
trees
avoiding
several
trees
figure
tree
discuss
structure
trees
avoid
given
tree
pattern
recurrence
generating
function
found
structure
list
equivalent
tree
patterns
clear
context
simply
write
lieu
avt
avt
t31
t51
t52
t71
t72
t73
t74
t75
t76
t77
figure
7-leaf
ternary
trees
2.1
avoiding
t51
t52
ﬁnd
avt51
let
look
n-leaf
tree
must
structured
order
avoid
t51
consider
internal
vertex
left
child
descendants
thus
must
leaf
center
child
root
subtree
number
leaves
finally
right
child
also
root
subtree
total
leaves
subtree
must
precisely
leaves
thus
possible
subtrees
beginning
center
child
possible
subtrees
right
child
also
avoid
t51
taking
summation
possible
values
gives
recurrence
relation
n−2
k=1
initial
conditions
recurrence
ternary
trees
leaves
one
tree
one
leaf
avoids
tree
pattern
one
leaf
trees
leaves
compute
gt1
p∞k=0
using
standard
techniques
obtain
4x2
gt1
ﬁrst
terms
sequence
two
things
worth
noting
avoidance
sequence
first
non-zero
terms
catalan
numbers
oeis
a000108
second
sequence
interspersed
zeros
ternary
trees
even
number
leaves
second
observation
true
avoidance
sequence
ternary
tree
pattern
trees
avoiding
t52
need
make
one
alteration
namely
center
child
instead
leftmost
child
vertex
children
therefore
ﬁnd
4x2
gt51
gt52
2.2
avoiding
t71
t72
next
ﬁnd
number
n-leaf
trees
avoid
t71
consider
internal
vertex
tree
avoids
t71
two
nonexclusive
possibilities
children
internal
vertices
first
leftmost
child
children
center
right
children
otherwise
center
child
children
left
right
children
two
cases
equivalent
avoiding
t51
t52
respectively
however
double-counts
one
instance
left
center
child
children
exactly
trees
counted
ﬁrst
two
cases
subtracting
recurrence
relation
left
n−2
k=1
initial
conditions
recurrence
relation
using
standard
techniques
obtain
gt71
√x4
6x2
gives
little
schr¨oder
numbers
oeis
a001003
interspersed
zeros
197
also
avoidance
sequence
t72
two
cases
exist
avoiding
t72
either
left
center
right
center
children
descendants
well
term
needs
subtracted
avoid
double-counting
neither
left
right
children
children
thus
gt71
gt72
√x4
6x2
considering
tree
patterns
examine
connection
trees
avoiding
t72
little
schr¨oder
numbers
look
one
well-known
combinatorial
interpretation
little
schr¨oder
numbers
number
binary
trees
vertices
right
edge
colored
either
solid
dashed
note
elsewhere
paper
concerned
strictly
binary
trees
internal
vertex
precisely
children
strictly
ternary
trees
internal
vertex
precisely
children
current
interpretation
little
schr¨oder
numbers
however
binary
trees
strict
internal
vertex
may
children
consider
following
map
set
colored
non-strict
binary
trees
set
strict
ternary
trees
avoiding
t72
vertex
binary
tree
draw
vertex
consider
parent-child
pair
binary
tree
left
child
center
child
right
child
via
solid
edge
left
child
right
child
via
dashed
edge
right
child
vertex
created
step
children
add
children
exactly
children
example
colored
binary
tree
figure
mapped
ternary
tree
figure
figure
colored
binary
tree
corresponding
t72-avoiding
ternary
tree
note
ternary
tree
produced
algorithm
certainly
avoids
t72
since
vertex
solid
right
edge
dashed
right
edge
time
accordingly
vertex
resulting
ternary
tree
never
right
child
left
child
children
process
obvious
inverse
example
look
11.
eleven
3-vertex
colored
binary
trees
eleven
5-leaf
trees
avoiding
t72
colored
binary
tree
shown
image
map
figure
figure
mapping
colored
binary
trees
t72-avoiding
ternary
trees
2.3
avoiding
t73
t77
ﬁnd
number
n-leaf
trees
avoid
t73
consider
two
cases
internal
vertex
tree
avoids
t73
first
left
child
children
center
right
children
roots
subtrees
leaves
leaves
respectively
second
case
left
child
three
children
avoid
t73
left-
vertex
child
another
consecutive
left-vertex
child
four
vertices
center
right
children
center
right
children
left
child
roots
subtrees
leaves
respectively
therefore
avt73
given
sum
two
cases
n−2
k=1
n−4
n−ℓ−3
ℓ=1
m=1
n−ℓ−m−2
k=1
ﬁnd
recurrence
relation
trees
avoiding
t77
see
instead
avoiding
two
consecutive
left-children
vertices
avoid
two
consecutive
middle-children
vertices
therefore
avt73
avt77
recurrence
compute
avoidance
sequence
207
oeis
a006605
interspersed
zeros
clearly
would
extremely
diﬃcult
solve
recurrence
directly
generating
function
gt73
turns
tree
patterns
t74
t75
t76
avoidance
generating
function
t71
t72
able
ﬁnd
recurrence
relations
hand
argument
parallel
complex
problems
arise
overcounting
undercounting
instead
adapt
rowland
generating
function
algorithm
trees
avoiding
binary
tree
patterns
deal
ternary
tree
patterns
generating
function
algorithm
saw
previous
section
straightforward
compute
given
ternary
tree
pattern
avoidance
generating
function
hand
small
tree
patterns
however
type
computation
quickly
becomes
impractical
increasingly
complex
tree
patterns
reason
develop
algorithm
ﬁnd
functional
equation
satisﬁed
avoidance
generating
function
ternary
tree
pattern
first
however
make
one
notational
adjustment
let
generating
function
number
n-leaf
ternary
trees
avoid
contain
tree
pattern
root
recall
already
speciﬁed
tree
contains
pattern
contains
contiguous
rooted
ordered
subgraph
contains
pattern
root
contains
copy
root
coincides
root
therefore
new
notation
generating
function
ternary
trees
begin
trees
avoiding
given
single
vertex
root
algorithm
use
ﬁnd
similar
rowland
algorithm
binary
trees
accounts
additional
child
internal
vertex
algorithm
produces
sequence
generating
functions
using
recursive
method
initially
generating
function
interested
written
terms
another
generating
function
new
generating
function
introduced
recursive
step
deduce
another
recurrence
terms
generating
functions
tree
pattern
use
denote
left
center
right
subtrees
respectively
appropriate
may
write
tℓtctr
also
require
one
operation
tree
patterns
use
denote
intersection
tree
patterns
conceptually
tree
pattern
produced
drawing
roots
coincide
formally
single
vertex
recursively
sℓscsr
tℓtctr
note
although
considering
trees
makes
intersection
notation
seem
misnomer
set
trees
tree
pattern
root
intersected
set
trees
tree
pattern
root
indeed
set
trees
tree
pattern
root
new
notation
prepared
give
algorithm
ﬁnd
equal
single
vertex
tree
first
notice
unless
single
vertex
tree
generating
function
trees
single
vertex
root
always
account
one
tree
one
leaf
rest
trees
avoiding
pattern
root
next
introduced
new
generating
function
need
derive
new
recurrence
function
recognize
t-avoiding
tree
pattern
root
made
three
t-avoiding
subtrees
respective
roots
however
account
trees
avoiding
individually
overcounts
trees
root
pattern
respectively
therefore
pℓ∩tℓ
pc∩tc
pr∩tr
observation
holds
tree
pattern
non-trivial
tree
pattern
repeatedly
use
observation
derive
new
recurrence
generating
function
arises
computation
complete
system
equations
guaranteed
system
eventually
complete
since
depth
pattern
introduced
process
depth
ﬁnitely
many
tree
patterns
depth
complete
system
equations
eliminate
unwanted
variables
functional
equation
algorithm
compute
non-trivial
ternary
tree
pattern
initialize
let
pℓ∩tℓ
pc∩tc
pr∩tr
let
var
var
let
var
let
step
eliminate
variables
var\
compute
functional
equation
system
equations
illustrate
algorithm
using
compute
avoidance
generating
function
t73
step
initialize
t73
t73
var
obtain
t73
step
consider
t73
var
var
t73
t73
since
relabel
consider
obtain
t73
t73
t73
t73
t73
var
var
since
consider
three
equations
let
t73
t73
t73
ca2
ba2
ca2
eliminating
gives
equation
xa4
xa2
simple
trees
usually
solve
resulting
functional
equation
directly
however
quartic
functional
equation
characteristic
result
complex
tree
patterns
although
functional
equation
simple
explicit
solution
use
compute
arbitrarily
many
coeﬃcients
generating
function
gt73
making
substitution
n=0
isolating
coeﬃcients
power
setting
equal
zero
functional
equation
xa4
xa2
ﬁnd
sequence
207
979
4797
24138
123998
647615
3428493
18356714
oeis
a006605
interspersed
zeros
complete
classiﬁcation
ternary
trees
leaves
given
appendix
along
functional
equations
terms
corresponding
avoidance
se-
quences
note
given
tree
pattern
algorithm
given
section
generates
system
equations
maximum
total
degree
auxiliary
variables
system
eliminated
produce
polynomial
functional
equation
guarantees
always
algebraic
khoroshkin
piontkovski
independently
showed
generating
functions
algebraic
case
general
pattern-avoiding
trees
however
work
done
diﬀerent
context
bijections
ternary
trees
discussed
two
methods
enumerating
pattern-avoiding
trees
look
connections
speciﬁc
sets
trees
recall
several
ternary
trees
paper
pattern
avoidance
sequence
one
trees
distinct
found
gtki
patterns
said
wilf
equivalent
explain
certain
pairs
tree
patterns
tki
tkj
wilf
equivalent
rowland
accomplish
ﬁnding
bijections
members
avtki
order
present
bijections
clear
concise
way
ﬁrst
present
alternate
notation
ternary
trees
use
notation
describe
bijections
explain
wilf
equivalences
7-leaf
ternary
tree
patterns
generalize
maps
avtkj
gtkj
4.1
word
notation
trees
subsection
represent
trees
sets
integer
words
notation
easily
extends
m-ary
trees
i.e.
trees
vertex
children
foundation
word
representation
m-leaf
parents
deﬁnition
m-leaf
parent
internal
vertex
m-ary
tree
exactly
children
leaves
example
t74
one
3-leaf
parent
t71
two
3-leaf
parents
word
notation
represents
m-ary
tree
set
words
word
follows
path
root
m-leaf
parent
construct
set
following
tree-set
algorithm
label
children
internal
vertex
m-ary
tree
left
right
ternary
trees
vertex
left
child
labeled
center
child
right
child
denote
path
root
tree
m-leaf
parent
integer
word
length
path
root
m-leaf
parent
ﬁrst
number
word
represents
child
root
labeled
refers
child
vertex
given
xi−1
labeled
value
example
let
look
look
t74
t71
t74
3-leaf
parent
reached
path
beginning
root
going
root
left
child
vertex
center
child
word
notation
t74
denoted
set
t71
reach
one
3-leaf
parents
going
root
left
child
root
center
child
becomes
set
note
ordered
m-ary
tree
uniquely
deﬁned
set
paths
root
m-leaf
parent
single
vertex
tree
represented
empty
set
3-leaf
tree
t31
set
containing
empty
word
set
321
denotes
tree
given
figure
set
223
denotes
ternary
tree
given
figure
also
note
tree-set
algorithm
clearly
reversible
particular
create
m-ary
tree
word
following
procedure
create
root
give
root
children
labeled
left
right
word
x1x2
give
x1-st
child
root
children
label
children
repeating
process
level
denotes
giving
children
xi-th
child
vertex
given
children
xi−1
take
intersection
trees
obtained
step
ﬁnd
ﬁnal
m-ary
tree
note
representing
trees
words
sets
words
new
idea
example
stanley
shows
represent
plane
trees
certain
integer
sequences
parenthesizations
words
subject
certain
constraints
alternate
representation
m-ary
trees
consider
speciﬁc
prop-
erties
word
notation
relevant
questions
pattern
avoidance
first
note
set
words
one
word
preﬁx
another
redundant
rep-
resentation
trees
since
word
speciﬁes
path
within
tree
word
preﬁx
word
path
speciﬁed
necessarily
part
path
speciﬁed
including
superﬂuous
deﬁnition
let
set
words
alphabet
word
preﬁx
another
word
namely
arbitrary
set
words
describing
m-ary
tree
write
set
sets
consider
set
words
i=1
corresponding
tree
pattern
note
tree
given
i=1
mhi
begins
possibly
empty
preﬁx
mhi
followed
exactly
ordered
sequence
elements
may
may
followed
additional
sequence
numbers
h=1
contains
exist
mhi
example
tree
pattern
1323
1223
contained
3231323
11322
3231223112
notice
preﬁx
323
ﬁrst
third
words
exactly
sequence
word
however
31323
1223
avoids
even
though
contains
sequence
numbers
words
words
begin
preﬁx
sequences
begin
following
subsections
btki
denote
bijection
trees
avoiding
tki
trees
avoiding
tkj
ﬁnd
maps
analyzing
word
notation
pattern-avoiding
trees
ready
present
bijections
wilf
equivalent
tree
patterns
tkj
4.2
patterns
t51
t52
tree
avoids
t51
none
left
vertices
children
avoids
t52
none
center
vertices
children
order
map
tree
avoiding
t51
tree
avoiding
t52
deﬁne
bijection
bt51
t52
switch
center
subtree
every
vertex
left
subtree
vertex
terms
word
notation
tree
avoids
t51
words
avoids
t52
words
thus
deﬁne
bt51
t52
replace
every
words
every
example
bt51
t52
233
133
clear
map
one-to-one
onto
preserves
number
leaves
4.3
patterns
t73
t77
tree
avoids
t73
two
consecutive
left
vertices
children
avoids
t77
two
consecutive
center
vertices
children
word
notation
tree
avoids
t73
pairs
consecutive
avoids
t77
pairs
consecutive
thus
deﬁne
bt73
t77
bt51
t52
tree
avoiding
t73
bt73
t77
replaces
set
words
originally
deﬁned
bt51
t52
deﬁning
bt73
t77
way
reasonable
example
bt73
t77
322
311
stated
map
bijection
4.4
patterns
t71
t72
tree
avoid
t71
vertex
children
descending
left
center
children
avoid
t72
vertex
children
descending
left
right
children
therefore
deﬁne
bijection
bt71
t72
switch
right
center
subtrees
vertex
using
word
notation
equivalent
deﬁning
bt71
t72
replace
every
every
example
bt71
t72
121
1232
322
331
131
1323
221
233
clear
bt71
t72
one-to-one
onto
preserves
number
leaves
4.5
patterns
t74
t75
using
word
notation
tree
avoids
t74
none
words
followed
avoids
t75
none
words
followed
therefore
deﬁne
bt74
t75
bt71
t72
bt74
t75
replaces
example
bt74
t75
1313
3213
323
1212
2312
232
previous
examples
clear
bt74
t75
bijection
preserves
number
leaves
4.6
patterns
t75
t76
using
word
notation
tree
avoids
t75
none
words
followed
avoids
t76
none
words
followed
therefore
deﬁne
bt75
t76
replace
every
every
every
bt75
t76
clearly
maps
words
contain
sequence
words
contain
sequence
21.
example
bt75
t76
3212
1323
previous
examples
clear
bt75
t76
bijection
preserves
number
leaves
4.7
patterns
t71
t74
bijection
bit
complicated
previous
maps
consider
function
bt71
t74
deﬁned
following
procedure
applied
word
contains
followed
nothing
otherwise
locate
ﬁrst
copy
x|l|
particular
suppose
xi−1
copy
xi−1
xi+1
xj+1
map
pair
words
xi−1xj+1
x|l|
contains
occurrence
iterate
step
new
word
created
produced
none
contain
followed
example
1232311121
ﬁrst
iteration
maps
232311121
second
iteration
gives
2323111
232321
words
12-free
bt71
t74
2323111
232321
t71
t74
order
prove
bt71
t74
bijection
ﬁrst
construct
inverse
function
b−1
start
root
tree
work
downward
consider
oc-
currences
t71
word
pairs
form
p01s1
p02s2
denotes
common
preﬁx
two
words
suﬃxes
note
occurrence
t71
possible
multiple
words
form
p02si
inverse
map
given
following
process
level
beginning
root
replace
occurrence
p02si
part
occurrence
t71
p012si
multiple
occurrences
t71
level
applying
step
one
occurrence
t71
aﬀect
words
denoting
occurrence
t71
level
therefore
order
apply
step
occurrence
t71
ith
level
irrelevant
iterate
step
successive
level
beginning
root
discard
words
preﬁx
another
set
words
example
2323111
232321
ﬁrst
level
occurrence
given
2323111
232321.
step
replace
2323111
232321
12323111
1232321
set
12323111
1232321
step
requires
check
next
levels
order
lowest
highest
see
occur
sixth
level
given
words
12323111
1232321.
thus
replace
1232321
12323121
obtain
12323111
12323121
third
iteration
step
replace
12323121
123231121.
fourth
iteration
replaces
123231121
1232311121
left
set
12323111
1232311121
applying
step
see
b−1
1232311121
note
b−1
expected
earlier
example
t71
t74
t71
t74
easy
see
bt71
t74
fact
map
trees
avoiding
t71
trees
avoiding
t74
bt71
t74
bt71
t74
clear
inverse
thus
bt71
t74
also
clear
b−1
bijection
t71
t74
claim
bt71
t74
preserves
numbers
leaves
step
bijection
step
changes
structure
consider
arbitrary
occurrence
t74
path
root
root
occurrence
given
preﬁx
occurrence
t74
step
bijection
map
words
preﬁx
p012
word
p01
words
preﬁx
p02
result
longer
words
preﬁx
p012
see
vertex
given
path
p01
one
leaf
bt71
t74
namely
second
child
leaf
leaf
however
also
see
vertex
given
path
one
less
child
leaf
result
words
p02
preﬁx
could
already
word
p02
preﬁx
since
would
entail
occurrence
t71
vertex
given
path
word
p01
add
subtract
number
leaves
since
preﬁx
word
replaces
thus
creates
new
vertices
iteration
step
occurrence
t74
reasoning
holds
see
number
leaves
bt71
t74
number
leaves
accounted
wilf
equivalences
tree
patterns
leaves
4.8
general
approaches
bijections
section
generalize
previous
six
bijections
bijections
larger
class
tree
patterns
particular
present
bijection
certain
tree
patterns
avoidance
generating
function
one
m-leaf
parent
tree
patterns
represented
single
word
word
notation
consider
two
m-ary
tree
patterns
word
notation
exists
bijection
maps
bijection
bl1
set
trees
avoiding
set
trees
avoiding
particular
bl1
map
replaces
letter
lists
l1-avoiding
tree
example
11213
22321
map
sends
consider
tree
avoids
given
list
notation
bl1
replaces
integer
example
bl1
13231
22321
21312
33132
general
tree
denoted
set
words
avoids
apply
bijection
letters
bl1
set
words
word
contains
instance
bl1
avoids
theorem
map
bl1
one-to-one
onto
preserves
number
leaves
proof
fact
bl1
one-to-one
onto
follows
fact
bl1
induced
map
permutation
show
bl1
preserves
number
leaves
enough
show
internal
vertex
given
tree
unique
internal
vertex
bl1
number
children
leaves
consider
word
describing
path
let
number
distinct
letters
follow
preﬁx
word
children
leaves
consider
bl1
since
distinct
letters
followed
must
distinct
letters
follow
preﬁx
bl1
meaning
vertex
whose
path
root
given
children
leaves
holds
true
every
vertex
proving
number
leaves
remains
generalized
bijections
trees
one
interesting
property
consider
word
notation
m-ary
tree
also
read
word
notation
m-ary
tree
says
bijection
bl1
pair
m-ary
trees
necessarily
discovered
wilf
equivalence
corresponding
pairs
m-ary
trees
4.9
final
notes
bijections
section
given
bijections
explaining
non-trivial
wilf
equivalences
ternary
tree
patterns
leaves
note
one
bijections
given
section
guaranteed
exist
results
section
4.8.
bijection
t71-
t74-avoiding
trees
lone
exception
method
since
involved
cutting
integer
words
representing
trees
rather
relabeling
appendix
also
give
computational
data
equivalent
ternary
tree
patterns
leaves
turns
9-leaf
ternary
tree
patterns
fall
three
distinct
wilf
classes
many
equivalences
also
explained
generalized
bijections
section
4.8.
moreover
bijections
except
one
t71
t74
may
clearly
seen
replacement
fact
see
bijections
sense
rowland
binary
tree
patterns
paper
last
bijection
replacement
bijection
considering
well-chosen
example
consider
tree
whose
word
representation
1232311121
shown
figure
tree
contains
two
copies
tree
pattern
t74
one
copies
root
near
bottom
tree
one
copy
t31
appended
deepest
left
leaf
hand
image
tree
represented
2323111
232321
also
shown
figure
tree
contains
two
copies
tree
t71
one
root
one
deeper
tree
however
lower
copy
copy
t51
copy
t31
appended
deepest
leaves
true
replacement
bijection
copies
t74
transformed
copies
t71
subtrees
descending
leaves
copy
t74
moved
entirety
subtrees
descending
leaves
copy
t71
clearly
case
bijection
remains
open
question
determine
whether
exists
replacement
bijection
ternary
trees
avoiding
t71
ternary
trees
avoiding
t74
figure
ternary
trees
word
representations
1232311121
2323111
232321
many
bijections
overlap
rowland
idea
replacement
bijections
however
propose
considering
trees
sets
integer
words
provides
insight
process
developing
wilf
equivalent
tree
patterns
conclusion
throughout
paper
investigated
pattern
avoidance
ternary
trees
extending
previous
work
binary
trees
began
ﬁnding
recurrence
relations
generating
functions
hand
several
simple
ternary
tree
patterns
make
computation
avoidance
sequences
easier
however
developed
algorithm
based
rowland
al-
gorithm
binary
trees
ﬁnd
generating
function
trees
avoiding
given
tree
pattern
next
classiﬁed
tree
patterns
grouping
together
avoid-
ance
sequence
able
ﬁnd
bijections
sets
trees
avoiding
speciﬁc
pairs
two
equivalent
tree
patterns
tki
tkj
pairs
trees
trans-
formed
tree
avoiding
tki
one
avoids
tkj
stating
several
bijections
speciﬁc
pairs
tree
patterns
generalized
bijections
trees
avoiding
patterns
equivalence
class
trees
permutations
acknowledgement
authors
thank
eric
rowland
number
presentation
suggestions
support
generating
many
tree
graphics
required
paper
appendix
appendix
lists
ternary
trees
nine
leaves
classifying
avoidance
generating
function
sequence
class
give
functional
equation
satisﬁed
list
ﬁrst
terms
including
zeros
corresponding
avoidance
sequence
simple
explicit
form
included
avoidance
sequence
class
listed
online
encyclopedia
integer
sequences
without
interspersed
zeros
include
appropriate
reference
brevity
left–right
reﬂections
omitted
class
xa2
1−√1−4x2
132
429
1430
4862
oeis
a000108
catalan
numbers
class
7.1
x2+1
x2+1
2−8x2
2xa2
x2a
197
903
4279
20793
103049
oeis
a001003
little
schr¨oder
numbers
class
7.2
xa4
xa2
207
979
4797
24138
123998
oeis
a006605
number
modes
connections
points
class
9.1
3xa2
3x2a
3x2+1
−√1−6x2−3x4
261
1323
6939
37341
205011
oeis
a107264
expansion
3x−1
−√1−6x−3x2
6x2
class
9.2
xa4
x2a3
2xa2
x2a
261
1324
6954
37493
206316
oeis
a200740
generating
function
satisﬁes
x2a4
x2a3
2xa2
class
9.3
xa6
xa4
xa2
262
1337
7072
38426
213197
oeis
a186241
generating
function
given
x3a6
+x2a4
+xa2
references
dotsenko
pattern
avoidance
labelled
trees
preprint
http
//arxiv.org/abs/1110.0844
flajolet
sedgewick
analytic
combinatorics
cambridge
university
press
2009
flajolet
sipala
steyaert
analytic
variations
common
subexpres-
sion
problem
automata
languages
programming
proc
icalp
1990
lecture
notes
computer
science
vol
443
springer
1990
220–234
goulden
jackson
inversion
theorem
cluster
decompositions
sequences
distinguished
subsequences
london
math
soc
1979
567–576
khoroshkin
piontkovski
generating
series
ﬁnitely
presented
operads
preparation
noonan
zeilberger
goulden-jackson
cluster
method
extensions
applica-
tions
implementations
diﬀerence
equations
applications
1999
355–377
rowland
pattern
avoidance
binary
trees
combin
theory
ser
117
2010
741–758
stanley
enumerative
combinatorics
cambridge
university
press
1999
sloane
encyclopedia
integer
sequences
available
http
//oeis.org
2011
steyaert
flajolet
patterns
pattern-matching
trees
analysis
info
control
1983
19–58
