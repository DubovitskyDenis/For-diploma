capacity
online
causal
q-ary
error-erasure
channels
chen
jaggi
langberg
abstract
q-ary
online
causal
channel
coding
model
sender
wishes
communicate
message
receiver
transmitting
codeword
symbol
symbol
via
channel
limited
errors
and/or
cid:63
erasures
channel
online
sense
ith
step
communication
channel
decides
whether
corrupt
ith
symbol
based
view
far
i.e.
decision
depends
transmitted
symbols
contrast
classical
adversarial
channel
corruption
chosen
channel
full
knowledge
sent
codeword
work
study
capacity
q-ary
online
channels
combined
corruption
model
channel
may
impose
errors
cid:63
erasures
transmitted
codeword
online
channel
error
erasure
case
seen
number
recent
studies
present
upper
lower
bounds
capacity
work
give
full
characterization
capacity
function
cid:63
âˆ—department
electrical
computer
engineering
university
maryland
college
park
chenztan
umd.edu
â€ department
information
engineering
chinese
university
hong
kong
jaggi
ie.cuhk.edu.hk
â€¡department
electrical
engineering
state
university
new
york
buï¬€alo
mikel
buffalo.edu
introduction
reliable
communication
diï¬€erent
types
channels
extensively
studied
electrical
engi-
neering
computer
science
one
frequently
used
communication
channel
model
binary
erasure
channel
bit
zero
one
either
transmitted
intact
erased
speciï¬cally
erased
bit
visible
error
denoted
special
symbol
identiï¬ed
directly
receiver
another
fre-
quently
studied
channel
model
binary
bit-ï¬‚ip
channel
bits
ï¬‚ipped
complement
generalization
channel
alphabet
size
leads
general
q-ary
channels
two
broad
approaches
model
erasure
error
corruptions
imposed
channel
shannon
approach
model
channel
stochastic
process
hamming
approach
combinatorial
approach
model
channel
adversarial
process
manipulate
parts
transmitted
codeword
arbitrarily
subject
limit
number
corrupted
symbols
interesting
classify
hamming
model
adversarial
channel
terms
adversary
knowledge
codeword
examples
include
standard
adversarial
channel
also
referred
omniscient
adversary
e.g.
1â€“3
causal
online
adversary
e.g.
4â€“9
oblivious
adversary
e.g.
10â€“12
strongest
adversarial
power
weakest
one
extreme
omniscient
adversarial
model
a.k.a
classical
adversarial
model
assumes
channel
full
knowledge
entire
codeword
based
knowledge
channel
maliciously
decide
corrupt
codeword
extreme
oblivious
adversarial
model
model
channel
clueless
codeword
generates
corruptions
manner
independent
codeword
transmitted
causal
adversarial
model
intermediate
model
two
extremes
channel
decides
whether
tamper
particular
symbol
codeword
based
symbols
transmitted
far
signiï¬cant
diï¬€erences
diï¬€erent
adversarial
models
classiï¬ed
respect
capacity
elaborate
diï¬€erences
shortly
work
focus
causal
adversaries
study
reliable
communication
q-ary
causal
adversarial
channels
speciï¬cally
consider
following
communication
scenario
sender
alice
wishes
transmit
message
receiver
bob
q-ary
causal
adversarial
channel
encoding
codeword
Â·Â·Â·
Â·Â·Â·
length
however
channel
governed
causal
adversary
calvin
observe
impose
errors
cid:63
erasures
importantly
calvin
decides
whether
tamper
i-th
symbol
codeword
based
symbols
Â·Â·Â·
transmitted
thus
far
roughly
qnr
distinct
messages
sent
using
codewords
length
say
code
achieves
rate
interested
maximum
achievable
rate
capacity
channel
see
section
precise
deï¬nitions
1.1
results
work
characterize
capacity
q-ary
causal
channels
function
alphabet
size
error
capability
erasure
capability
cid:63
speciï¬cally
propose
analyze
attack
strategy
similar
binary
cases
described
detail
shortly
gives
upper
bound
capacity
coding
scheme
similar
one
given
implies
lower
bound
capacity
matching
upper
bound
main
result
summarized
following
theorem
theorem
1.1.
capacity
q-ary
causal
adversarial
channels
symbol
errors
erasures
cid:104
ï£±ï£²ï£³
min
Â¯pâˆˆ
cid:16
cid:16
cid:17
cid:17
cid:105
cid:104
qâˆ’1
cid:105
cid:63
cid:104
cid:105
qâˆ’1
otherwise
cid:63
qâˆ’1
qâˆ’1
qâˆ’1
cid:63
fact
direct
by-products
analysis
coding
scheme
show
even
calvin
small
lookahead
capacity
essentially
unchanged
precisely
constant
calvin
decides
whether
tamper
i-th
symbol
codeword
based
symbols
Â·Â·Â·
min
i+n
capacity
corresponding
n-lookahead
less
corresponding
show
theorems
1.1
continuous
provide
rough
argument
support
claim
remark
end
section
1.2
previous
work
start
brieï¬‚y
summarizing
state-of-the-art
erasure
error
adversarial
channels
omniscient
oblivious
adversaries
optimal
rate
communication
binary
omniscient
adver-
sarial
channels
erasure
error
long
standing
open
problems
coding
theory
best
known
lower
bounds
problems
derive
gilbert-varshamov
codes
bound
1,2
tightest
upper
bounds
mrrw
bounds
work
mceliece
literature
arbitrarily
varying
channels
avcs
e.g.
implies
capacity
binary
oblivious
adversarial
error
channel
oblivious
adversarial
erasure
channels
match
well-known
capacities
corresponding
random
noise
channels
bits
ï¬‚ipped
erased
bernoulli
attainable
even
noise
patterns
chosen
overall
constraint
p-fraction
corruptions
adversary
full
knowledge
codebook
knowledge
actually
transmitted
codeword.1
alternate
proof
capacity
binary
oblivious
bit-ï¬‚ip
channel
presented
langberg
computationally
eï¬ƒcient
scheme
achieving
rate
presented
guruswami
smith
turn
causal
setting
causal
adversary
never
better
omniscient
adversary
least
well
oblivious
one
upper
bounds
capacity
oblivious
adversaries
speciï¬ed
act
upper
bounds
causal
case
well
lower
bounds
capacity
omniscient
adversaries
act
lower
bounds
causal
case
binary
causal
adversarial
bit-ï¬‚ip
channel
bounds
improved
speciï¬cally
ï¬rst
nontrivial
upper
bound
min
given
langberg
later
tightest
upper
bound
given
continuing
work
dey
best
lower
bound
described
haviv
langberg
slightly
improves
bound
binary
causal
adversarial
erasure
channel
trivial
upper
bound
improved
bassily
smith
also
present
improved
lower
bounds
separate
achievable
rate
causal
adversarial
erasures
rates
achievable
omniscient
adversarial
erasures
recently
capacities
binary
causal
adversarial
erasures
errors
fully
characterized
demonstrate
equals
theorem
1.1
case
case
cid:63
respectively
related
results
include
study
binary
delayed
adversaries
dey
provide
character-
ization
capacity
case
delays
arbitrarily
small
constant
fraction
code
block
length
n.2
value
corresponds
adversarial
model
decision
1in
fact
even
shown
alice
allowed
use
stochastic
encoding
choosing
one
multiple
possible
codewords
randomly
message
wants
transmit
even
maximal
probability
error
metric
vanishingly
small
probability
error
attained
capacity
achieving
codes
exists
sequence
codes
whose
rates
asymptotically
achieve
corresponding
capacity
every
message
transmitted
alice
every
corruption
pattern
imposed
calvin
decoded
correctly
bob
codewords
corresponding
message
2while
presented
work
techniques
used
show
capacity
holds
even
delay
polylog
rather
whether
corrupt
ith
codeword
bit
depends
xiâˆ’d
overall
constraint
number
bits
corrupted
interesting
note
case
well
oblivious
one
capacity
bit-ï¬‚ip
bit-erasure
channels
matches
corresponding
random
noise
capacities
hand
mentioned
causal
lookahead
settings
strictly
lower
approximately
matching
capacities
seems
imply
knowledge
present
critical
calvin
signiï¬cantly
depress
capacity
random
noise
capacity
discussion
relates
problem
binary
alphabets
work
dey
considered
large
alphabet
channels
alphabet
size
signiï¬cantly
larger
block-length
causal
symbol
errors.3
complete
capacity
characterization
presented
corresponding
computationally
eï¬ƒcient
codes
attaining
capacity
demonstrated
capacity
problem
equals
capacity
omniscient
adversary
attained
reed-solomon
codes
impossibility
higher
rates
singleton
bound
demonstrates
penalty
imposed
causality
condition
calvin
diminishes
increasing
alphabet
size
also
related
work
study
mazumdar
capacity
memoryless
channels
adversary
makes
decisions
based
value
currently
transmitted
bit
addressed
note
causal
model
also
variant
avc
model
however
previous
works
avcs
capacity
characterizations
relate
directly
study
hand
causal
adversaries
1.3
proof
technique
prove
theorem
1.1
demonstrate
two
results
converse
analyzing
attack
strategy
similar
presented
7,8,13
coding
scheme
follows
lines
presented
major
novelty
lies
extending
proof
techniques
hold
q-ary
causal
adversarial
channels
general
adversary
able
impose
errors
erasures
codewords
throughout
denote
encoder
alice
decoder
bob
adversarial
causal
jammer
calvin
1.3.1
converse
prove
theorem
1.1
must
present
strategy
calvin
allow
communication
rate
higher
matter
encoding/decoding
scheme
used
alice
bob
speciï¬cally
strategy
present
allow
calvin
enforce
constant
probability
error
bounded
away
zero
whenever
alice
bob
communicate
rate
higher
calvin
uses
two-phase
babble-and-push
strategy
ï¬rst
phase
calvin
babbles
behaving
like
q-ary
symmetric
channel
Â¯pn
symbols
changed
adversarial
attack
calvin
strongest
optimal
depends
setting
cid:63
fact
accounts
minimization
capacity
term
given
theorem
1.1.
value
also
determines
length
denoted
babble
phase
namely
calvin
stops
behaving
like
q-ary
symmetric
channel
starts
second
push
phase
taken
ï¬rst
phase
calvin
uses
error
capabilities
erase
symbols
second
phase
channel
uses
calvin
randomly
selects
codeword
alice
bob
codebook
consistent
bob
received
far
namely
codeword
bob
3the
capacity
large
alphabet
causal
symbol
erasures
essentially
omniscient
large
alphabet
symbol
erasures
turn
equals
capacity
random
symbol
erasures
rates
directly
attained
reed-solomon
codes
matching
converses
obtained
calvin
merely
randomly
erasing
symbols
changing
cid:48
perspective
may
transmitted
taking
account
calvin
attack
calvin
pushes
remaining
part
alice
codeword
towards
selected
codeword
push
phase
includes
errors
erasures
calvin
behalf
speciï¬cally
calvin
ï¬rst
imposes
error
probability
1/2
every
entry
transmitted
codeword
diï¬€ers
chosen
calvin
cid:48
operation
pushes
transmitted
codeword
towards
codeword
selected
calvin
calvin
exhausted
budget
errors
moves
erasures
erases
entry
diï¬€ers
cid:48
calvin
cid:63
budget
allows
erase
symbols
symmetrization
techniques
e.g.
show
constant
probability
bob
unable
determine
whether
alice
transmitted
codeword
one
chosen
calvin
causing
decoding
error
probability
1/2
case
prove
bound
remaining
budget
calvin
errors
erasures
must
suï¬ƒce
push
codeword
alice
half
distance
towards
chosen
calvin
using
q-ary
plotkin
bound
additional
ideas
one
show
constant
probability
distance
two
codewords
locations
push
phase
1/q
implying
calvin
needs
remaining
budget
last
channel
uses
number
erasures
plus
twice
number
errors
least
1/q
roughly
speaking
calculations
show
every
corresponding
threshold
calvin
budget
suï¬ƒces
push
phase
however
one
would
like
long
enough
setting
small
shorten
babble
phase
clavin
increase
block
length
push
phase
increase
budget
needed
calvin
overcome
potential
distance
1/q
alice
codeword
long
babble
phase
makes
calvin
attack
look
similar
output
random
channel
resulting
weaker
outer
bound
threshold
set
minimal
value
possible
still
leaves
calvin
suï¬ƒcient
push
budget
given
cid:63
parameter
set
roughly
value
speciï¬ed
theorem
1.1
implies
babble
phase
behaves
like
q-ary
symmetric
channel
error
parameter
Â¯p/Î±q
recall
babble
phase
calvin
changing
Â¯pn
randomly
chosen
locations
locations
phase
hence
upper
bound
obtained
case
rate
corresponding
q-ary
symmetric
channel
block
length
exactly
stated
term
theorem
1.1.
see
shortly
achievability
scheme
setting
rate
upper
bound
optimal
allows
overcome
calvin
pushing
capabilities
allows
successful
communication
implying
tight
characterization
capacity
online
model
1.3.2
achievability
codes
encoder
alice
uses
internal
randomness
known
bob
calvin
choice
transmitted
codeword
designed
allow
high
probability
successful
communication
matter
message
alice
sending
bob
use
chunked
random
codes
described
shortly
pick
codes
uniformly
random
random
ensemble
speciï¬ed
section
prove
w.h.p
code
distribution
code
chosen
random
allows
reliable
communication
decoder
involves
two
major
phases
list
decoding
phase
decoder
obtains
short
list
messages
include
one
transmitted
unique
decoding
phase
list
reduced
single
message
roughly
bob
decoding
process
divides
received
word
two
parts
symbols
received
given
time
cid:63
symbols
received
afterwards
list
decoding
done
using
ï¬rst
part
received
word
process
unique
decoding
list
done
using
second
part
consider
ï¬rst
special
case
erasures
case
given
parameter
cid:63
speciï¬es
fraction
symbols
erased
adversary
received
word
decoder
bob
pin-point
value
cid:63
allow
successful
decoding
speciï¬cally
adversarial
behavior
show
existence
value
cid:63
one
hand
allows
bob
obtain
small
list
messages
ï¬rst
part
received
word
guarantees
fraction
symbols
erased
adversary
second
part
received
word
suï¬ƒce
confuse
bob
two
messages
list
holds
notice
duality
parameter
upper
bound
parameter
cid:63
upper
bound
show
rate
matter
code
shared
alice
bob
exists
threshold
bob
uniquely
decoding
based
ï¬rst
received
symbols
calvin
suï¬ƒcient
remaining
budget
cause
decoding
error
remaining
symbols
lower
bound
rate
suggest
coding
scheme
show
exists
threshold
cid:63
bob
list
decode
based
ï¬rst
cid:63
received
symbols
calvin
suï¬ƒcient
budget
left
cause
decoding
error
remaining
cid:63
symbols
rate
list
decoding
lower
bound
resembles
q-ary
symmetric
channel
upper
bound
obtain
tight
results
ability
list
decode
obtained
using
standard
probabilistic
arguments
take
account
block
length
cid:63
number
erasures
cid:63
ï¬rst
part
received
word
ability
uniquely
decode
obtained
list
involves
delicate
analysis
uses
stochastic
nature
encoding
causality
constraint
calvin
particular
use
fact
secret
symbols
used
encoding
ï¬rst
part
codeword
position
cid:63
independent
used
second
part
independence
useful
separating
two
decoding
phases
sense
casual
adversary
time
cid:63
acting
knowledge
whatsoever
secret
symbols
used
alice
time
cid:63
lack
knowledge
sets
stage
unique
decoding
phase
accommodate
diï¬€erent
potential
values
cid:63
designing
stochastic
encoding
process
diï¬€erent
parts
codewords
rely
independent
secret
symbols
alice
namely
divide
coding
process
chunks
chunk
random
stochastic
code
length
small
parameter
uses
independent
randomness
alice
ï¬nal
code
alice
concatenation
chunks
setting
small
enough
allows
enough
ï¬‚exibility
manage
possible
value
cid:63
chosen
bob
decoder
encoding
decoding
process
channel
presence
errors
erasures
follow
line
analysis
speciï¬ed
erasure
case
one
major
signiï¬cant
diï¬€erence
bob
know
symbols
transmitted
codeword
error
thus
studying
received
word
bob
able
identify
location
cid:63
desired
properties
overcome
diï¬ƒculty
design
iterative
decoding
process
bob
starts
small
value
performs
attempt
decode
decoding
process
ï¬rst
list
decodes
using
ï¬rst
part
received
word
uniquely
decodes
list
decoding
done
according
certain
guessed
value
Ë†pt
fraction
symbol
errors
ï¬rst
part
received
word
Ë†pt
carefully
designed
function
also
referred
trajectory
ï¬xed
known
parties
involved
communication
trajectory
Ë†pt
chosen
way
guarantees
successful
decoding
location
Ë†pt
equals
fraction
symbols
actually
changed
calvin
location
respect
unerased
positions
speciï¬cally
Ë†pt
guarantees
bob
able
obtain
small
list
messages
list
decoding
position
uniquely
decode
list
remaining
corruption
power
calvin
limited
analyzing
conditions
gives
range
possible
trajectories
Ë†pt
depicted
figure
denotes
number
erasures
bob
receives
channel
uses
set
Ë†pt
otherwise
set
Ë†pt
cid:63
cid:17
cid:16
cid:63
qâˆ’1
cid:63
increases
grows
note
since
bounded
cid:63
therefore
ranges
quantity
always
takes
possible
integer
values
least
cid:63
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:63
cid:17
value
Ë†pt
cid:16
qâˆ’1
qâˆ’1
cid:63
cid:17
qâˆ’1
qâˆ’1
cid:16
cid:16
cid:17
cid:16
tâˆ’Î»t
figure
range
trajectory
Ë†pt
shaded
function
1/8
bounds
analytical
however
plot
made
numerically
using
000.
curves
extremal
curves
calvin
true
corruption
fraction
curves
bound
region
Ë†pt
horizontal
lines
Â¯popt
optimal
upper
bound
given
references
calvin
follow
attack
given
upper
bound
proof
nÂ¯popt
red
horizontal
line
decoding
scheme
Ë†pt
point
topt
topt
red
vertical
line
values
location
Ë†pt
diï¬€er
Ë†pt
show
iterative
decoding
bob
successful
threshold
location
indeed
Ë†pt
otherwise
show
unique
decoding
phase
fail
sense
bob
receive
message
decoding
process
identifying
failure
decoding
process
bob
increases
repeats
decoding
attempt
crux
analysis
lies
proof
eventually
matter
behavior
calvin
value
denoted
cid:63
Ë†pt
cid:63
approximately
cid:63
decoding
succeeds
establishing
existence
trajectory
Ë†pt
discussed
proving
point
must
close
central
part
proof
1.4
structure
section
formally
present
channel
model
encoder
decoding
process
addition
present
careful
description
adversarial
behavior
section
presents
overview
00.511.522.533.54
cid:1
cid:1
10400.10.20.30.40.50.60.70.80.91
cid:2
cid:1
cid:1
cid:3
cid:2
cid:1
1243
cid:2
cid:4
cid:1
cid:2
cid:3
cid:2
cid:1
cid:1
cid:3
cid:2
cid:1
cid:1
cid:2
cid:3
cid:2
cid:1
code
analysis
proof
achievability
theorem
1.1.
due
space
limitations
technical
claims
proofs
appear
appendix
model
output
alphabet
channel
adv
cid:8
advi|i
cid:9
sequence
mappings
represents
channel
model
positive
integer
let
denote
set
Â·Â·Â·
transmission
duration
symbols
q-ary
causal
adversarial
error-erasure
channel
characterized
two
triples
cid:63
adv
cid:63
fractions
symbol
errors
symbol
erasures
calvin
impose
codeword
Â·Â·Â·
Â·Â·Â·
input
adversarial
behavior
time
step
precisely
map
advi
iÃ—y
iâˆ’1
function
time
transmitting
i-th
symbol
maps
sequence
channel
inputs
time
Â·Â·Â·
together
sequence
previous
channel
outputs
time
Â·Â·Â·
yiâˆ’1
iâˆ’1
output
symbol
functions
advi
must
satisfy
adversarial
power
constraint
namely
point
time
total
number
errors
erasures
exceed
cid:63
respectively
proof
use
random
code
distribution
deï¬ne
distribution
codes
distribution
claim
existence
ï¬xed
code
allows
reliable
communication
alice
bob
channel
model
code
construction
denotes
code
rate
private
secret
rate
encoder
deï¬ned
explicitly
shortly
quantization
parameter
speciï¬ed
let
cid:2
qnr
cid:3
denote
alice
message
set
cid:2
qns
cid:3
set
private
random
secrets
available
alice
encoder
randomness
neither
shared
receiver
adversary
let
uniform
distribution
stochastic
codes
let
Â·Â·Â·
c1/Î¸
stochastic
codes
i.i.d
according
probability
distribution
speciï¬cally
1/Î¸
corresponding
stochastic
code
map
chosen
distribution
cid:0
s1/Î¸
cid:1
encoder
given
message
1/Î¸
secrets
Â·Â·Â·
s1/Î¸
codeword
length
respect
message
1/Î¸
secrets
deï¬ned
concatenation
1/Î¸
chunks
sub-codewords
Â·Â·Â·
c1/Î¸
i-th
sub-codeword
entire
codeword
denotes
concatenation
two
chunks
sub-codewords
distinguish
concatenated
code
code
chunk
call
Â·Â·Â·
c1/Î¸
sub-codes
hereafter
code
analysis
focuses
two
diï¬€erent
parts
entire
code
deï¬ned
follows
deï¬nition
2.1.
let
code
block-length
consist
1/Î¸
sub-codes
i.e.
Â·Â·Â·
c1/Î¸
let
2nÎ¸
Â·Â·Â·
code
preï¬x
respect
concatenation
ï¬rst
sub-codes
deï¬nition
2.2.
let
code
block-length
consist
1/Î¸
sub-codes
i.e.
Â·Â·Â·
c1/Î¸
let
2nÎ¸
Â·Â·Â·
code
suï¬ƒx
respect
concatenation
last
sub-codes
analysis
convenient
describe
encoding
scheme
alice
causal
manner
namely
assume
secret
value
corresponding
encoding
i-th
chunk
chosen
alice
immediately
i-th
chunk
transmitted
sooner
mentioned
show
positive
probability
code
chosen
random
based
distribution
certain
properties
allow
reliable
communication
channel
model
cid:16
cid:17
decoding
process
decoding
process
bob
done
iterative
manner
speciï¬cally
upon
receiving
entire
codeword
errors
erasures
ï¬xed
bob
identiï¬es
smallest
value
corresponding
end
location
chunk
attempts
correctly
decode
transmitted
message
based
codeword
preï¬x
suï¬ƒx
respect
position
decoding
process
terminated
message
decoded
bob
otherwise
value
increased
chunk
size
bob
attempts
decode
process
continues
reaches
approximately
end
codeword
decodings
succeeds
decoder
error
declared
qâˆ’1
cid:63
qâˆ’1
9q2
cid:17
cid:63
cid:63
cid:16
qâˆ’1
cid:1
messages
phase
bob
obtains
list
show
list
size
consists
cid:0
attempt
decoding
divided
two
phases
first
position
bob
chooses
estimate
Ë†pt
fraction
errors
respect
unerased
positions
used
calvin
codeword
preï¬x
knÎ¸
proof
come
show
Ë†pt
satisï¬es
two
important
conditions
list-decoding
condition
energy
bounding
condition
see
claim
b.7
list-decoding
condition
allows
bob
decode
codeword
preï¬x
Â·Â·Â·
list
decoder
list
size
messages
case
Ë†pt
equals
true
fraction
symbol
errors
respect
unerased
positions
holds
transmitted
message
next
second
phase
energy
bounding
condition
states
Ë†pt
equals
symbol
errors
codeword
suï¬ƒx
respect
position
therefore
show
bob
use
natural
consistency
decoder
deï¬ned
determine
whether
stop
continue
decoding
process
precisely
decoding
process
continues
consistency
decoder
fails
return
message
stops
message
decoded
messages
decoder
also
stops
reached
size
qâˆ’1
cid:63
number
erasures
position
deï¬nition
2.3.
let
let
cid:48
suï¬ƒx
consistent
word
suï¬ƒx
cid:48
qâˆ’1
agree
cid:48
deï¬nition
2.4.
consistency
decoder
applied
code
suï¬ƒx
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
respect
position
knÎ¸
list
decoder
takes
word
suï¬ƒx
received
word
cid:48
returns
unique
message
list
one
whose
codeword
suï¬ƒxes
consistent
cid:48
one
message
exists
decoding
error
declared
nâˆ’t
two
word
suï¬ƒxes
respect
position
word
fraction
unerased
positions
nâˆ’tâˆ’np
cid:63
+Î»t
9q2
cid:63
appear
analysis
let
cid:16
cid:17
cid:16
formally
decoder
process
bob
described
follows
essentially
use
following
deï¬nition
Ë†pt
estimate
calvin
error
corruption
fraction
respect
unerased
positions
time
used
bob
slightly
revised
later
deï¬nition
b.3
robust
slight
slacknesses
Ë†pt
otherwise
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:16
qâˆ’1
value
Ë†pt
qâˆ’1
cid:63
cid:17
cid:63
Ë†pt
cid:63
qâˆ’1
cid:17
cid:16
cid:17
tâˆ’Î»t
grows
qâˆ’1
cid:63
increases
constant
design
parameter
considered
arbitrarily
small
description
recall
cid:16
qâˆ’1
cid:63
cid:17
identify
position
k0nÎ¸
integer
smallest
integer
cid:16
qâˆ’1
cid:16
Î»t0
qâˆ’1
qâˆ’1
cid:63
cid:17
list-decode
code
preï¬x
Â·Â·Â·
respect
position
obtain
list
messages
size
list-decoding
radius
Ë†pt
precisely
message
list
codeword
corresponding
unerased
symbols
codeword
preï¬x
respect
position
distance
Ë†pt
corresponding
unerased
symbols
received
word
preï¬x
verify
codeword
suï¬ƒxes
respect
position
corresponding
messages
list
consistency
decoder
compares
symbols
unerased
positions
speciï¬cally
consider
hamming
balls
radius
equal
cid:63
centered
codeword
suï¬ƒx
codeword
corresponding
messages
list
corresponding
received
word
suï¬ƒx
outside
balls
increase
goto
step
received
word
suï¬ƒx
lies
exactly
one
balls
decode
message
corresponding
center
ball
received
word
suï¬ƒx
lies
one
ball
decoding
error
declared
cid:16
qâˆ’1
cid:17
cid:63
9q2
every
message
bob
decodes
correctly
estimate
equals
bob
decodes
correctly
cid:63
codeword
suï¬ƒx
codewords
corresponding
messages
list
consistent
received
word
corresponds
message
show
indeed
happens
w.h.p
random
secrets
nâˆ’t
cid:63
used
alice
codeword
suï¬ƒx
respect
position
cid:63
bob
estimate
equal
bob
said
make
decoding
error
probability
error
message
deï¬ned
probability
alice
private
secrets
bob
decodes
incorrectly
probability
error
code
deï¬ned
maximum
probabilities
error
message
messages
rate
said
achievable
every
every
suï¬ƒciently
large
exists
code
block
length
allows
alice
communicate
râˆ’Î²
distinct
messages
bob
probability
error
supremum
achievable
rates
capacity
channel
adversarial
behavior
behavior
calvin
speciï¬ed
channel
model
particular
interested
calvin
corrupts
codeword
errors
characterized
function
deï¬ned
speciï¬es
many
errors
ejected
calvin
up-to
position
normalized
number
unerased
positions
refer
trajectory
note
exact
trajectory
used
calvin
known
decoder
bob
deï¬nition
2.5
calvin
trajectory
let
codeword
length
consist
1/Î¸
chunks
sub-
codewords
let
2nÎ¸
Â·Â·Â·
let
actual
fraction
symbol
errors
respect
unerased
positions
codeword
preï¬x
respect
position
analysis
assume
calvin
certain
capabilities
may
beyond
available
causal
adversary
without
loss
generality
studying
lower
bounds
achievable
rate
work
assume
trajectory
Ë†pt
bob
uses
decoding
process
known
calvin
implies
show
calvin
knows
position
cid:63
bob
eventually
stops
decoding
process
addition
assume
list
messages
obtained
bob
list
decoding
process
determined
explicitly
calvin
moreover
assume
calvin
knows
message
priori
every
list-decoding
position
knÎ¸
stress
subsequent
secrets
namely
sk+1
sk+2
Â·Â·Â·
s1/Î¸
codeword
suï¬ƒx
unknown
calvin
indeed
given
causal
nature
alice
encoding
secrets
even
chosen
alice
point
time
fact
secrets
hidden
calvin
implies
sk+1
sk+2
Â·Â·Â·
s1/Î¸
completely
independent
list
obtained
bob
list
decoding
determined
calvin
fact
crucial
analysis
also
strengthen
calvin
allowing
choose
symbols
corrupt
position
cid:63
cid:63
non-causally
namely
assume
calvin
chooses
corruption
pattern
looking
ahead
remaining
symbols
transmitted
codeword
show
matter
corruptions
chosen
codeword
suï¬ƒx
cid:63
cid:63
cid:63
symbols
error
fact
distribution
cid:63
cid:63
Â·Â·Â·
s1/Î¸
independent
list
allow
show
bob
succeeds
decoding
cid:16
qâˆ’1
cid:17
cid:63
9q2
code
analysis
due
space
limitations
technical
details
proof
appear
entirely
appendix
follows
give
roadmap
proof
including
major
high-level
arguments
used
appendix
throughout
constant
design
parameter
considered
arbitrarily
small
existence
trajectory
Ë†pt
analysis
bob
decoding
begins
selecting
decoding
reference
trajectory
Ë†pt
deï¬nition
b.3
proxy
trajectory
calvin
trajectory
recall
fraction
errors
respect
unerased
positions
codeword
preï¬x
accordingly
Ë†pt
fraction
symbols
respect
unerased
positions
bob
assumes
errors
general
trajectories
Ë†pt
equal
show
claim
b.7
position
qâˆ’1
selected
decoding
reference
trajectory
Ë†pt
satisï¬es
two
important
conditions
list-decoding
condition
energy
bounding
condition
introduced
qâˆ’1
cid:63
cid:16
cid:17
Ë†pt
Ë†pt
9q2
cid:63
list
decoding
condition
guarantees
small
list
size
decoding
done
radius
Ë†pt
energy
bounding
condition
restricts
remaining
errors
adversary
codeword
suï¬ƒx
bob
estimate
Ë†pt
approximately
correct
prove
correctness
decoding
procedure
must
introduce
new
trajectory
Ëœpt
closely
related
counterpart
Ë†pt
sense
Ëœpt
approximately
equals
Ë†pt
former
slightly
smaller
latter
parameter
introduced
allow
robustness
analysis
absorbs
certain
slacknesses
result
code
construction
analysis
technique
e.g.
fact
chunk
size
made
small
give
precise
deï¬nitions
times
better
understood
intuitively
reader
keeps
discussion
mind
notation
given
table
existence
position
cid:63
Ë†pt
cid:63
cid:39
cid:63
next
analysis
chooses
integer
position
k0nÎ¸
cid:39
Î»t0
benchmarking
position
separate
analysis
two
cases
based
whether
pt0
greater
Ë†pt0
use
following
classiï¬cation
qâˆ’1
cid:63
qâˆ’1
cid:16
cid:17
deï¬nition
3.1
high
type
trajectory
trajectory
calvin
consider
values
Ë†pt
position
pt0
Ë†pt0
calvin
trajectory
high
type
trajectory
deï¬nition
3.2
low
type
trajectory
trajectory
calvin
consider
values
Ë†pt
position
pt0
Ë†pt0
calvin
trajectory
low
type
trajectory
high
type
trajectory
calvin
show
claim
b.8
always
intersects
Ë†pt
point
matter
corruption
pattern
chosen
calvin
i.e.
point
bob
estimate
Ë†pt
equal
actual
amount
errors
moreover
claim
b.9
claim
b.10
implies
value
cid:63
chunk
end
falls
immediately
intersection
point
guaranteed
remaining
error
budget
calvin
low
sense
number
errors
calvin
introduce
codeword
suï¬ƒx
respect
cid:63
less
cid:63
cid:63
cid:63
hand
low
type
trajectory
calvin
already
know
approximately
Ë†pt
point
nearly
thus
show
claim
b.11
setting
cid:63
equal
guaranteed
remaining
error
budget
calvin
low
sense
number
errors
calvin
introduce
codeword
suï¬ƒx
respect
cid:63
less
cid:63
cid:63
cid:63
cid:63
formally
cid:16
qâˆ’1
cid:17
cid:63
cid:16
qâˆ’1
cid:17
9q2
9q2
deï¬nition
3.3.
let
9q2
let
2nÎ¸
Â·Â·Â·
pt0
Ë†pt0
cid:63
k0nÎ¸
pt0
Ë†pt0
cid:63
smallest
value
cid:63
âˆ’nÎ¸
Ë†pt
cid:63
âˆ’nÎ¸
cid:63
Ë†pt
cid:63
success
bob
decoding
bob
starts
decoding
position
continues
decode
subsequent
chunk
ends
message
returned
consistency
decoder
bob
reaches
end
received
word
claim
b.12
corollary
b.13
via
list
decoding
condition
guarantee
bob
ï¬rst
phase
decoding
always
obtain
list
messages
list
size
cid:0
cid:1
list
decoder
cid:63
9q2
nâˆ’tâˆ’np
cid:63
+Î»t
fraction
remaining
part
unerased
symbols
codeword
matter
position
currently
considered
analysis
claim
b.12
corollary
b.13
claims
come
w.h.p
random
code
construction
moreover
energy
bounding
condition
implies
case
cid:39
Ë†pt
unused
errors
left
calvin
less
qâˆ’1
start
studying
case
current
iteration
bob
satisï¬es
cid:63
implies
cid:39
Ë†pt
claim
b.17
claim
b.18
claim
b.20
show
cid:63
calvin
remaining
error
budget
suï¬ƒcient
mislead
consistency
decoder
allow
unique
decoding
list
messages
bob
holds
namely
show
high
probability
secret
random
symbols
alice
used
encoding
process
code
design
guarantees
message
list
consistent
transmitted
codeword
one
transmitted
alice
precisely
consider
consistency
checking
phase
bob
iteration
cid:63
iteration
know
via
energy
bounding
condition
number
unused
errors
calvin
less
qâˆ’1
nâˆ’tâˆ’np
cid:63
+Î»t
fraction
remaining
part
unerased
symbols
codeword
point
time
bob
holds
small
list
messages
implicitly
determined
calvin
via
consistency
decoder
wishes
ï¬nd
unique
message
list
transmitted
transmitted
message
list
small
guarantee
high
probability
code
design
codeword
suï¬ƒxes
corresponding
roughly
distance
nâˆ’t
qâˆ’1
codeword
suï¬ƒx
message
list
turn
implies
given
bound
calvin
remaining
error
budget
decoding
succeed
however
analysis
misleading
one
must
overcome
adversarial
choice
establishing
correct
decoding
note
naÂ¨Ä±ve
use
union
bound
suï¬ƒce
overcome
potential
lists
successful
decoding
regardless
calvin
adversarial
behavior
use
randomness
alice
stochastic
encoding
known
priori
calvin
fact
calvin
causal
recall
every
9q2
cid:63
message
encoded
several
codewords
based
randomness
alice
let
slef
sright
collection
alice
random
symbols
used
position
cid:63
respectively
calvin
perhaps
partially
determines
list
may
assume
full
knowledge
slef
however
causal
nature
knowledge
regarding
sright
list
obtained
position
cid:63
bob
may
take
advantage
fact
independent
randomness
sright
used
alice
speciï¬cally
instead
considering
single
codeword
analysis
corresponds
consider
family
codewords
one
hand
share
speciï¬c
slef
corresponds
calvin
view
position
cid:63
diï¬€erent
sright
calvin
perspective
position
cid:63
codewords
family
equivalent
completely
match
view
far
using
family
codewords
independent
analysis
allowing
decoding
fail
small
fraction
enables
amplify
success
rate
decoding
procedure
extent
used
needed
union
bound
full
analysis
given
claim
b.17
claim
b.18
claim
b.20
address
case
cid:54
cid:63
claim
b.10
case
previous
discussions
holds
high
type
trajectory
calvin
Ë†pt
Ëœpt
cid:54
cid:63
show
decoding
process
bob
return
codewords
messages
list
fail
consistency
test
case
continue
next
value
next
chunk
end
summarize
properties
code
claim
b.21
properties
established
bob
iterative
decoder
show
claim
b.23
bob
able
correctly
decode
transmitted
message
w.h.p
randomness
alice
finally
theorem
b.24
show
channel
capacity
claimed
indeed
achievable
depict
ï¬‚ow
claims
corollaries
theorems
proof
achievability
figure
remark
scenario
wherein
calvin
lookahead
also
handled
via
codes
roughly
back
rate
trajectory
Ë†pt
gets
shifted
left
sacriï¬ce
symbols
calvin
demanding
stringent
energy-bounding
condition
satisï¬ed
block
length
second
part
succeeding
cid:63
reduced
tweaks
remainder
analysis
n-lookahead
codes
identical
causal
codes
discussed
references
gilbert
comparison
signalling
alphabets
bell
system
technical
journal
:504â€“522
1952
varshamov
estimate
number
signals
error
correcting
codes
dokl
acad
nauk
117:739â€“741
1957
mceliece
rodemich
rumsey
welch
new
upper
bounds
rate
ieee
transactions
information
theory
code
via
delsarte-macwilliams
inequalities
:157â€“166
1977
dey
jaggi
langberg
codes
online
adversaries
part
large
alphabets
ieee
transactions
information
theory
:3304â€“3316
2013
langberg
jaggi
dey
binary
causal-adversary
channels
ieee
international
symposium
information
theory
proceedings
isit
pages
2723â€“2727
2009
haviv
langberg
beating
gilbert-varshamov
bound
online
channels
ieee
international
symposium
information
theory
proceedings
isit
pages
1392â€“1396
2011
dey
jaggi
langberg
sarwate
improved
upper
bounds
capacity
binary
channels
causal
adversaries
ieee
international
symposium
information
theory
proceedings
isit
pages
681â€“685
2012
bassily
smith
causal
erasure
channels
proceedings
acm-siam
symposium
discrete
algorithms
soda
pages
1844â€“1857
2014
chen
jaggi
langberg
characterization
capacity
online
causal
binary
channels
proceedings
forty-seventh
annual
acm
symposium
theory
computing
pages
287â€“296
acm
2015
lapidoth
narayan
reliable
communication
channel
uncertainty
ieee
transactions
information
theory
:2148â€“2177
1998
langberg
oblivious
channels
capacity
ieee
transactions
information
theory
:424â€“429
2008
guruswami
smith
codes
computationally
simple
channels
explicit
constructions
optimal
rate
proceedings
51st
annual
ieee
symposium
foundations
computer
science
focs
pages
723â€“732
ieee
2010
dey
jaggi
langberg
sarwate
upper
bounds
capacity
binary
channels
causal
adversaries
ieee
transactions
information
theory
:3753â€“3763
2013
dey
jaggi
langberg
sarwate
coding
delayed
adversaries
ieee
international
symposium
information
theory
proceedings
isit
pages
285â€“289
2010
mazumdar
capacity
memoryless
adversary
arxiv
preprint
arxiv:1401.4642
2014
blackwell
breiman
thomasian
capacities
certain
channel
classes
random
coding
annals
mathematical
statistics
pages
558â€“567
1960
blake
mullin
introduction
algebraic
combinatorial
coding
theory
academic
press
inc.
1976
csiszar
narayan
capacity
arbitrarily
varying
channel
revisited
positivity
constraints
ieee
transactions
information
theory
:181â€“193
1988
guruswami
list
decoding
error-correcting
codes
lecture
notes
computer
science
volume
3282-2005
springer
2001.
appendices
converse
start
summarizing
several
deï¬nitions
claims
detailed
presentations
claims
followed
summary
depict
ï¬‚ow
claims
theorems
figure
summary
event
deï¬nitions
figure
organization
claims
theorems
converse
event
babble-attacked
word
preï¬x
suï¬ƒcient
entropy
alice
message
conditioned
babble-attacked
word
preï¬x.event
ğ¸ğ¸4
push-attacked
word
suï¬ƒx
roughly
distance
away
corresponding
codewordsuï¬ƒxes
alice
message
calvin
message.event
ğ¸ğ¸1
certain
number
messages
drawn
conditional
distribution
messages
given
babble-attacked
word
preï¬x
distinct.event
ğ¸ğ¸3
hamming
distance
codewordsuï¬ƒxes
corresponding
alice
message
calvin
message
large.event
ğ¸ğ¸2
calvin
chosen
message
diï¬€erent
alice
message.claim
a.2â„™ğ¸ğ¸is
bounded
away
zero
theorem
a.1
plotkinbound
codewordsin
code
large
minimum
distance
lemma
a.3the
probability
i.i.d
random
variables
nonzero
entropy
distinct
bounded
away
zero
theorem
a.7under
babble-and-push
attack
strategy
average
error
probability
bounded
away
zero.claim
a.6â„™ğ¸ğ¸4ğ¸ğ¸2ğ¸ğ¸3is
large.claim
a.4â„™ğ¸ğ¸1ğ¸ğ¸is
bounded
away
zero.claim
a.5â„™ğ¸ğ¸2ğ¸ğ¸3ğ¸ğ¸is
bounded
away
zero
event
babble-attacked
word
preï¬x
suï¬ƒcient
entropy
alice
message
i.e.
transmitted
message
conditioned
babble-attacked
word
preï¬x
event
certain
number
messages
drawn
conditional
distribution
messages
given
babble-attacked
word
preï¬x
distinct
event
calvin
chosen
message
diï¬€erent
alice
message
event
hamming
distance
codeword
suï¬ƒxes
respect
pushing
phase
attack
corresponding
alice
message
calvin
message
large
event
resulting
word
suï¬ƒx
respect
pushing
phase
attack
roughly
distance
away
codeword
suï¬ƒxes
respect
pushing
phase
attack
corresponding
alice
message
calvin
message
summary
claims
theorems
theorem
a.1
codewords
code
large
minimum
distance
claim
a.2
probability
happens
bounded
away
zero
lemma
a.3
probability
i.i.d
random
variables
nonzero
entropy
distinct
bounded
away
zero
claim
a.4
probability
e1|e
happens
bounded
away
zero
claim
a.5
probability
e2e3|e
happens
bounded
away
zero
claim
a.6
probability
e4|e2e3
happens
large
theorem
a.7
babble-and-push
attack
strategy
average
error
probability
bounded
away
zero
let
let
cid:16
qâˆ’1
fraction
symbol
errors
cid:63
cid:16
cid:17
qâˆ’1
cid:17
qâˆ’1
erasures
let
following
unless
otherwise
speciï¬ed
refers
source
entropy
symbols
q-ary
entropy
obtained
normalizing
standard
binary
entropy
factor
log
refers
q-ary
entropy
function
namely
logq
logq
logq
qâˆ’1
cid:63
fraction
symbol
babble-and-push
attack
babble
let
cid:0
cid:1
position
transmitted
codeword
calvin
adopts
babble
strategy
calvin
chooses
random
subset
nÂ¯p
indices
uniformly
set
nÂ¯p-sized
subset
calvin
changes
symbol
precisely
chosen
calvin
uniformly
Â·Â·Â·
push
let
ï¬rst
symbols
transmitted
alice
ï¬rst
symbols
resulting
calvin
babble
attack
namely
Â·Â·Â·
Â·Â·Â·
calvin
constructs
set
pairs
encodings
close
speciï¬cally
set
constructed
calvin
ï¬rst
symbols
next
calvin
chooses
element
cid:48
cid:48
byb
uniformly
random
considers
corresponding
encoding
cid:48
cid:48
cid:48
cid:48
Â·Â·Â·
cid:48
cid:48
byb
nÂ¯p
cid:54
cid:48
probability
half
calvin
uses
errors
calvin
uses
errors
calvin
erases
subsequent
symbols
whenever
cid:54
cid:48
calvin
uses
cid:63
erasures
calvin
sets
cid:48
theorem
a.1
q-ary
plotkin
bound
qdmin
qdminâˆ’
qâˆ’1
codewords
q-ary
code
block
length
minimum
distance
dmin
cid:16
cid:17
let
random
variable
corresponding
alice
input
message
random
variable
cor-
responding
alice
input
codeword
random
variable
corresponding
output
channel
let
random
variables
corresponding
respectively
let
cid:8
cid:8
u|yb
cid:9
cid:9
claim
a.2
let
cid:0
cid:1
babble-and-push
attack
proof
considering
entropy
u|yb
u|yb
cid:18
cid:19
cid:17
cid:17
cid:16
nÂ¯p
cid:17
cid:18
cid:18
cid:19
cid:19
cid:18
cid:17
cid:18
cid:19
cid:19
cid:16
cid:19
cid:17
cid:18
cid:18
cid:19
cid:19
cid:18
cid:19
cid:19
follows
data-processing
inequality
follows
substituting
cid:0
cid:0
follows
assuming
monotonic
increasing
function
variate
therefore
expected
value
u|yb
least
applying
markov
inequality
random
variable
u|yb
follows
fact
xhq
cid:16
cid:17
cid:17
cid:16
maximum
value
u|yb
cid:105
u|yb
cid:1
cid:1
cid:16
cid:16
cid:18
cid:18
cid:16
cid:104
therefore
cid:104
u|yb
cid:105
follows
fact
lemma
a.3
let
random
variable
discrete
ï¬nite
set
entropy
let
Â·Â·Â·
i.i.d
copies
Â·Â·Â·
distinct
cid:18
logq
logq
cid:19
kâˆ’1
logq
|v|
proof
fix
let
Â·Â·Â·
Â·Â·Â·
let
vi+1
denotes
indicator
function
write
distribution
vi+1
vi+1
v|wi
cid:88
0,1
bound
entropy
vi+1
vi+1|wi
cid:88
logq
logq
|v|
logq
0,1
vi+1
v|wi
since
hence
logq
logq
|v|
logq
logq
logq
logq
|v|
logq
logq
logq
|v|
event
distinct
equivalent
event
Â·Â·Â·
vi+1
implies
claim
a.4
let
Ïu|yb
conditional
distribution
given
babble-and-push
attack
let
Â·Â·Â·
random
variables
drawn
i.i.d
according
Ïu|yb
let
Â·Â·Â·
distinct
large
enough
e1|e
cid:16
cid:17
kâˆ’1
proof
claim
a.2
given
event
u|yb
|v|
cid:18
logq
logq
cid:19
kâˆ’1
e1|e
lemma
a.3
setting
large
enough
thus
logq
logq
cid:17
kâˆ’1
e1|e
cid:16
let
cid:48
random
choice
calvin
message
cid:48
random
variable
codeword
corre-
sponding
cid:48
let
xb+1
xb+2
Â·Â·Â·
remaining
part
input
codeword
push
phase
corresponding
random
variable
similarly
cid:48
part
codeword
chosen
calvin
push
phase
cid:48
let
denote
hamming
distance
function
two
vectors
corresponding
random
variable
b+2
Â·Â·Â·
cid:48
cid:48
b+1
cid:48
claim
a.5
let
cid:110
cid:0
cid:48
cid:54
cid:48
cid:1
cid:63
cid:111
babble-and-push
attack
e2e3|e
proof
claim
a.4
setting
lower
bound
probability
holds
given
e2|e
distribution
Ïu|yb
distinct
least
cid:0
general
claim
a.4
shows
probability
messages
drawn
conditional
shows
exist
q-ary
codes
block
length
minimum
distance
qdâˆ’
qâˆ’1
nâˆ’b
codewords
let
byb
set
mutually
independent
pairs
uniformly
byb
setting
exist
codewords
cid:48
corresponding
pairs
cid:48
cid:48
bybwith
distance
satisfying
cid:1
kâˆ’1
hand
plotkin
bound
theorem
a.1
cid:1
kâˆ’1
claim
a.4
theorem
a.1
together
imply
probability
least
cid:0
solving
using
cid:0
cid:1
cid:63
cid:18
cid:19
cid:63
cid:63
cid:63
let
cid:63
probability
selection
set
event
hold
let
fraction
pairs
byb
satisfy
cid:54
k2Î³
cid:35
cid:18
cid:19
codewords
corresponding
pairs
set
corresponding
message
random
variables
however
probability
Â·Â·Â·
distance
less
distinct
least
one
pair
codewords
Â·Â·Â·
distinct
cid:34
cid:91
cid:34
cid:91
cid:110
cid:111
cid:35
cid:17
cid:16
since
event
analyzed
includes
cid:16
cid:17
cid:16
cid:17
hence
deï¬nition
e2e3|e
claim
a.6
let
hamming
distance
chosen
alice
cid:48
corresponding
part
word
received
bob
resulting
calvin
push
attack
let
chosen
calvin
let
cid:26
cid:18
cid:19
cid:27
babble-and-push
attack
e4|e2e3
2âˆ’Ï‰
n2
proof
assume
calvin
erases
cid:63
symbols
push
phase
let
cid:63
hamming
distance
cid:48
without
considering
positions
corresponding
erasures
constraints
calvin
error
budget
calvin
would
change
locations
expectation
conditioned
event
event
cid:63
4this
actually
corresponds
calvin
strongest
attack
babble
phase
uses
fraction
budget
symbols
errors
push
phase
potentially
uses
remainder
symbol
error
budget
also
cid:63
erasure
budget
assume
probability
half
calvin
changes
original
symbol
intended
symbol
cid:48
bound
probability
number
changes
symbols
deviates
expectation
push
attack
2âˆ’Ï‰
n2
chernoï¬€
theorem
a.7
code
stochastic
encoding
rate
babble-and-push
strategy
average
error
probability
lower
bounded
cid:16
cid:17
cid:17
cid:1
symbols
drawn
cid:0
cid:48
cid:16
proof
idea
behind
proof
conditioned
events
calvin
symmetrize
channel
calvin
corrupt
symbols
manner
bob
unable
distinguish
two
possible
codewords
cid:48
corresponding
two
diï¬€erent
messages
cid:48
calvin
ensuring
probability
bounded
away
zero
word
received
bob
equally
likely
decoded
either
cid:48
corresponding
messages
cid:48
let
cid:48
cid:48
joint
distribution
received
word
end
babble
phase
alice
message
randomness
calvin
chosen
message
randomness
cid:48
cid:48
al-
ice
uniform
choice
calvin
attack
let
y|yb
cid:48
cid:48
conditional
distribution
calvin
attack
let
probabilistic
map
namely
mapping
random
variable
taking
values
error
probability
written
cid:88
cid:0
cid:48
cid:48
cid:1
cid:88
cid:0
y|yb
cid:48
cid:48
cid:1
cid:54
cid:48
cid:48
let
set
tuples
cid:48
cid:48
satisfying
events
claims
a.2
a.5
show
cid:0
cid:48
cid:1
suï¬ƒciently
small
cid:48
cid:48
cid:54
cid:48
assuming
holds
since
calvin
change
symbol
diï¬€erent
cid:48
half
corresponding
part
received
word
may
result
either
cid:48
thus
conditional
distribution
symmetric
probability
equal
probability
claim
a.6
cid:48
cid:48
cid:0
y|yb
cid:48
cid:48
cid:1
cid:0
y|yb
cid:48
cid:48
cid:1
cid:88
cid:0
yp|yb
cid:48
cid:48
cid:1
2âˆ’Ï‰
n2
returning
overall
error
probability
let
unconditional
probability
bob
receiving
babble
phase
probability
alice
uniform
choice
calvin
babble
attack
since
posteriori
distributions
cid:48
cid:48
given
independent
uniform
byb
joint
distribution
written
cid:0
cid:48
cid:48
cid:1
|byb|2
cid:0
cid:48
cid:48
cid:1
therefore
yp|yb
cid:48
cid:48
yp|yb
cid:48
cid:48
hence
2Â¯
cid:88
cid:0
cid:48
cid:48
cid:1
cid:0
yp|yb
cid:48
cid:48
cid:1
cid:2
cid:54
cid:48
cid:3
cid:88
cid:0
yp|yb
cid:48
cid:48
cid:1
cid:54
cid:88
cid:0
cid:48
cid:48
cid:1
cid:88
cid:0
yp|yb
cid:48
cid:48
cid:1
cid:0
cid:54
cid:2
cid:54
cid:48
cid:3
cid:1
cid:88
cid:0
cid:48
cid:48
cid:1
cid:88
cid:0
yp|yb
cid:48
cid:48
cid:1
cid:16
2âˆ’Ï‰
n2
cid:17
cid:88
achievability
start
summarizing
several
deï¬nitions
claims
detailed
presentations
deï¬nitions
claims
followed
summary
depict
ï¬‚ow
claims
corollaries
theorems
figure
preliminary
deï¬nitions
technical
claims
deï¬nition
b.1
deï¬nes
calvin
trajectory
respect
unerased
positions
number
symbol
errors
normalized
number
unerased
positions
deï¬nition
b.2
deï¬nes
bob
guess
random
noise
Â¯pt
deriving
deï¬nition
decoding
reference
trajectory
Ë†pt
deï¬nition
b.3
deï¬nes
bob
decoding
reference
trajectory
Ë†pt
revision
deï¬ni-
tion
given
section
deï¬nition
b.4
deï¬nes
two
types
trajectory
calvin
according
Ë†pt0
deï¬nition
b.5
deï¬nes
energy
bounding
trajectory
Ëœpt
delimits
smallest
value
meets
energy
bounding
condition
lemma
b.6
technical
lemma
gives
certain
upper
bound
q-ary
entropy
function
list
decoding
energy
bounding
properties
claim
b.7
central
claim
shows
decoding
reference
trajectory
Ë†pt
satisï¬es
list-decoding
condition
energy
bounding
condition
establishing
existence
correct
decoding
point
claim
b.8
calvin
trajectory
always
intersects
decoding
reference
trajectory
Ë†pt
later
second
last
chunk
claim
b.9
high
type
trajectory
value
chunk
end
immediately
intersection
decoding
reference
trajectory
Ë†pt
satisï¬es
energy
bounding
condition
recall
Ë†pt
deï¬ned
respect
unerased
positions
figure
organization
claims
corollaries
theorems
achievability
claim
b.7list-decoding
condition
energy
bounding
conditionhigh
type
trajectory
ğ‘ğ‘ğ‘¡ğ‘¡0â‰¥ï¿½ğ‘ğ‘ğ‘¡ğ‘¡0
low
type
trajectory
ğ‘ğ‘ğ‘¡ğ‘¡0
ï¿½ğ‘ğ‘ğ‘¡ğ‘¡0
claim
b.10ğ‘ğ‘ğ‘¡ğ‘¡âˆ—satisfies
energy
bounding
conditionclaim
b.9ğ‘ğ‘ğ‘¡ğ‘¡âˆ—is
ï¿½ğ‘ğ‘ğ‘¡ğ‘¡âˆ—and
ï¿½ğ‘ğ‘ğ‘¡ğ‘¡âˆ—claim
b.8existence
intersection
point
ğ‘ğ‘ğ‘¡ğ‘¡and
ï¿½ğ‘ğ‘ğ‘¡ğ‘¡existence
correct
decoding
point
ğ’•ğ’•âˆ—existence
correct
decoding
point
ğ’•ğ’•âˆ—=ğ’•ğ’•ğŸğŸclaim
b.11ğ‘ğ‘ğ‘¡ğ‘¡0satisfies
energy
bounding
conditionlemma
b.6bounding
ğ»ğ»ğ‘ğ‘
list
decoding
message
list
size
ğ“ğ“ğŸğŸğğclaim
b.12list
size
code
prefix
corollary
b.13list
size
every
code
prefixexistence
good
code
suffixclaim
b.20
w.h.p
every
code
suffix
good
w.r.t
every
message
every
list
codewordsuffices
sequences
secretsclaim
b.18
w.h.p
code
suffix
good
w.r.t
message
list
codewordsuffices
sequences
secretsclaim
b.17
w.h.p
code
suffix
good
w.r.t
message
list
codewordsuffices
sequence
secretstheorem
b.24channel
capacityclaim
b.21good
properties
code
designclaim
b.23probability
decoding
error
claim
b.10
larger
Ëœpt
point
satisï¬es
energy
bounding
condition
claim
b.11
point
pt0
approximately
Ë†pt0
satisï¬es
energy
bounding
condi-
tion
list
decoding
properties
claim
b.12
code
preï¬x
list
decoded
list
messages
size
cid:0
corollary
b.13
every
code
preï¬x
list
decoded
list
messages
size
cid:0
cid:1
high
cid:1
probability
high
probability
utilizing
energy
bounding
condition
deï¬nition
b.14
deï¬nes
distance
codeword
suï¬ƒx
list
codeword
suï¬ƒxes
deï¬nition
b.15
deï¬nes
certain
goodness
properties
code
suï¬ƒx
respect
message
list
codeword
suï¬ƒxes
messages
excluding
transmitted
message
sequence
secrets
deï¬nition
b.16
deï¬nes
Ïƒ-goodness
property
code
suï¬ƒx
respect
message
list
codeword
suï¬ƒxes
messages
excluding
transmitted
message
sequences
secrets
claim
b.17
code
suï¬ƒx
good
respect
message
list
codeword
suï¬ƒxes
messages
excluding
transmitted
message
sequence
secrets
claim
b.18
code
suï¬ƒx
Ïƒ-good
respect
message
list
codeword
suï¬ƒxes
messages
excluding
transmitted
message
claim
b.20
every
code
suï¬ƒx
Ïƒ-good
respect
every
transmitted
message
every
list
codeword
suï¬ƒxes
messages
excluding
transmitted
message
summary
proof
theorem
1.1
claim
b.21
high
probability
code
possesses
needed
properties
claim
b.23
high
probability
bob
succeeds
decoding
theorem
b.24
rephrasing
theorem
1.1
channel
capacity
cid:17
fraction
symbol
errors
cid:63
cid:16
cid:17
qâˆ’1
qâˆ’1
let
let
cid:16
symbol
erasures
cid:63
qâˆ’1
9q2
let
2nÎ¸
Â·Â·Â·
let
assume
received
word
symbol
errors
cid:63
erasures
let
number
erasures
position
let
k0nÎ¸
smallest
integer
Î»t0
let
Î¸3/q2
secret
rate
namely
qns
size
set
secrets
available
alice
qâˆ’1
cid:63
qâˆ’1
cid:16
cid:17
fraction
b.1
preliminaries
deï¬nition
b.1
calvin
trajectory
let
actual
fraction
symbol
errors
respect
unerased
positions
codeword
preï¬x
respect
position
deï¬nition
b.2
bob
guess
random
noise
Â¯pt
Â¯pt
cid:63
cid:18
cid:19
deï¬nition
b.3
bob
decoding
reference
trajectory
Ë†pt
let
Â¯pt
Â¯pt
deï¬nition
b.2
qâˆ’1
Â¯pt
qâˆ’1
cid:63
cid:104
cid:104
cid:16
cid:16
cid:17
cid:16
qâˆ’1
cid:63
qâˆ’1
cid:63
cid:17
cid:16
qâˆ’1
cid:63
cid:17
cid:105
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:17
qâˆ’1
qâˆ’1
ï£±ï£²ï£³
Â¯pt
9q2Î±2
Â¯pt
Ë†pt
Â¯pt
9q2Î±2
deï¬nition
b.4
trajectory
type
trajectory
calvin
consider
values
Ë†pt
position
pt0
Ë†pt0
calvin
trajectory
high
type
trajectory
otherwise
low
type
trajectory
deï¬nition
b.5
energy
bounding
trajectory
Ëœpt
let
Â¯pt
deï¬nition
b.2
qâˆ’1
Â¯pt
qâˆ’1
cid:63
Â¯pt
lemma
b.6
let
logq
logq
logq
1/q
1/2
Â¯pt
Ëœpt
Â¯pt
9q2
proof
prove
lemma
ï¬rst
show
log
log
cid:2
cid:1
cid:3
cid:0
since
cid:0
hand
cid:0
cid:2
cid:1
let
log
cid:48
cid:0
cid:1
cid:2
cid:1
cid:48
cid:0
cid:1
log
therefore
cid:1
cid:48
1âˆ’x
solving
cid:48
obtain
cid:3
log
cid:0
log
cid:1
thus
replacing
log
since
concave
namely
second
derivative
negative
1/q
therefore
cid:19
cid:19
cid:18
cid:18
cid:18
cid:18
logq
log
log
log
log
logq
log
log
cid:19
logq
cid:19
log
log
log
log
log
log
log
log
cid:19
monotonically
increasing
follows
follows
note
xâˆ’1âˆš
1/2
xâˆ’1âˆš
hence
follows
cid:18
cid:18
cid:18
cid:16
log
cid:19
log
cid:19
cid:17
log
b.2
list
decoding
energy
bounding
properties
cid:20
cid:19
cid:19
cid:21
qâˆ’1
cid:63
let
qâˆ’1
claim
b.7
let
cid:18
cid:104
qâˆ’1
exists
Ë†pt
1/q
following
conditions
satisï¬ed
cid:18
min
Â¯pâˆˆ
cid:16
qâˆ’1
cid:63
Ë†pt
Ë†pt
9q2
cid:63
cid:17
cid:16
qâˆ’1
cid:63
cid:17
cid:105
2/4
proof
first
note
exists
cid:104
cid:104
qâˆ’1
cid:63
cid:17
cid:105
cid:16
cid:16
qâˆ’1
qâˆ’1
Â¯pt
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:63
cid:17
nÎ±q
Â¯pt
dividing
sides
obtain
cid:16
cid:16
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:16
qâˆ’1
cid:63
cid:17
cid:105
Â¯pt
substituting
Â¯pt
obtain
nÎ±q
Â¯pt
next
replacing
nÎ±q
Â¯pt
substitute
Ë†pt
left
hand
side
lhs
get
cid:33
9q2Î±2
Â¯pt
cid:33
9q2Î±2
Â¯pt
cid:18
Â¯pt
9q2Î±2
Â¯pt
Â¯pt
Â¯pt
cid:18
Â¯pt
cid:32
cid:32
cid:18
cid:18
cid:20
cid:18
Â¯pt
Ë†pt
Â¯pt
cid:18
Â¯pt
cid:18
Â¯pt
cid:18
Â¯pt
cid:18
Â¯pt
Â¯pt
Â¯pt
Â¯pt
9q2Î±2
Â¯pt
cid:115
cid:115
cid:19
cid:19
cid:19
cid:19
cid:19
cid:19
cid:19
cid:19
cid:18
qÎ±q
Â¯pt
cid:19
cid:19
cid:21
Â¯pt
Â¯pt
Â¯pt
min
Â¯pâˆˆ
follows
lemma
b.6
follows
2+ln
qâˆ’1
cid:104
cid:16
cid:17
cid:16
qâˆ’1
cid:63
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:17
qâˆ’1
cid:63
Ë†pt
cid:19
cid:19
cid:18
Ë†pt
9q2Î±2
cid:18
qÎ±q
cid:19
cid:18
cid:18
cid:18
cid:18
cid:20
cid:19
cid:19
cid:18
cid:19
cid:18
cid:19
cid:18
min
Â¯pâˆˆ
cid:18
cid:19
cid:19
cid:19
cid:21
qÎ±q
follows
lemma
b.6
2+ln
qâˆ’1
thus
far
satisï¬ed
condition
claim
see
condition
substitute
Ë†pt
lhs
note
cid:104
qâˆ’1
cid:63
cid:17
cid:105
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:16
cid:16
Â¯pt
therefore
cid:18
Â¯pt
cid:19
9q2Î±2
Â¯pt
Â¯pt
9q2
n22
9q2
9q2
nÂ¯pt
nÂ¯pt
cid:63
cid:63
Ë†pt
9q2Î±2
cid:17
monotonically
qâˆ’1
Â¯pt
Â¯pt
qâˆ’1
cid:63
cid:17
cid:17
cid:19
9q2Î±2
Â¯pt
9q2
cid:16
follows
substituting
Â¯pt
cid:104
increasing
cid:104
cid:16
qâˆ’1
cid:63
cid:16
Â¯pt
let
Â¯pt
qâˆ’1
Â¯pt
9q2Î±2
cid:17
9q2Î±2
Â¯pt
9q2Î±2
therefore
9q2Î±2
9q2
follows
cid:16
qâˆ’1
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:17
cid:17
cid:16
qâˆ’1
qâˆ’1
cid:63
qâˆ’1
cid:63
cid:18
Â¯pt
Â¯pt
cid:63
b.3
establishing
existence
correct
decoding
point
first
show
Ë†pt
must
eventually
greater
claim
b.8
proof
since
cid:104
cid:16
qâˆ’1
cid:63
Ë†pt
qâˆ’1
cid:63
cid:17
cid:105
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:16
hence
Ë†pt
Â¯pt
Â¯pt
9q2Î±2
Â¯pt
Ë†pt
nÂ¯pt
nÂ¯pt
n22
9q2
n2
9q2
n2
9q2
n2
9q2
follows
Â¯pt
follows
substituting
expression
Â¯pt
cid:17
cid:16
qâˆ’1
cid:63
cid:17
cid:105
ptâˆ’nÎ¸
qâˆ’1
cid:63
qâˆ’1
cid:16
qâˆ’1
cid:63
cid:17
cid:105
cid:16
cid:16
Ë†ptâˆ’nÎ¸
Ëœpt
claim
b.9
cid:104
qâˆ’1
cid:63
cid:17
proof
cid:104
Ë†pt
Ë†pt
Î»tâˆ’nÎ¸
ptâˆ’nÎ¸
Ë†pt
Î»tâˆ’nÎ¸
Ë†ptâˆ’nÎ¸
cid:19
cid:18
Â¯pt
qâˆ’1
9q2Î±2
Â¯pt
Â¯pt
Â¯ptâˆ’nÎ¸
Â¯pt
Â¯ptâˆ’nÎ¸
Â¯pt
Î»tâˆ’nÎ¸
cid:18
n22
9q2
cid:18
Â¯ptâˆ’nÎ¸
Â¯ptâˆ’nÎ¸
9q2Î±2
Â¯ptâˆ’nÎ¸
cid:19
Î»tâˆ’nÎ¸
cid:19
follows
using
fact
pnâˆ’nÎ¸
Ë†pnâˆ’nÎ¸
following
substituting
expression
Ë†pt
follows
Â¯pt
follows
substituting
expression
Â¯pt
hand
since
Ëœpt
Â¯pt
Â¯pt
nâˆ’t
Ë†pt
Ëœpt
n2
9q2
9q2
tâˆ’Î»t
9q2
n22
9q2
tâˆ’Î»t
Ë†pt
n22âˆ’
nâˆ’t
tâˆ’Î»t
n22
9q2
9q2
9q2
Ë†pt
n2
follows
since
Ë†pt
Ëœpt
Ë†pt
follows
Ëœpt
show
Ëœpt
cid:104
cid:104
cid:16
cid:16
Â¯pt
qâˆ’1
cid:63
qâˆ’1
Â¯pt
Â¯pt
9q2Î±2
cid:16
cid:17
cid:17
qâˆ’1
cid:63
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:63
qâˆ’1
qâˆ’1
cid:16
qâˆ’1
cid:17
let
monotonically
increasing
qâˆ’1
Ë†pt
therefore
qâˆ’1
cid:63
cid:17
cid:17
cid:16
cid:17
Ë†pt
Ëœpt
Ëœpt
n22
9q2
cid:104
cid:104
cid:16
cid:16
qâˆ’1
qâˆ’1
cid:17
qâˆ’1
cid:16
cid:16
cid:17
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:63
qâˆ’1
cid:63
cid:17
cid:17
cid:17
Ë†pt
Ë†pt
Î»tâˆ’nÎ¸
Ë†ptâˆ’nÎ¸
qâˆ’1
qâˆ’1
cid:63
next
consider
diï¬€erence
Ë†pt
Ë†pt
9q2Î±2
thus
Ë†pt
Î»tâˆ’nÎ¸
Ë†pt
cid:17
qâˆ’1
cid:63
cid:17
cid:104
cid:16
qâˆ’1
Ë†pt
qâˆ’1
qâˆ’1
cid:63
cid:17
cid:16
Ë†pt
Ë†pt
Î»tâˆ’nÎ¸
Ë†ptâˆ’nÎ¸
cid:19
Ë†pt
Î»tâˆ’nÎ¸
cid:18
Â¯pt
9q2Î±2
Â¯pt
Â¯pt
Î»tâˆ’nÎ¸
cid:18
Â¯ptâˆ’nÎ¸
Â¯ptâˆ’nÎ¸
cid:19
Â¯ptâˆ’nÎ¸
9q2Î±2
cid:16
qâˆ’1
Ë†pt
Ëœpt
follows
Ëœpt
hence
cid:104
position
cid:104
qâˆ’1
cid:63
cid:16
tâˆ’Î»t
claim
b.10
let
portion
symbol
errors
codeword
respect
unerased
positions
Ëœpt
qâˆ’1
qâˆ’1
cid:63
qâˆ’1
cid:63
cid:17
qâˆ’1
cid:16
cid:17
cid:17
qâˆ’1
cid:63
cid:17
cid:105
cid:17
cid:16
Ë†pt
qâˆ’1
9q2
cid:63
nâˆ’tâˆ’np
cid:63
+Î»t
proof
deï¬nition
npâˆ’
tâˆ’Î»t
nâˆ’np
cid:63
âˆ’t+Î»t
since
Ëœpt
Ëœpt
cid:63
cid:63
cid:63
9q2
cid:18
nÂ¯pt
cid:18
9q2
cid:19
cid:63
cid:63
cid:63
cid:108
1âˆ’2pq/
qâˆ’1
cid:63
qâˆ’1
âˆ’2/4
cid:109
cid:19
9q2
follows
Â¯pt
follows
Î»t0
k0nÎ¸
pt0
Ë†pt0
claim
b.11
let
Ë†pt0
9q2Î±2
Î»t0
pt0
proof
since
k0nÎ¸
cid:0
2pq/
cid:63
2/4
cid:1
Î»t0
9q2
cid:63
Î»t0
cid:18
2pq
cid:18
2pq
cid:18
cid:18
cid:19
cid:19
cid:63
cid:19
cid:19
cid:63
cid:63
Î»t0
n2
9q2
Î»t0
pt0
9q2
b.4
list
decoding
properties
claim
b.12
let
Î¸3/q2
let
cid:104
qâˆ’1
cid:63
knÎ¸
Ë†pt
code
Â·Â·Â·
list-decodable
Ë†pt
symbol
errors
list
size
qâˆ’1
cid:16
cid:17
probability
least
qâˆ’âˆ†
code
design
cid:16
qâˆ’1
cid:63
cid:17
cid:105
Ë†pt
nÎ¸2/q2
radius
number
potential
codewords
chunks
cid:0
qnÎ¸
cid:1
qknÎ¸
Ë†pt
1/q
number
proof
proof
follows
ideas
thm
10.3
modiï¬ed
slightly
correspond
stochastic
codes
stress
although
code
stochastic
message
corresponds
several
codewords
analyze
number
diï¬€erent
messages
codewords
fall
hamming
ball
limited
words
length
hamming
ball
radius
Ë†pt
tâˆ’Î»t
Ë†pt
cid:88
cid:18
cid:19
i=0
tâˆ’Î»t
Ë†pt
study
number
diï¬€erent
messages
corresponding
codewords
may
lie
ball
message
corresponds
qns/Î¸
codewords
since
encoding
message
independent
messages
probability
exist
messages
corresponding
codewords
length
lie
hamming
ball
radius
Ë†pt
centered
received
word
length
cid:18
qnr
cid:19
cid:16
qns/Î¸
cid:17
l+1
cid:32
tâˆ’Î»t
Ë†pt
tâˆ’Î»t
cid:33
l+1
cid:32
tâˆ’Î»t
Ë†pt
tâˆ’Î»t
cid:33
l+1
nr+nÎ¸2/q2
l+1
thus
probability
received
word
chunks
list-decoded
list
size
greater
nr+nÎ¸2/q2
tâˆ’Î»t
1âˆ’hq
Ë†pt
l+1
tâˆ’Î»t
nr+nÎ¸2/q2
tâˆ’Î»t
1âˆ’hq
Ë†pt
l+1
quantify
study
cid:2
cid:0
nÎ¸2/q2
cid:1
Ë†pt
cid:3
since
Ë†pt
Ë†pt
nÎ¸2/q2
hence
solving
Ë†pt
nÎ¸2/q2
therefore
satisï¬es
code
c1â—¦c2â—¦Â·Â·Â·â—¦ck
l-list
decodable
probability
least
1âˆ’qâˆ’âˆ†
corollary
b.13
let
logq
let
cid:104
cid:16
cid:17
cid:16
qâˆ’1
cid:63
cid:17
cid:105
qâˆ’1
knÎ¸
probability
least
code
Â·Â·Â·
l-list
decodable
Ë†pt
symbol
errors
list
size
code
design
tâˆ’Î»t
Ë†pt
qâˆ’1
cid:63
cid:19
cid:18
logq
Ë†pt
nÎ¸2/q2
proof
claim
b.12
probability
qâˆ’3
logq
code
Â·Â·Â·
l-list
decodable
list
size
logq
Ë†pt
nÎ¸2/q2
therefore
probability
code
decoded
list
size
greater
qâˆ’3
logq
since
Ë†pt
probability
code
Â·Â·Â·
l-list
decodable
chunks
least
cid:0
/4
Î¸2/q2
cid:1
thus
obtain
addition
since
Ë†pt
Ë†pt
nÎ¸2/q2
cid:17
cid:16
logq
/4
Î¸2/q2
cid:18
cid:19
cid:0
s1/Î¸
cid:0
s1/Î¸
number
chunks
1/Î¸
cid:1
distance
cid:1
suï¬ƒx
given
set
least
b.5
utilizing
energy
bounding
condition
unless
otherwise
speciï¬ed
2nÎ¸
Â·Â·Â·
integer
preï¬x
code
codeword
respect
position
integer
1/Î¸
number
chunks
suï¬ƒx
code
codeword
respect
position
deï¬nition
b.14
codeword
suï¬ƒx
ck+1
sk+1
ck+2
sk+2
Â·Â·Â·
c1/Î¸
set
codeword
suï¬ƒxes
hamming
distance
suï¬ƒx
ck+1
sk+1
â—¦ck+2
sk+2
Â·Â·Â·
c1/Î¸
follows
deï¬ne
properties
code
respect
list
codeword
suï¬ƒxes
list
consists
codeword
suï¬ƒxes
corresponding
messages
obtained
bob
list
decoding
phase
decoding
excluding
true
message
alice
wishes
communicate
bob
indeed
list
may
Ë†pt
consideration
hence
size
qnsl
true
message
qnsl
true
message
deï¬nition
b.15
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
good
respect
list
code-
ck+1
sk+1
ck+2
sk+2
Â·Â·Â·
c1/Î¸
list
deï¬nition
b.16
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
list
codeword
suï¬ƒxes
message
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
good
respect
message
list
portion
sequences
secrets
set
claim
b.17
let
sk+1
sk+2
Â·Â·Â·
s1/Î¸
sequence
1/Î¸
secrets
probability
greater
qâˆ’Î´
nâˆ’t
code
design
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
good
respect
message
list
secrets
sk+1
sk+2
Â·Â·Â·
s1/Î¸
Î¸2/q2
Î¸3/q2
word
suï¬ƒxes
message
sequence
secrets
cid:0
sk+1
sk+2
Â·Â·Â·
s1/Î¸
cid:1
distance
nâˆ’t
qâˆ’1
cid:1
codeword
suï¬ƒx
cid:0
s1/Î¸
nâˆ’t
22
9q3
proof
let
cid:8
Â·Â·Â·
cid:9
list
codeword
suï¬ƒxes
note
qnsl
cid:0
cid:1
deï¬ne
forbidden
region
respect
list
cid:91
hamming
ball
center
radius
nâˆ’t
qâˆ’1
notion
forbidden
region
figure
nâˆ’t
22
9q3
depict
i=1
figure
three
realizations
forbidden
regions
realization
shaded
disks
correspond
forbidden
region
isolated
red
point
codeword
suï¬ƒx
outside
forbidden
region
since
size
list
number
words
length
forbidden
region
determined
cid:18
cid:19
cid:88
i=0
cid:16
qâˆ’1
cid:17
22
cid:17
9q3
2Î¸2
qâˆ’1
cid:16
nâˆ’t
cid:16
cid:16
logq
nâˆ’t
nâˆ’t
2Î¸2
qâˆ’1
nâˆ’t
cid:17
cid:17
follows
taylor
series
q-ary
entropy
function
neighborhood
1/q
i.e.
qâˆ’1
substitution
9q2
qâˆ’1
2iâˆ’1+1
cid:17
cid:80
2iâˆ’1
qâˆ’1
cid:16
i=1
suï¬ƒciently
large
Î¸3/q2
constant
follows
2Î¸2
logq
logq
cid:18
2Î¸2
logq
c/
cid:19
2Î¸2
substituting
cid:18
cid:88
i=0
cid:19
nâˆ’t
1âˆ’Î´
Î¸2/q2
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
cid:1
codeword
suï¬ƒx
corresponding
message
let
ck+1
sk+1
â—¦ck+2
sk+2
â—¦Â·Â·Â·â—¦c1/Î¸
codeword
suï¬ƒx
region
deï¬nition
b.15
code
suï¬ƒx
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
cid:0
s1/Î¸
cid:1
good
respect
message
list
secrets
sk+1
sk+2
Â·Â·Â·
s1/Î¸
therefore
probability
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
codeword
suï¬ƒx
ck+1
sk+1
â—¦ck+2
sk+2
â—¦Â·Â·Â·â—¦c1/Î¸
lie
forbidden
region
cid:0
s1/Î¸
cid:2
ck+1
sk+1
ck+2
sk+2
Â·Â·Â·
c1/Î¸
cid:0
s1/Î¸
cid:1
cid:3
qnâˆ’t
nâˆ’t
1âˆ’Î´
qnâˆ’t
nâˆ’t
claim
b.18
probability
larger
qâˆ’n2
code
design
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
length
1/Î¸
Ïƒ-good
respect
message
list
qâˆ’nÎ¸4
proof
let
cid:2
qns
cid:3
set
integers
qns
start
considering
partition
set
codeword
suï¬ƒxes
corresponding
message
lâˆ’1
disjoint
subsets
speciï¬cally
partition
set
secrets
lâˆ’1
disjoint
sets
set
indexed
element
sk+2
s1/Î¸
lâˆ’1
set
ssâˆ—
corresponding
1/Î¸
equals
cid:110
ssâˆ—
1/Î¸
cid:2
qns
cid:3
cid:111
addition
done
modulo
qns
holds
k+2
k+2
cid:91
ssâˆ—
sâˆ—âˆˆslâˆ’1
1/Î¸
k+1
cid:48
cid:0
s1/Î¸
cid:1
correspond-
let
lâˆ’1
analysis
use
fact
two
l-tuples
sk+1
sk+2
s1/Î¸
1/Î¸
appear
ssâˆ—
property
coordinates
diï¬€er
k+2
cid:48
cid:48
cid:48
k+1
s1/Î¸
cid:54
cid:48
namely
sk+1
cid:54
cid:48
consider
set
qns
codeword
suï¬ƒxes
ck+1
sk+1
â—¦ck+2
sk+2
â—¦Â·Â·Â·â—¦c1/Î¸
ing
l-tuples
sk+1
sk+2
s1/Î¸
certain
set
ssâˆ—
partition
speciï¬ed
codeword
suï¬ƒx
consists
chunks
construction
set
qns
codeword
suï¬ƒxes
corresponding
sk+1
sk+2
s1/Î¸
ssâˆ—
independent
uniformly
distributed
follows
directly
code
construction
property
ssâˆ—
discussed
thus
sk+1
sk+2
s1/Î¸
1/Î¸
ssâˆ—
event
code
suï¬ƒx
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
good
respect
cid:48
cid:48
message
list
secrets
sk+1
sk+2
Â·Â·Â·
s1/Î¸
independent
event
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
good
respect
message
list
secrets
cid:48
k+1
cid:48
claim
b.17
code
suï¬ƒx
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
good
respect
message
list
sequence
secrets
sk+1
sk+2
Â·Â·Â·
s1/Î¸
probability
less
nâˆ’t
thus
probability
code
suï¬ƒx
ck+1â—¦ck+2â—¦Â·Â·Â·â—¦c1/Î¸
good
respect
message
list
certain
portion
sequences
secrets
set
ssâˆ—
less
k+2
Â·Â·Â·
cid:48
k+2
cid:48
k+1
cid:48
1/Î¸
cid:16
nâˆ’t
cid:17
Ïƒqns
nâˆ’t
Î´Ïƒqns
number
possible
Ïƒ-portions
set
ssâˆ—
cid:18
qns
cid:19
Ïƒqns
2qns
2qnsÂ·
âˆ’2Ïƒ
log
follows
âˆ’2Ïƒ
log
1/2
say
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
message
list
codeword
suï¬ƒxes
secret
set
ssâˆ—
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
good
respect
message
list
portion
sequences
secrets
set
ssâˆ—
probability
code
design
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
message
list
secrets
ssâˆ—
cid:2
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
w.r.t
ssâˆ—
cid:3
nâˆ’t
Î´Â·Ïƒqns
2qnsÂ·
âˆ’2Ïƒ
log
qÏƒqns
nâˆ’t
Î´âˆ’2
log
logq
qÏƒqns
âˆ’nÎ¸Î´âˆ’2
log
logq
nÎ¸3/q2âˆ’nÎ¸4
âˆ’nÎ¸3/q2+2nÎ¸4
qâˆ’n3
follows
substituting
Î¸2/q2
Î¸3/q2
qâˆ’nÎ¸4
follows
suï¬ƒciently
large
union
bounding
sets
ssâˆ—
partition
get
suï¬ƒciently
large
cid:2
âˆƒsâˆ—
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
w.r.t
ssâˆ—
cid:3
qâˆ’n3
qns
lâˆ’1
qâˆ’n2
finally
notice
Ïƒ-good
respect
message
list
codeword
suï¬ƒxes
secret
set
ssâˆ—
partition
implies
Ïƒ-good
respect
message
list
hence
probability
code
design
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
message
list
cid:2
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
w.r.t
cid:3
qâˆ’n2
remark
b.19
goodness
code
suï¬ƒx
guarantees
consistency
check
decoding
process
succeeds
speciï¬cally
code
good
respect
certain
list
certain
message
addition
codeword
suï¬ƒx
received
errors
message
list
w.h.p
unique
element
passes
consistency
checking
phase
bob
list
consistency
checking
phase
bob
return
message
w.h.p.
claim
b.20
let
qâˆ’nÎ¸4
probability
greater
qâˆ’n
code
design
every
message
every
list
every
chunk
end
code
suï¬ƒx
Ïƒ-good
respect
message
list
proof
number
possible
lists
obtained
certain
chunk
end
position
depends
set
messages
size
c/
constant
thus
size
qcnr/
cid:18
qnr
cid:19
c/
claim
b.18
know
qâˆ’nÎ¸4
probability
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
message
list
every
chunk
end
position
least
qnr
qcnr/
1/Î¸
qâˆ’n2
qâˆ’n2+3cn/
qâˆ’n
suï¬ƒciently
large
b.6
summary
claim
b.21
probability
least
following
properties
satisï¬ed
qâˆ’n
code
design
exists
good
code
size
cid:0
adversarial
error
erasure
patterns
exists
position
cid:63
cid:63
code
preï¬x
respect
position
cid:63
Â·Â·Â·
cid:63
list
decodable
cid:63
cid:63
Ë†pt
cid:63
errors
list
corresponding
cid:1
transmitted
message
let
list
codeword
suï¬ƒxes
adversarial
error
erasure
patterns
position
cid:63
received
word
suï¬ƒx
respect
position
total
amount
erasures
plus
twice
amount
er-
rors
bounded
total
amount
errors
bounded
cid:63
moreover
code
suï¬ƒx
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
cid:16
qâˆ’1
cid:16
qâˆ’1
22
cid:17
cid:63
transmitted
message
list
qâˆ’nÎ¸4
cid:17
9q2
9q2
proof
consider
possible
error
erasure
patterns
adversary
analyzing
calvin
possible
trajectories
precisely
given
erasure
pattern
analyze
calvin
possible
behaviors
unerased
symbol
positions
mentioned
possible
trajectories
calvin
classiï¬ed
two
types
high
type
trajectory
low
type
trajectory
cid:63
9q2
cid:0
cid:1
probability
low
type
trajectory
pt0
Ë†pt0
let
k0nÎ¸
integer
notice
choice
Ë†pt
list-decoding
condition
always
satisï¬ed
therefore
corollary
b.13
list
decoding
radius
Î»t0
Ë†pt0
code
preï¬x
Â·Â·Â·
ck0
list
decodable
errors
list
size
code
design
addition
since
Î»t0
pt0
Î»t0
Ë†pt0
far
ï¬rst
property
stated
claim
satisï¬ed
low
type
trajectory
claim
b.11
pt0
satisï¬es
energy
bounding
condition
deï¬nition
b.5
pt0
Ëœpt0
claim
b.10
received
word
suï¬ƒx
respect
position
fraction
qâˆ’1
nâˆ’t0âˆ’np
cid:63
+Î»t0
unerased
symbols
error
moreover
since
cid:63
Î»t0
cid:17
cid:16
qâˆ’1
erasures
received
word
suï¬ƒx
total
amount
erasures
twice
amount
22
errors
suï¬ƒx
cid:63
Î»t0
cid:63
Î»t0
claim
b.20
code
suï¬ƒx
ck0+1
â—¦ck0+2
â—¦Â·Â·Â·â—¦c1/Î¸
Ïƒ-good
respect
message
list
probability
qâˆ’n
code
design
hence
low
type
trajectory
code
design
possesses
two
properties
stated
claim
moreover
case
cid:63
high
type
trajectory
pt0
Ë†pt0
claim
b.8
given
trajectory
high
type
trajectory
always
intersects
Ë†pt
later
position
Î»t+nâˆ’
qâˆ’1
cid:63
âˆ’nÎ¸
let
cid:63
chunk
end
immediately
intersection
point
cid:63
Ë†pt
cid:63
implies
cid:63
âˆ’nÎ¸
Ë†pt
cid:63
âˆ’nÎ¸
Ëœpt
cid:63
âˆ’nÎ¸
let
knÎ¸
cid:63
position
corollary
b.13
list
decoding
radius
Ë†pt
code
cid:16
qâˆ’1
22
nâˆ’t0âˆ’np
cid:63
+Î»t0
9q2
cid:17
cid:63
9q2
preï¬x
Â·Â·Â·
list
decodable
errors
list
size
cid:0
cid:1
probability
cid:16
qâˆ’1
9q2
22
design
also
cid:63
since
cid:63
cid:63
cid:63
cid:63
cid:63
Ë†pt
cid:63
transmitted
message
list
since
cid:63
âˆ’nÎ¸
Ë†pt
cid:63
âˆ’nÎ¸
claim
b.9
cid:63
Ëœpt
cid:63
claim
b.10
trajectory
high
type
cid:63
received
word
suï¬ƒx
respect
position
fraction
qâˆ’1
nâˆ’t0âˆ’np
cid:63
+Î»t0
unerased
symbols
error
cid:63
cid:63
9q2
claim
b.20
code
suï¬ƒx
respect
position
ck+1
ck+2
Â·Â·Â·
c1/Î¸
Ïƒ-good
respect
message
list
probability
qâˆ’n
code
design
thus
far
high
type
trajectory
properties
claim
also
satisï¬ed
code
design
conclusion
probability
code
possesses
two
properties
least
cid:16
qâˆ’1
22
nâˆ’tâˆ’np
cid:63
+Î»t
cid:17
cid:17
cid:63
cid:63
9q2
code
qâˆ’n
remark
b.22
note
using
code
claim
b.21
position
cid:63
found
bob
iterative
decoding
process
starting
position
therefore
decoding
process
bob
stop
cid:63
correctly
precisely
claim
b.21
ensures
every
time
bob
obtains
list
codewords
matter
transmitted
message
list
code
suï¬ƒx
respect
position
cid:63
Ïƒ-good
respect
message
list
codeword
suï¬ƒxes
words
strictly
smaller
cid:63
consistency
decoding
bob
return
message
cid:63
consistency
decoding
return
correct
message
high
probability
randomness
alice
thus
bob
correctly
determine
whether
continue
decoding
process
claim
b.23
let
qâˆ’1
cid:20
qâˆ’1
cid:63
let
cid:19
cid:19
cid:21
cid:18
cid:18
min
Â¯pâˆˆ
message
corresponding
encoding
using
code
established
claim
b.21
encoder
section
decoding
procedures
described
section
allows
bob
correctly
decode
message
probability
least
nqâˆ’nÎ¸4
random
secrets
available
alice
proof
decoding
error
occurs
consistency
decoder
fails
return
single
message
decoder
returns
message
equal
transmitted
message
strictly
less
cid:63
claim
b.21
property
claim
b.21
remark
b.22
deï¬nition
step
decoding
procedure
consistency
check
decoding
process
return
message
probability
randomness
encoding
precisely
deï¬nition
3.3
deï¬nition
iterative
decoding
process
strictly
less
cid:63
Ë†pt
since
list-decoding
radius
tË†pt
tpt
list
obtain
list-decoding
phase
include
transmitted
message
consistency
decoder
return
message
high
probability
addition
cid:63
probability
consistency
check
decoding
process
return
correct
message
speciï¬cally
cid:63
cid:54
claim
b.9
cid:63
Ëœpt
cid:63
cid:63
claim
b.11
energy
bounding
condition
satisï¬ed
pt0
deï¬nition
b.5
cid:63
Ëœpt
cid:63
energy
bounding
condition
satisï¬ed
cid:63
cid:63
Ëœpt
cid:63
claim
b.10
amount
errors
codeword
suï¬ƒx
bounded
therefore
deï¬nition
consistency
decoder
claim
b.20
consistency
decoder
return
correct
message
high
probability
cases
success
probability
obtained
probability
sequence
secrets
used
codeword
suï¬ƒx
chosen
particular
portion
may
cause
decoding
failure
claim
b.20
qâˆ’nÎ¸4
therefore
probability
successful
decoding
least
nqâˆ’nÎ¸4
theorem
b.24
capacity
q-ary
causal
adversarial
channels
symbol
errors
erasures
cid:20
cid:18
min
Â¯pâˆˆ
cid:18
cid:19
cid:19
cid:21
qâˆ’1
cid:63
qâˆ’1
proof
let
converse
proven
section
namely
code
stochastic
achievability
encoding
rate
average
error
probability
lower
bounded
proof
follows
claim
b.23
section
speciï¬cally
suï¬ƒciently
large
holds
claim
b.23
decoding
error
bounded
addition
suï¬ƒciently
small
continuity
q-ary
entropy
function
code
rate
claim
b.23
least
therefore
suï¬ƒciently
large
qnr
câˆ’Î²
distinct
messages
reliably
transmitted
channel
error
probability
hence
channel
capacity
q-ary
causal
adversarial
channels
symbol
errors
erasures
cid:16
cid:17
discussion
special
cases
section
discuss
several
special
cases
q-ary
causal
adversarial
channels
c.1
symbol
error
channel
q-ary
causal
adversarial
channels
symbol
errors
analysis
get
modiï¬ed
setting
cid:63
obtain
corresponding
capacity
cid:20
cid:18
cid:18
cid:19
cid:19
cid:21
min
Â¯pâˆˆ
qâˆ’1
c.2
symbol
erasure
channel
q-ary
causal
adversarial
channels
erasures
need
decoding
reference
trajectory
Ë†pt
since
erasures
visible
corresponding
list-decoding
condition
becomes
shown
exists
cid:104
following
energy-bounding
condition
satisï¬ed
cid:16
cid:63
qâˆ’1
cid:63
9q2
cid:17
cid:16
qâˆ’1
cid:63
qâˆ’1
cid:17
cid:105
modiï¬ed
conditions
decoder
bob
pin-point
value
cid:63
modiï¬ed
conditions
satisï¬ed
therefore
bob
also
able
determine
list
decoding
radius
cid:63
corresponding
capacity
cid:63
c.3
large
alphabet
suï¬ƒciently
large
cid:63
cid:17
obtain
cid:16
cid:19
cid:19
cid:21
cid:18
cid:19
cid:21
cid:20
cid:20
cid:18
cid:18
min
Â¯pâˆˆ
min
Â¯pâˆˆ
min
Â¯pâˆˆ
min
Â¯pâˆˆ
cid:63
cid:63
hence
suï¬ƒciently
large
alphabets
adversary
erasure
budget
i.e.
cid:63
capacity
matches
one
given
hand
adversary
erasure
budget
i.e.
capacity
cid:63
also
depict
special
cases
discussed
figure
comparison
binary
online
setting
bounds
figure
binary
adversarial
erasure
channels
bound
1âˆ’p
blue
corresponds
capacity
binary
obliv-
ious
erasure
channel
mrrw
bound
bound
dotted
black
best
known
upper
lower
bounds
binary
omniscient
erasure
chan-
nels
lower
bound
binary
causal
erasure
channels
bassily
smith
plotted
green
binary
adversarial
bit-ï¬‚ip
channels
bound
blue
corresponds
binary
oblivious
bit-ï¬‚ip
channel
mrrw
bound
bound
best
upper
lower
bounds
dotted
black
binary
omniscient
bit-ï¬‚ip
channels
binary
causal
bit-ï¬‚ip
channels
previous
lower
bound
haviv
langberg
slight
improvement
bound
figure
bounds
capacity
binary
online
adversarial
channels
00.10.20.30.40.50.60.70.80.9100.10.20.30.40.50.60.70.80.91pcapacitybassilyâˆ’smith
lower
bound
causal
erasure
channels
capacity
causal
erasure
channelscapacity
oblivious
erasure
channelslower
bound
omniscient
erasure
channelsupper
bound
omniscient
erasure
channels00.050.10.150.20.250.30.350.40.450.500.10.20.30.40.50.60.70.80.91pcapacitycapacity
oblivious
bitâˆ’flip
channelscapacity
causal
bitâˆ’flip
channelsupper
bound
omniscient
bitâˆ’flip
channelslower
bound
omniscient
bitâˆ’flip
channels
online
q-ary
erasure
channels
online
q-ary
error
channels
online
binary
error-erasure
channels
online
ternary
error-erasure
channels
figure
capacity
number
online
q-ary
channels
00.20.40.60.81p*00.10.20.30.40.50.60.70.80.91capacityq=2q=
cid:1
q=64q=300.10.20.30.40.5p00.10.20.30.40.50.60.70.80.91capacityq=64q=3q=2q=
cid:1
10.80.250.50.20.60.15capacity0.10.40.4p0.050.200.30p*0.20.1010.80.6capacity0.30.250.40.20.60.150.1p0.20.05000.4p*0.20
symbol
description
equality/range
table
table
parameters
capacity
block
length
fraction
codeword
changed
fraction
codeword
erased
quantization
parameter
cid:16
cid:16
cid:17
cid:17
qâˆ’1
qâˆ’1
9q2
code
rate
private
secret
rate
message
set
secret
set
input
alphabet
output
alphabet
set
chunk
ends
random
variable
input
message
random
variable
input
codeword
random
variable
output
word
message
codeword
secret
secret
length
preï¬x
number
erasures
position
number
chunks
preï¬x
w.r.t
position
number
chunks
suï¬ƒx
w.r.t
position
adversary
trajectory
guess
random
noise
decoding
reference
trajectory
energy
bounding
trajectory
list
messages
list
codeword
suï¬ƒxes
excluding
suï¬ƒxes
corresponding
list
size
list
size
Î¸3/q2
cid:2
qnr
cid:3
cid:2
qns
cid:3
Â·Â·Â·
Â·Â·Â·
2nÎ¸
Â·Â·Â·
1/Î¸
cid:0
cid:1
qnsl
cid:0
cid:1
cid:63
Â¯pt
Ë†pt
Ëœpt
