secure
index
coding
existence
construction
lawrence
ong1
badri
vellambi2
phee
lep
yeoh3
j¨org
kliewer2
jinhong
yuan4
1the
university
newcastle
australia
2new
jersey
institute
technology
usa
3university
melbourne
australia
4university
new
south
wales
australia
abstract—we
investigate
construction
weakly-secure
index
codes
sender
send
messages
multiple
receivers
side
information
presence
eavesdropper
derive
sufﬁcient
necessary
condition
existence
index
codes
secure
eavesdropper
access
subset
messages
cardinality
ﬁxed
contrast
beneﬁts
using
random
keys
secure
network
coding
prove
random
keys
promote
security
three
classes
index-coding
instances
introduction
classical1
index-coding
problems
sender
sends
multiple
messages
multiple
receivers
common
noiseless
broadcast
medium
receiver
priori
knowledge
subset
messages
subsets
receiver
wants
knows
vary
receiver
work
consider
secure
index
coding
addition
classical
setup
eavesdropper
access
subset
messages
collection
subsets
messages
sender
receivers
know
priori
collection
message
subsets
however
know
subset
messages
collection
actually
accessed
eavesdropper
weakly-secure
index
code
must
satisfy
receivers
decoding
requirements
ensuring
eavesdropper
able
decode
message
access
contributions
paper
related
work
contributions
work
three-fold
existence
secure
index
codes
secure
index
coding
ﬁrst
studied
dau
skachek
chee
authors
derived
conditions
given
linear
code
given
message
alphabet
size
must
satisfy
simultaneously
meet
receivers
decoding
requirements
well
secure
eavesdropper
access
message
subset
contrast
code-centric
results
dau
al.
obtain
problem-centric
results
derive
sufﬁcient
necessary
condition
existence
linear
non-
linear
weakly-secure
index
codes
ﬁnite-ﬁeld
alphabets
index-coding
problem
eavesdropper
access
message
subset
cardinality
show
construct
codes
exist
investigate
optimality
work
supported
arc
grants
ft140100219
de140100420
dp150100903
nsf
grants
cns-1526547
ccf-1439465
1we
use
term
classical
indicate
absence
security
con-
straints
random
keys
shown
exist
randomised
secure
network
codes
using
random
keys
instances
deterministic
secure
network
code
exists
owing
equivalence
classical
versions
net-
work
index
coding
plausible
exist
index-coding
instances
randomised
encoding
enable
security
deterministic
encoding
identify
instance
true
proven
random
keys
useful
weakly-secure
index
codes
following
three
cases
eavesdropper
access
messages
sender
encoding
function
linear
iii
eavesdropper
access
one
message
subset
secure
classical
index
coding
highlight
signiﬁ-
cant
difference
classical
secure
index
coding
classical
index
coding
messages
required
receiver
useful
removed
system
weakly-
secure
index
coding
messages
may
used
keys
problem
definition
notation
let
deﬁne
two
subsets
classical
index-coding
instance
i=1
consists
single
sender
receivers
sender
messages
i=1
independent
uniformly
distributed
ﬁnite
ﬁeld
elements
subset
integers
i|i|
i|i|
let
xi1
xi2
xi|i|
receiver
priori
knowledge
needs
decode
xwi
sender
encodes
gives
codeword
receivers
codeword
must
chosen
receiver
able
decode
messages
xwi
wants
using
codeword
messages
already
knows
without
loss
generality
may
assume
since
receivers
wanting
messages
already
know
expunged
problem
let
set
subsets
i=1
classical
secure
index-coding
instance
index-coding
instance
i=1
added
presence
eavesdropper
access
sender
codeword
precisely
one
subset
messages
eavesdropper
simultaneously
access
messages
corre-
sponding
indices
contained
one
member
set
contains
possible
subsets
indices
compromised
messages
sender
receivers
aware
oblivious
exact
subset
indices
eavesdropper
knows
addition
meeting
receivers
decoding
requirements
weakly-secure
index
codeword
must
ensure
eavesdropper
gains
additional
information
individual
message
given
codeword
formally
following
deﬁnition
deterministic
weakly-secure
index
code
i=1
i=1
code-
given
secure
index-coding
instance
deterministic
weakly-secure
index
code
length
consists
encoding
function
sender
encode
decoding
function
receiver
|wi|
decode
xwi
|ki|
decodability
xwi
weak
security
eavesdropper
accessing
information
single
message
i.e.
xi|f
cid:4
remark
classical
index-coding
instance
without
security
constraint
cid:4
notion
weak
security
considered
also
known
1-block
weakly
secure
literature
preclude
eavesdropper
gaining
information
despite
gaining
knowledge
single
message
thereof
notions
security
also
considered
literature
example
mojahedian
aref
gohari
considered
strongly-secure
index
coding
eavesdrop-
per
access
message
must
gain
information
messages
approach
involves
sender
encoding
messages
keys
pre-shared
receivers
unknown
eavesdropper
may
possible
sender
use
random
keys
along
messages
encoding
process
ensure
security
eavesdropper
therefore
introduce
following
notion
random
weakly-secure
index
codes
generalise
deterministic
weakly-secure
index
codes
deﬁnition
random
weakly-secure
index
code
let
random
variable
taking
values
ﬁnite
alphabet
known
sender
unknown
receivers
eavesdropper
random
weakly-secure
index
code
i=1
codelength
identical
deter-
ministic
index-code
setup
exception
sender
encodes
using
function
decoding
operations
decodability
conditions
security
conditions
identical
deﬁnition
rest
paper
unless
otherwise
stated
secure
index
codes
mean
weakly-secure
index
codes
deﬁnition
linear
index
code
random
index
code
linear
key
i=1
independent
uniformly
distributed
encoding
function
matrices
sizes
respectively
similarly
deterministic
index
code
linear
encoding
function
cid:4
say
secure
index
code
exists
secure
index-
coding
instance
i=1
ex-
ists
deterministic
random
secure
index
code
i=1
meets
conditions
deﬁnition
one
code
exists
say
code
secure
eavesdropper
access
message
subset
see
later
secure
index
code
may
may
exist
depending
optimal
secure
index
codelength
secure
index-coding
instance
secure
index
codes
exist
deﬁned
inﬁmum
codelengths
secure
index
codes
alphabet
sizes
iii
fundamental
properties
begin
following
counter-intuitive
proposition
proposition
let
index
code
secure
eavesdropper
knows
may
secure
eavesdropper
knows
vice
versa
proof
following
example
proves
claim
consider
four
receivers
consider
two
eaves-
droppers
ﬁrst
eavesdropper
access
second
eavesdropper
access
index
code
denotes
addition
ﬁnite
ﬁeld
secure
ﬁrst
eavesdropper
xi|c1
second
eavesdropper
decode
index
code
secure
second
eavesdropper
ﬁrst
proposition
contrast
secure
network
coding
strongly
secure
network
code
eavesdropper
access
subset
links
say
also
secure
eavesdropper
access
proposition
secure
index
code
exists
secure
i=1
exists
index-coding
instance
proof
pick
let
codeword
random
index
code
uses
key
since
xj|c
xj|c
eavesdropper
able
decode
thus
code
secure
existence
secure
index
codes
present
necessary
sufﬁcient
condition
existence
secure
index
codes
construction
furthermore
derive
optimal
secure
index
codes
certain
classes
instances
begin
speciﬁc
type
eaves-
droppers
deﬁnition
given
i=1
say
index
code
secure
eavesdropper
t-level
access
secure
index
code
i=1
|a|
lemma
deterministic
random
index
code
secure
eavesdropper
t-level
access
also
secure
eavesdropper
t′-level
access
cid:4
proof
consider
eavesdropper
t-level
access
access
member
|a|
index
code
secure
eavesdropper
must
satisfy
xi|c
consider
eavesdropper
access
level
access
member
|b|
pick
always
ﬁnd
subset
xi|c
xi|c
follows
follow
since
conditioning
increase
entropy
since
choices
arbitrary
must
xi|c
thus
index
code
also
secure
eavesdropper
t′-level
access
remark
lemma
generalises
result
dau
theorem
4.9
pertains
speciﬁcally
deterministic
linear
index
codes
random
deterministic
linear
non-
linear
index
code
cid:4
remark
although
proposition
states
index
code
secure
eavesdropper
access
may
secure
eavesdropper
access
index
code
secure
eavesdropper
t-level
access
i.e.
|a|
also
secure
eavesdropper
access
level
cid:4
existence
secure
index
codes
construction
present
necessary
sufﬁcient
condition
existence
secure
index
codes
theorem
consider
secure
index-coding
instance
i=1
|a|
i.e.
eavesdropper
t-level
access
secure
index
codes
exist
kmin
min
|ki|
deterministic
linear
secure
index
codes
exist
satisﬁed
proof
ﬁrst
prove
converse
suppose
kmin
deﬁnition
exists
receiver
say
|ki|
kmin
pick
i.e.
since
kmin
m−1
always
ﬁnd
proposition
conclude
secure
index
code
exists
next
prove
forward
part
consider
deterministic
linear
index
code
length
kmin
formed
xigi
i-th
matrix
row
let
transpose
generating
matrix
maximum-distance-separable
mds
code
always
exists
sufﬁciently
large
code
follows
rows
linearly
independent
decoding
receiver
forms
since
ki|
|ki|
kmin
follows
linearly
independent
using
receiver
decode
\ki
consequently
message
xwi
wants
solving
security
denote
hamming
distance
two
vec-
tors
a1a2
b1b2
minimum
distance
vector
space
min
b∈s
a6=b
vector
space
spanned
rows
columns
matrix
rowsp
colsp
respectively
dau
showed
linear
index
code
form
secure
eavesdropper
access
level
colsp
note
generator
matrix
mds
code
whose
codewords
vectors
rowsp
minimum
distance
mds
code
equals
rowsp
colsp
invoking
lemma
see
index
code
secure
eavesdropper
access
level
including
kmin
remarks
order
remark
mds
codes
also
used
partial-clique-
cover
coding
scheme
time-shared
version
local-chromatic-number
coding
scheme
unicast
index
coding
receivers
cid:4
remark
receiver
cooperation
increase
security
level
allowing
two
receivers
say
cooperate
share
messages
equivalent
solving
new
secure
index-coding
instance
everything
remains
receivers
know
ki∪kj
thus
except
cooperation
potentially
increase
kmin
see
translates
security
eavesdroppers
higher
access
levels
cid:4
remark
theorem
also
holds
consider
b-block
security
see
dau
deﬁnition
setting
b-block
security
eavesdropper
knows
gains
information
messages
know
i.e.
b|c
|b|
case
necessary
sufﬁcient
condition
existence
secure
index
codes
replaced
kmin
cid:4
corollary
1.1
amax
maxa∈a
|a|
kmin
deterministic
linear
secure
index
codes
exist
proof
proof
follows
theorem
lemma
intuitively
corollary
1.1
says
always
ﬁnd
secure
index
codes
eavesdropper
access
fewer
messages
receiver
however
unlike
theorem
converse
corollary
1.1.
even
eavesdropper
access
numerically
messages
receivers
may
still
able
construct
secure
index
codes
depending
sets
messages
eavesdropper
access
example
see
secure
index
codes
two
instances
amax
kmin
proof
proposition
optimality
secure
index
codes
k∈ki
xkgk
\ki
construction
secure
index
codes
theorem
following
corollary
1.2
amax
kmin
optimal
secure
index
codelength
upper-bounded
kmin
upper
bound
achievable
deterministic
linear
index
codes
proof
see
proof
theorem
say
receiver
complementary
message
i.e.
requests
wants
messages
know
proposition
amax
kmin
receiver
knowing
exactly
kmin
messages
complementary
message
requests
optimal
codelength
kmin
achievable
deterministic
secure
linear
index
codes
proof
without
loss
generality
let
|k1|
kmin
∪w1
deterministic
random
index
code
xw1|c
thus
log2
xw1
log2
log2
qkmin
made
use
facts
k1∪w1
xw1
log2
|c|
log2
log2
qkmin
therefore
kmin
since
arbitrary
follows
inf
kmin
proof
complete
invoking
corollary
1.2.
secure
represent
index-coding
secure
classical
index
coding
instance
i=1
directed
bipartite
graph
similar
neely
tehrani
zhang
independent
vertex
sets
arc
i.e.
directed
edge
connects
vertex
vertex
partition
two
disjoint
sets
representing
receivers
v|a|
representing
possible
sets
messages
eavesdropper
access
set
represents
message
indices
arc
set
deﬁned
follows
arc
receiver
knows
message
i.e.
arc
receiver
wants
message
i.e.
unique
out-neighbourhood
given
secure
index-coding
instance
ignore
security
constraint
subgraph
induced
fact
bipartite
graph
used
neely
represent
classical
index-coding
instance
proposition
consider
secure
index-coding
instance
i=1
let
directed
bipartite
graph
representation
acyclic
equivalently
acyclic
every
message
wanted
receiver
i.e.
secure
index
code
exists
proof
classical
index-coding
instance
r∪m
neely
appendix
shown
condition
true
condition
always
assumed
true
non-secure
index
coding
one
obtain
messages
index
code
even
without
using
side
information
since
secure
index
code
denoted
index
code
therefore
xi|c
since
exists
follows
index
code
secure
classical
condition
proposition
every
message
wanted
index
coding
receiver
implicit
removing
messages
wanted
receiver
change
neither
index
code
optimal
index
codelength
however
removing
unwanted
messages
may
affect
secure
index
coding
messages
used
keys
protect
index
code
eavesdropper
following
example
illustrates
idea
example
consider
following
secure
index-coding
instance
depicted
directed
bipartite
graph
representation
message
wanted
receiver
remove
setup
invoking
proposition
conclude
secure
index
code
however
keeping
system
invoking
corollary
1.1
conclude
secure
index
codes
exist
indeed
index
code
secure
acts
key
sender
receiver
protect
message
eavesdropper
random
keys
secure
index
coding
saw
example
using
unwanted
messages
keys
may
essential
ensuring
security
one
wonders
generating
random
keys
unknown
receivers
eavesdropper
also
help
secure
index
coding
answer
question
known
general
show
following
three
scenarios
random
keys
useful
sense
random
secure
index
codes
exist
deterministic
secure
index
codes
also
exist
eavesdroppers
t-level
access
theorem
follows
using
random
keys
provide
greater
security
eavesdropper
level
access
i.e.
|a|
linear
index
codes
restrict
secure
index
codes
linear
arbitrary
theorem
given
secure
index-coding
instance
random
secure
linear
index
codes
codelength
exist
deterministic
secure
linear
index
codes
codelength
also
exist
proof
need
prove
direction
claim
random
linear
index
code
expressed
since
receiver
recovers
intended
messages
receiver
exist
vector
|ki|
vector
let
deﬁned
nullspace
i.e.
cdi
null
note
vector
space
follows
since
˜ga
cdi
xgdi
˜gdi
hold
˜gdi
let
aˆℓ
basis
note
since
sender
broadcasts
ˆc1
ˆc2
ˆcˆℓ
ˆci
cai
xgai
receiver
still
able
recover
intended
messages
since
ˆcdi
linear
combination
ˆc1
ˆcˆℓ
furthermore
xj|x
xj|x
second
inequality
follows
since
function
hence
new
code
also
secure
proof
complete
noting
deterministic
index
code
remark
random
keys
also
shown
useful
linear
secure
index
codes
strong-security
setting
considered
mojahedian
eavesdroppers
access
one
message
subset
lastly
consider
class
secure
index-coding
in-
stances
eavesdropper
access
one
message
subset
proposition
given
index-coding
instance
|a|
random
secure
index
codes
exist
deterministic
secure
index
codes
also
exist
proof
note
need
consider
index-coding
instances
receiver
either
type
type
type
related
instance
index-coding
consider
otherwise
according
proposition
deterministic
random
secure
index
code
exists
let
receivers
type
rest
type
i=1
|a|c
messages
receivers
type
deﬁnition
type-2
receiver
|k′
amax
kmin
invoking
corollary
1.1
see
exists
deterministic
secure
index
code
say
means
exists
function
xi|c
show
secure
index
code
receiver
type
decoding
requirement
fulﬁlled
observing
receiver
type
gets
xwi∩a
xwi∩ac
since
knows
finally
xi|c
xi|c
xi|c
follows
inde-
pendence
hence
deterministic
secure
index
code
|a|
either
deterministic
random
secure
index
codes
exist
always
ﬁnd
deterministic
secure
index
code
secure
index
network
coding
discuss
issues
extending
equiva-
lence2
classical
index
network
coding
secure
setting
consider
following
network-coding
instance
source
two
links
receiver
codewords
conveyed
links
network
code
written
respectively
decoding
operation
equivalent
index-coding
instance
three
inde-
pendent
messages
ˆx1
ˆy1
ˆy2
four
receivers
follows
receiver
wants
ˆx1
ˆy1
ˆx1
ˆy2
ˆy1
ˆy2
ˆx1
ˆx1
ˆy1
ˆy2
since
codes
instances
translated
one
another
translate
code
index
code
ˆy1
ˆx1
ˆy2
ˆx1
next
consider
secure
version
eavesdropper
access
one
link
secure
network
code
must
strongly
secure
eavesdropper
end
need
random
network
codes
e.g.
random
key
uniformly
distributed
independent
unfortunately
code
translation
breaks
presence
security
constraints
receiver
decode
ˆy1
message
ˆx1
knows
additionally
needs
know
random
key
ˆx1
generated
sender
one
difﬁculty
establishing
equivalence
secure
network
coding
secure
index
coding
random
keys
used
sender
encoding
need
available
receivers
decoding
furthermore
also
straightfor-
ward
translate
strong
weak
security
constraints
eavesdropper
equivalent
meaningful
strong
weak
security
constraints
vice
versa
references
birk
kol
coding
demand
informed
source
iscod
efﬁcient
broadcast
different
supplemental
data
caching
clients
ieee
trans
inf
theory
2825–2830
june
2006
bar-yossef
birk
jayram
kol
index
coding
side
information
ieee
trans
inf
theory
1479–1494
mar
2011
blasiak
kleinberg
lubetzky
broadcasting
side
information
bounding
approximating
broadcast
rate
ieee
trans
inf
theory
292–298
sept.
2013
neely
duality
codes
integrality
gap
bound
index
coding
ieee
trans
inf
theory
7256–7268
nov.
2014
2the
instances
equivalent
sense
code
one
instance
translated
code
vice
versa
arbabjolfaei
bandemer
y.-h.
kim
s¸as¸o˘glu
wang
capacity
region
index
coding
proc
isit
2013
962–966
dau
skachek
chee
security
index
coding
side
information
ieee
trans
inf
theory
3975–3988
june
2012
rouayheb
sprintson
georghiades
index
coding
problem
relation
network
coding
matroid
theory
ieee
trans
inf
theory
3187–3195
july
2010
effros
rouayheb
langberg
equivalence
network
coding
index
coding
ieee
trans
inf
theory
2478–2487
may
2015
cai
yeung
secure
network
coding
wiretap
network
ieee
trans
inf
theory
424–435
jan.
2011
bhattad
narayanan
weakly
secure
network
coding
proc
netcod
2005
mojahedian
aref
gohari
perfectly
secure
index
coding
online
available
http
//arxiv.org/abs/1504.04494v2
shanmugam
dimakis
langberg
local
graph
coloring
index
coding
proc
isit
2013
1152–1156
neely
tehrani
zhang
dynamic
index
coding
wireless
broadcast
networks
proc
infocom
2012
316–324
