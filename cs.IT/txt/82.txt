integrated
interleaved
codes
locally
recoverable
codes
properties
performance
mario
blaum
steven
hetzler
ibm
almaden
research
center
san
jose
95120
march
2018
abstract
considerable
interest
paid
recent
literature
codes
combining
local
global
properties
erasure
correction
applications
cloud
type
implemen-
tations
fast
recovery
failed
storage
device
important
additional
protection
required
order
avoid
data
loss
raid
type
architectures
total
device
failures
coexist
silent
failures
page
sector
level
device
existing
solutions
problems
require
general
relatively
large
ﬁnite
ﬁelds
techniques
integrated
interleaved
codes
closely
related
generalized
concatenated
codes
proposed
reduce
signiﬁcantly
size
ﬁnite
ﬁeld
shown
parameters
codes
judiciously
chosen
performance
may
competitive
one
codes
optimizing
minimum
distance
keywords
error-correcting
codes
reed-solomon
codes
generalized
concatenated
codes
integrated
interleaved
codes
maximally
recoverable
codes
mds
codes
pmds
codes
redundant
arrays
independent
disks
raid
local
global
parities
heavy
parities
introduction
recent
literature
considerable
interest
obtaining
codes
local
global
properties
erasure
correction
idea
divide
data
symbols
sets
add
parity
symbols
local
parities
set
independently
preferably
using
mds
code
case
number
erasures
exceeding
number
parity
symbols
occurs
set
erasures
rapidly
recovered
addition
local
parities
number
global
parities
added
global
parities
involve
data
symbols
may
include
local
parity
symbols
idea
global
parities
correct
situations
erasure-correcting
power
local
parities
exceeded
figure
example
placement
data
local
global
parities
figure
xorbas
code
ten
data
two
local
four
global
symbols
situation
illustrated
figure
showing
array
row
data
denoted
encoded
local
parity
denoted
local
parity
aﬀects
row
belongs
two
global
parities
denoted
aﬀect
data
possibly
necessarily
local
parities
similarly
local
parities
aﬀect
data
corresponding
row
may
may
extend
global
parities
possible
rows
diﬀerent
lengths
one
may
simply
assume
data
symbols
zero
process
known
shortening
code
example
code
local
global
properties
global
local
parities
independent
provided
illustrated
figure
figure
data
symbols
divided
two
sets
sets
protected
local
parity
symbol
addition
data
symbols
protected
using
extra
global
parity
symbols
corresponding
reed-solomon
code
code
locality
data
means
one
data
symbol
erased
symbol
recovered
using
remaining
symbols
parity
set
locality
global
symbols
approach
letting
symbols
remain
erased
price
reducing
erasure-correcting
capability
code
one
erasure
occurs
parity
set
code
invoked
easy
see
code
minimum
distance
i.e.
four
erasures
recovered
interest
erasure
correcting
codes
local
global
properties
arises
mainly
two
applications
one
cloud
cloud
conﬁguration
may
consist
many
storage
devices
may
even
diﬀerent
geographical
locations
data
distributed
across
case
one
devices
fails
desirable
recover
contents
locally
using
parity
devices
within
set
limited
size
order
aﬀect
performance
little
possible
however
local
parity
may
enough
want
extra
protection
case
erasure-correcting
capability
local
set
exceeded
case
devices
containing
global
parities
incorporated
local
correction
power
exceeded
global
parities
invoked
correction
attempted
situation
occurs
impact
performance
data
expected
cases
local
parity
exceeded
loss
may
averted
relatively
rare
events
aforementioned
impact
performance
occur
frequently
example
type
application
refer
reader
description
azure
system
xorbas
code
discussed
figure
second
application
occurs
context
redundant
arrays
independent
disk
raid
architectures
case
raid
architecture
protects
one
storage
device
failures
example
raid
adds
one
extra
parity
device
allowing
recovery
contents
one
failed
device
raid
protects
two
device
failures
particular
devices
solid
state
drives
ssds
like
ﬂash
memories
reliability
decays
time
number
writes
reads
information
ssds
generally
divided
pages
page
containing
internal
error-correction
code
ecc
may
happen
particular
page
degrades
ecc
exceeded
however
situation
may
known
user
page
accessed
known
silent
failure
assuming
ssd
failed
raid
scheme
reconstruction
silent
page
failure
encountered
one
surviving
ssds
data
loss
occur
method
around
situation
using
raid
however
method
costly
since
requires
two
whole
ssds
parity
desirable
divide
information
raid
type
architecture
stripes
represents
size
stripe
number
ssds
raid
architecture
viewed
consisting
large
number
stripes
stripe
encoded
decoded
independently
certainly
codes
like
ones
used
cloud
applications
used
well
raid
applications
like
one
depicted
figure
describing
stripe
two
global
parities
better
rate
raid
would
require
two
whole
columns
devoted
parity
course
choice
code
depends
statistics
errors
frequency
silent
page
failures
call
symbols
entries
code
local
global
properties
symbols
whole
devices
example
case
cloud
applications
pages
case
raid
applications
ssds
let
follow
notation
consider
codes
consisting
arrays
row
array
contains
local
parities
usual
coding
notation
row
corresponds
code
assume
local
codes
mds
i.e.
erasures
row
may
corrected
locally
invoking
non-erased
symbols
row
addition
number
global
parities
added
code
let
state
deﬁnition
locally
recoverable
codes
formally
deﬁnition
1.1
consider
code
ﬁnite
ﬁeld
consisting
arrays
given
integers
arrays
satisfy
row
array
mds
code
reading
symbols
row-wise
code
say
locally
recoverable
lrc
code
deﬁnition
1.1
row
corresponds
parity
set
strictly
speaking
necessary
parity
sets
given
rows
description
disjoint
example
deﬁnition
local-error
correction
lec
codes
make
assumption
however
constructions
see
example
discussed
certainly
number
global
parities
deﬁnition
1.1
may
well
lrc
code
would
correspond
raid
scheme
row
protected
erasures
particular
corresponds
raid
corresponds
raid
question
add
global
parities
array
code
optimized
several
possible
criteria
optimization
literature
let
brieﬂy
review
given
lrc
code
natural
place
start
minimum
distance
code
singleton
type
bound
obtained
present
next
adapted
deﬁnition
1.1.
denoting
⌊x⌋
ﬂoor
minimum
distance
bounded
cid:22
cid:23
important
subcase
bound
occurs
case
bound
becomes
simply
example
figure
depicts
4,5
1,2
lrc
code
bound
states
code
easy
see
since
four
erasures
row
uncorrectable
enough
parities
three
argument
prove
general
bound
proceeds
similarly
although
next
see
stronger
criteria
optimality
lrc
codes
follow
traditional
denomination
literature
call
lrc
codes
meeting
bound
optimal
lrc
codes
work
lrc
codes
concentrates
constructing
optimal
lrc
codes
see
references
within
bound
singleton
type
bound
take
account
size
ﬁeld
bound
consider
size
ﬁeld
see
certainly
desirable
ﬁeld
small
possible
early
constructions
ﬁeld
relatively
large
satisfactory
solution
problem
constructing
optimal
lrc
codes
given
size
ﬁeld
least
i.e.
length
code
case
codes
fact
construction
viewed
generalization
codes
correspond
special
case
second
stronger
approach
optimizing
lrc
codes
given
partial
mds
pmds
codes
pmds
codes
called
maximally
recoverable
figure
patterns
corrected
4,5
1,2
pmds
code
figure
patterns
corrected
4,5
1,2
code
codes
pmds
code
addition
correcting
erasures
per
row
allows
correction
erasures
anywhere
another
way
stating
pmds
prop-
erty
punctured
code
consisting
puncturing
locations
row
code
i.e.
mds
code
figure
illustrates
correction
power
4,5
1,2
pmds
code
array
left
ﬁrst
third
rows
corrected
using
local
parity
correct
two
erasures
second
row
two
erasures
fourth
row
array
right
ﬁrst
third
fourth
rows
corrected
correct
three
erasures
second
row
4,5
1,2
pmds
code
minimum
distance
since
erasures
row
corrected
optimal
lrc
parameters
also
minimum
distance
however
optimal
lrc
code
general
correct
left
pattern
figure
hence
pmds
codes
stronger
requirements
optimal
lrc
codes
another
family
codes
local
global
properties
specially
adapted
raid
type
architectures
storage
device
ssd
given
called
sector-disk
codes
closely
related
pmds
codes
codes
tolerate
one
device
failures
addition
number
page
failures
like
case
figure
illustrate
correction
power
4,5
1,2
code
figure
see
arrays
figure
third
device
represented
third
addition
two
random
symbol
page
failures
column
total
failure
occurred
array
left
two
diﬀerent
rows
array
right
row
situations
corrected
code
code
certainly
pmds
code
like
one
depicted
figure
also
job
converse
true
code
like
one
depicted
figure
correct
general
patterns
like
one
depicted
left
figure
advantage
using
codes
pmds
codes
idea
given
requirements
less
stringent
use
smaller
ﬁnite
ﬁeld
codes
pmds
codes
example
constructions
pmds
codes
presented
constructions
size
ﬁnite
ﬁeld
satisﬁes
codes
roughly
larger
2mn
pmds
codes
obtaining
general
eﬃcient
constructions
pmds
codes
still
open
problem
given
considerations
desirable
lrc
codes
relatively
small
ﬁeld
size
operations
small
ﬁeld
less
complexity
larger
ﬁeld
due
smaller
look-up
tables
required
speciﬁcally
use
integrated
interleaved
codes
max
lrc
codes
certainly
requires
tradeoﬀ
minimum
distance
ﬁnite
ﬁeld
size
general
code
optimal
lrc
code
since
minimum
distance
achieve
bound
given
however
see
cases
minimum
distance
crucial
parameter
performance
lrc
codes
average
number
erasures
data
loss
show
respect
parameter
versatility
choice
parameters
codes
allows
often
outperform
optimal
lrc
codes
related
work
remark
stair
codes
similarly
codes
use
ﬁelds
small
size
stair
codes
assume
correlations
sector
failures
order
make
corrections
work
assume
correlations
sectors
pages
assume
symbol
protected
one
local
group
let
mention
work
considering
multiple
localities
related
work
consists
called
zigzag
codes
array
keeps
mds
property
columns
optimizes
minimum
number
updates
presence
one
column
failure
codes
strongly
related
generalized
concatenated
codes
fact
codes
constructed
goal
giving
explicit
implementation
codes
convenient
applications
like
magnetic
recording
related
codes
two-
level
coding
used
ibm
magnetic
recording
products
80s
extensions
related
codes
designed
correction
errors
paper
exploit
implicit
two
dimensional
structure
use
lrc
codes
end
need
prove
properties
tailored
erasure
model
paper
structured
follows
section
give
deﬁnition
codes
prove
main
erasure-correcting
property
derive
minimum
distance
codes
corollary
main
property
result
given
without
proof
section
brieﬂy
discuss
implementation
practice
codes
give
performance
comparisons
lrc
codes
like
optimal
lrc
codes
pmds
codes
depending
model
failure
statistics
argue
minimum
distance
always
best
parameter
measure
performance
lrc
codes
average
number
failures
follows
failures
erasures
used
interchangeably
data
loss
instead
may
important
two
parameters
certainly
completely
correlated
mds
codes
show
case
lrc
codes
particular
show
codes
although
codes
much
smaller
ﬁeld
often
outperform
optimal
lrc
codes
parameter
considered
average
number
failures
data
loss
end
paper
drawing
conclusions
integrated
interleaved
mds
codes
lrc
codes
assume
codes
describe
section
array
codes
symbols
ﬁnite
ﬁeld
characteristic
i.e.
fact
codes
described
ﬁnite
ﬁeld
characteristic
prime
number
keep
simplicity
case
relevant
applications
reading
symbols
horizontally
row-wise
manner
gives
code
length
deﬁnition
2.1
consider
set
linear
codes
ct−1
ct−2
ut−1
let
following
vector
non-decreasing
integers
length
st−1
let
ˆst
ˆsi
pt−1
st−1
ut−1
ut−1
ut−1
j=i
particular
ˆst−1
st−1
consider
code
consisting
arrays
given
array
rows
cm−1
primitive
element
αrjcj
ct−i
ˆst−i+1
ˆst−i
m−1
mj=0
say
t-level
code
notice
deﬁnition
2.1
made
assumptions
size
ﬁeld
assume
codes
mds
i.e.
codes
generally
choose
extended
codes
mds
codes
although
possibilities
discussed
section
hence
assume
rows
m−1
multiplied
powers
constituting
parity-check
matrix
ˆs1
code
require
code
mds
also
thus
deﬁnition
2.1
max
let
illustrate
construction
examples
example
2.1
assume
1-level
code
i.e.
according
deﬁnition
2.1
arrays
row
code
mds
code
i.e.
correct
erasures
example
2.2
assume
i.e.
s0+s1
2-level
code
code
mds
code
code
code
consider
array
rows
given
according
αrjcj
m−1
mj=0
codes
type
presented
parity-check
matrix
given
example
consider
according
given
4×n
array
rows
αc1
α2c2
α3c3
α2c1
α4c2
α6c3
example
2.3
assume
i.e.
3-level
code
code
mds
code
code
code
code
code
consider
array
rows
given
according
αrjcj
αrjcj
m−1
m−1
mj=0
mj=0
example
consider
given
array
rows
since
give
αc1
α2c2
α3c3
α2c1
α4c2
α6c3
seen
rows
multiplied
powers
constituting
parity-check
matrix
ˆs1
ˆs1
code
fact
also
use
parity-check
matrix
shortened
extended
ˆs1
ˆs1
code
case
suﬃces
taking
hence
case
instead
may
max
ct−1
αrjcj
ct−1
st−1
αrjcj
ct−i
ˆst−i+1
ˆst−i
m−1
m−2
mj=0
mj=0
mj=0
m−2
advantage
using
instead
power
smaller
ﬁeld
required
illustrate
situation
next
example
example
2.4
consider
4×4
array
3-level
code
rows
given
extended
code
according
primitive
αc1
α2c2
α2c1
used
instead
would
require
ﬁeld
size
max
smallest
ﬁeld
could
use
would
instead
next
give
main
property
t-level
codes
theorem
2.1
consider
t-level
code
given
deﬁnition
2.1
either
condition
conditions
component
codes
mds
max
holds
max
hold
correct
erasures
row
erasures
rows
array
corresponding
codeword
formally
proving
theorem
2.1
illustrate
example
example
2.5
consider
code
depicted
exam-
ple
2.3.
according
theorem
2.1
code
correct
row
erasures
two
rows
erasures
one
row
erasures
speciﬁcally
assume
array
rows
row
erasures
rows
erasures
row
erasures
since
row
ﬁrst
correct
erasures
according
reordering
rows
decreasing
number
erasures
αc1
α3c3
α2c2
α2c1
α6c3
α4c2
since
coeﬃcients
form
vandermonde
matrix
triangulate
system
since
obtain
γ1,3c3
γ1,2c2
γ2,2c2
coeﬃcients
obtained
result
triangulation
particular
since
erasures
also
γ2,2c2
erasures
since
γ2,2c2
erasures
corrected
erasures
corrected
obtained
xoring
corrected
vector
γ2,2c2
vector
γ1,3c3
γ1,2c2
erasures
corrected
obtained
xoring
corrected
vector
γ1,3c3
γ1,2c2
finally
erasures
vector
erasures
corrected
obtained
xoring
corrected
vector
proof
theorem
2.1
generalizes
procedure
also
provides
decoding
algo-
rithm
proof
theorem
2.1
prove
result
assuming
condition
proof
conditions
completely
analogous
assume
least
rows
erasures
since
row
erasures
rows
corrected
without
loss
generality
assume
rows
erasures
rows
ui−1
erasures
erasures
induction
total
number
rows
erasures
proceed
assume
ﬁrst
exactly
one
row
ut−1
erasures
particular
taking
m−1
mj=0
ct−1
ut−1
erasures
corrected
corrected
obtain
m−1
mj=0
j6=v
assume
next
partition
set
disjoint
sets
set
consists
locations
rows
erasures
set
consists
locations
rows
ui−1
erasures
erasures
example
2.5
notice
also
|si|
may
empty
rearranging
following
order
given
st−1
st−2
obtain
mv=1
mu∈st−v
let
αrucu
ct−i
ˆst−i+1
ˆst−i
particular
since
ct−1
ct−2
cw0
taking
ﬁrst
rows
obtain
min
mv=1
mu∈st−v
αrucu
cw0
let
last
element
set
sw0
set
ordered
increasing
order
example
2.5
since
matrix
coeﬃcients
αru
vandermonde
particular
triangulated
last
row
triangulation
crl
mu∈s0
γucu
cw0
coeﬃcients
obtained
consequence
triangulation
particular
crl
lu∈s0
γucu
cw0
since
linear
combination
elements
cw0
since
crl
figure
allocation
data
parity
code
erasures
uw0−1
erasures
corrected
erasures
corrected
crl
obtained
xoring
corrected
uw0
also
crl
lu∈s0
γucu
vector
lu∈s0
γucu
leaves
rows
erasures
result
follows
induction
case
general
erasure
decoding
encoding
special
case
decoding
example
t-level
code
code
given
deﬁnition
2.1
may
dedicate
parity
last
symbols
ﬁrst
rows
last
symbols
following
rows
last
ut−1
symbols
last
st−1
rows
example
2.5
take
allocation
data
parity
would
depicted
figure
also
gives
dimension
code
corollary
2.1
consider
t-level
code
theorem
2.1.
−pm−1
i=0
siui
code
following
result
given
without
proof
corollary
2.2
consider
t-level
code
theorem
2.1.
ˆst
j=i
minimum
distance
given
ˆsi
min
ˆsi+1
proof
consider
array
ˆsi+1
rows
erasures
one
row
erasures
entries
zero
means
row
ut−1
erasures
entries
zero
theorem
2.1
array
would
corrected
code
zero
codeword
thus
min
ˆsi+1
order
show
equality
need
prove
satisﬁes
ˆsw+1
min
ˆsi+1
codeword
weight
ˆsw+1
proceed
as-
suming
condition
proof
conditions
completely
analogous
let
codeword
weight
let
codeword
weight
ˆsw+1
ˆsw+1
ˆsw+1
code
whose
parity-check
matrix
given

...
...
αˆsw+1−1
ˆsw+1−1
...
αˆsw+1
α2ˆsw+1
ˆsw+1−1
ˆsw+1
...

explicitly
let
vˆsw+1
particular
ˆsw+1
mj=0
αrjvj
ˆsw+1
consider
array
weight
ˆsw+1
whose
rows
vˆsw+1
m−ˆsw+1−1
0n
denotes
zero
vector
length
show
array
according
show
ˆsw+1
mj=0
αrj
ct−i
ˆst−i+1
ˆst−i
assume
ﬁrst
since
ct−i
particular
ct−i
hence
j=0
αrj
t−i
follows
assume
next
ˆsw+1
ˆst−i
ˆst−i
lˆsw+1
ˆsw+1
mj=0
αrj
ˆsw+1
mj=0
since
ct−i
follows
also
case
αrjvj
example
2.6
consider
code
examples
2.3
2.5.
corollary
2.2
states
minimum
distance
given
min
case
depicted
figure
min
consider
next
2-level
code
according
corollary
2.2
since
minimum
distance
given
min
notice
code
local
parities
per
row
−u0
global
parities
thus
according
bound
therefore
achieves
bound
i.e.
code
optimal
lrc
code
2u0
let
state
observation
corollary
result
also
given
corollary
2.3
consider
2-level
code
given
2u0
optimal
lrc
code
corollary
2.3
interpreted
given
parameters
exists
optimal
lrc
code
ﬁeld
size
max
general
constructions
optimal
lrc
codes
require
ﬁeld
size
implementation
performance
consider
t-level
code
given
deﬁnition
2.1.
proof
theorem
2.1
provides
decoding
algorithm
erasures
within
correcting
capability
code
stated
theorem
2.1
ﬁrst
step
involves
correcting
rows
erasures
second
step
involves
triangulation
row
erasures
corrected
triangulation
done
since
row
corrected
assuming
triangulated
matrix
rows
proceed
ﬁrst
rows
triangulated
matrix
repeat
process
implementation
details
see
decoding
algorithm
tailored
erasures
adapted
errors
well
decoding
algorithms
correcting
errors
using
codes
see
convenient
implementation
codes
may
done
using
ring
polynomials
modulo
xp−1
prime
min
instead
ﬁeld
ring
allows
using
symbols
large
size
avoiding
look-up
tables
multiplications
powers
basically
rotations
individual
mds
codes
may
instance
blaum-roth
codes
extended
evenodd
codes
reasons
space
omit
details
next
establish
performance
comparisons
t-level
codes
types
lrc
codes
optimal
lrc
pmds
codes
given
array
stated
main
advantage
codes
size
ﬁeld
required
much
smaller
eﬀect
optimal
lrc
codes
size
ﬁeld
general
codes
max
argue
next
parameters
carefully
chosen
performance
codes
competitive
one
optimal
lrc
codes
optimal
lrc
codes
general
better
minimum
distance
codes
exception
given
codes
satisfying
conditions
corollary
2.3.
however
minimum
distance
although
still
important
parameter
always
important
one
reﬂecting
performance
code
see
two
ways
firstly
assume
probability
single
erasure
probability
data
loss
usually
dominated
ﬁrst
term
weight
distribution
i.e.
number
codewords
weight
however
say
number
codewords
weight
much
larger
number
codewords
weight
probability
small
example
failure
rate
ssds
reported
1.5
year
.015
second
term
probability
data
loss
may
larger
ﬁrst
let
illustrate
situation
concrete
case
consider
two
lrc
codes
one
optimal
lrc
code
bound
minimum
distance
second
one
3-level
code
m−2
corollary
2.2
minimum
distance
com-
pute
probability
data
loss
erasures
study
parameters
one
probability
larger
one
consider
ﬁrst
patterns
erasures
corrected
optimal
lrc
code
since
later
minimum
distance
theorem
2.1
occur
least
erasures
occurred
row
exactly
two
erasures
another
row
exactly
three
erasures
remaining
erasures
one
row
hard
see
probability
occurring
m−2
100p
.73
.34
.67
.31
.52
.24
.12
table
parameters
giving
polrc
pii
lrc
codes
polrc
cid:18
cid:19
cid:18
cid:19
mn−5
m−2
xi=0
cid:18
cid:19
cid:18
cid:19
similarly
cases
corrected
optimal
lrc
code
m−2
occur
one
row
exactly
erasures
remaining
rows
erasures
one
erasure
probability
occurring
pii
cid:18
cid:19
mn−4
consider
quotient
m−1
xi=0
cid:18
cid:19
cid:18
cid:19
polrc/pii
cid:18
cid:19
pm−2
i=0
cid:0
m−2
cid:19
cid:18
i=0
cid:0
m−1
pm−1
1−p
cid:1
1−p
cid:1
cid:1
cid:0
cid:1
cid:0
whenever
polrc/pii
optimal
lrc
code
higher
probability
data
loss
3-level
code
table
gives
values
diﬀerent
parameters
quotient
close
values
lrc
codes
roughly
probability
data
loss
value
given
table
optimal
lrc
code
probability
data
loss
m−2
3-level
code
percentage
failure
rate
table
m−2
probability
multiplied
100
given
ssds
used
assume
annual
failure
rate
around
1.5
suggested
m−2
cases
table
3-level
code
performance
superior
next
analyze
another
parameter
performance
lrc
code
average
number
erasures
cause
uncorrectable
pattern
hence
data
loss
denote
avfail
parameter
closely
related
mean
time
data
loss
mttdl
parameter
explore
connection
argue
avfail
may
important
minimum
distance
applications
eﬀect
assume
erasures
occur
random
array
model
may
correspond
system
storage
devices
failures
tracked
idea
allow
failures
long
possible
requesting
maintenance
example
maintenance
may
requested
system
two
failures
away
uncorrectable
pattern
would
cause
data
loss
calling
maintenance
one
failure
away
data
loss
may
risky
since
maintenance
expensive
desirable
delay
much
possible
let
point
similar
models
considered
computer
memories
protected
single
errors
references
also
explore
connection
avfail
mttdl
next
simple
example
illustrates
concept
average
number
erasures
causing
uncorrectable
pattern
example
3.1
consider
lrc
code
array
one
local
parity
per
row
global
parities
corresponds
raid
scheme
data
loss
two
erasures
row
occurred
average
number
erasures
data
loss
one
way
running
montecarlo
simulation
averaging
large
number
trials
proceed
like
ﬁnd
example
365
avfail
24.6.
reader
may
recognize
number
birthday
surprise
number
assuming
people
start
arriving
random
many
people
arrive
average
two
share
birthday
exact
formulae
compute
birthday
surprise
number
example
planet
days
birthday
surprise
number
equivalent
problem
lrc
code
given
avfail
e−mx
possible
obtain
formulae
like
one
complicated
cases
beyond
scope
paper
case
montecarlo
simulations
give
good
approxima-
tions
parameters
80,61
code
80,61
mds
16,5
1,3
pmds
optimal
16,5
1,3
lrc
dmin
avfail
12.7
10.8
80,60
3-level
80,60
mds
16,5
1,4
pmds
optimal
16,5
1,4
lrc
80,59
3-level
80,59
mds
16,5
1,5
pmds
optimal
16,5
1,5
lrc
80,58
3-level
80,58
mds
16,5
1,6
pmds
optimal
16,5
1,6
lrc
80,57
80,56
3-level
80,57
mds
16,5
1,7
pmds
optimal
16,5
1,7
lrc
3-level
80,56
mds
16,5
1,8
pmds
optimal
16,5
1,8
lrc
4-level
11.6
14.5
13.5
16.2
17.7
19.2
17.1
20.6
18.5
table
codes
corresponding
arrays
parameters
128,92
code
128,92
mds
16,8
2,4
pmds
optimal
16,8
2,4
lrc
dmin
avfail
25.1
20.4
128,91
3-level
128,91
mds
16,8
2,5
pmds
optimal
16,8
2,5
lrc
128,90
128,89
128,84
3-level
128,90
mds
16,8
2,6
pmds
optimal
16,8
2,6
lrc
3-level
128,89
mds
16,8
2,7
pmds
optimal
16,8
2,7
lrc
4-level
128,84
mds
16,8
2,12
pmds
optimal
16,8
2,12
lrc
5-level
23.8
27.8
21.8
29.1
24.9
26.3
30.1
25.7
27.5
38.8
32.2
34.7
table
codes
corresponding
arrays
notice
code
mds
minimum
distance
avfail
completely
correlated
fact
data
loss
mds
code
occurs
time
erasures
thus
avfail
property
lost
lrc
codes
show
next
many
cases
lrc
codes
better
minimum
distance
others
however
worse
avfail
consider
general
lrc
codes
terms
avfail
best
pmds
code
since
correct
possible
patterns
locality
number
global
parities
restrictions
avfail
pmds
code
provides
upper
bound
next
consider
t-level
codes
lrc
codes
two
diﬀerent
codes
type
may
minimum
distance
one
may
better
avfail
one
shown
next
example
providing
good
illustration
power
theorem
2.1
corollary
2.2.
example
3.2
consider
two
codes
arrays
rate
follows
ﬁrst
code
2-level
code
second
code
3-level
code
according
theorem
2.1
correct
row
erasures
long
remaining
rows
one
erasure
according
corollary
2.2
minimum
distance
code
similarly
correct
one
row
two
erasures
one
row
three
erasures
one
erasure
remaining
rows
minimum
distance
also
corollary
2.2.
however
simulation
avfail
5.67
avfail
6.96
second
one
preferable
similarly
consider
optimal
lrc
code
respect
arrays
hence
rate
two
codes
according
bound
minimum
distance
code
better
codes
simulation
avfail
6.4
thus
optimal
lrc
code
better
avfail
slightly
worse
instance
optimal
lrc
code
requires
ﬁeld
size
least
codes
require
ﬁeld
size
least
took
pmds
code
parameters
codes
verify
avfail
7.4.
mds
code
length
dimension
minimum
distance
avfail
locality
lost
situations
complex
ones
described
example
3.2
depicted
tables
table
compares
diﬀerent
lrc
codes
consisting
arrays
number
global
parities
satisfying
value
compute
avfail
pmds
code
optimal
lrc
code
code
given
specially
selected
vector
also
write
value
avfail
mds
code
length
dimension
seen
case
avfail
coincides
minimum
distance
code
table
thing
arrays
number
global
parities
see
cases
could
ﬁnd
code
larger
avfail
corresponding
optimal
lrc
code
moreover
codes
tables
may
implemented
ﬁeld
optimal
lrc
codes
require
least
ﬁeld
128
conclusions
presented
method
implementing
integrated
interleaved
codes
locally
re-
coverable
codes
proved
fundamental
properties
codes
compared
performance
one
optimal
lrc
codes
main
advantage
codes
ﬁelds
required
construction
much
smaller
optimal
lrc
codes
certainly
minimum
distance
code
smaller
minimum
distance
optimal
lrc
code
general
exceptions
described
paper
however
consider
average
number
erasures
lrc
code
tolerate
codes
frequently
outperform
optimal
lrc
codes
pmds
codes
maximize
average
number
erasures
lrc
code
tolerate
construction
using
relatively
small
ﬁelds
open
problem
making
codes
lrc
codes
attractive
alternative
references
abdel-ghaﬀar
hassner
multilevel
codes
data
storage
channels
ieee
trans
information
theory
vol
it-37
735–41
may
1991
blaum
goodman
mceliece
reliability
single-error
protected
computer
memories
ieee
trans
computers
vol
c-37
114–19
january
1988
blaum
locally
recoverable
lrc
codes
arxiv:1512.06161
december
2015
blaum
brady
bruck
menon
vardy
evenodd
code
generalization
high
performance
mass
storage
parallel
i/o
technologies
applications
edited
jin
cortes
buyya
ieee
wiley
press
new
york
chapter
187–208
2001
blaum
hafner
hetzler
partial-mds
codes
application
raid
type
architectures
ieee
trans
information
theory
vol
it-59
4510-
july
2013
blaum
hetzler
generalized
concatenated
types
codes
erasure
correction
arxiv:1406.6270v2
july
2014
blaum
plank
schwartz
yaakobi
partial
mds
pmds
sector-
disk
codes
tolerate
erasure
two
random
sectors
isit
2014
ieee
international
symposium
information
theory
1792–96
july
2014
blaum
roth
new
array
codes
multiple
phased
burst
correction
ieee
trans
information
theory
vol
it-39
66-77
january
1993
blokh
zyablov
coding
generalized
concatenated
codes
problemy
peredachii
informatsii
vol
218–222
1974
cadambe
mazumdar
upper
bound
size
locally
recoverable
codes
international
symposium
network
coding
netcod
1–5
june
2013
also
arxiv:308.13200v2
march
2015
campello
wilson
generalized
concatenated
scheme
ecc
symbols
unpublished
presentation
2003
dumer
concatenated
codes
multilevel
generalizations
handbook
coding
theory
edited
pless
huﬀman
elsevier
science
chapter
1998
gibson
redundant
disk
arrays
mit
press
1992
goodman
mceliece
lifetime
analyses
error-control
coded
semi-
conductor
ram
systems
proc
iee
part
vol
81–85
1982
goodman
mceliece
hamming
codes
computer
memories
birthday
surprise
proc
20th
allerton
conf
commun.
control
comput.
672–79
1982
gopalan
huang
jenkins
yekhanin
explicit
maximally
recoverable
codes
locality
ieee
trans
information
theory
vol
it-60
5245–56
september
2014
gopalan
huang
simitci
yekhanin
locality
codeword
symbols
ieee
trans
information
theory
vol
it-58
6925–34
november
2012
han
lastras-monta˜no
reliable
memories
subline
accesses
isit
2007
ieee
international
symposium
information
theory
2531–35
june
2007
hassner
abdel-ghaﬀar
patel
koetter
trager
integrated
inter-
leaving
novel
ecc
architecture
ieee
transactions
magnetics
vol
773–5
march
2001
huang
chen
pyramid
codes
flexible
schemes
trade
space
access
eﬃciency
reliable
data
storage
systems
acm
transactions
storage
vol
article
march
2013
huang
simitci
ogus
calder
gopalan
yekhanin
erasure
coding
windows
azure
storage
2012
usenix
annual
technical
confer-
ence
boston
massachussetts
june
2012
klamkin
newman
extensions
birthday
surprise
combin
theory
279–82
1967
kuijper
napp
erasure
codes
simplex
locality
arxiv:1403.2779
march
2014
lee
stair
codes
general
family
erasure
codes
tolerating
device
sector
failures
practical
storage
systems
12th
usenix
conference
file
storage
technologies
fast
santa
clara
february
2014
macwilliams
sloane
theory
error-correcting
codes
north
holland
amsterdam
1977
mearian
ssds
die
linus
torvalds
discovered
http
//www.computerworld.com/article/2484998/solid-state-drives/ssds-do-die—as-linus-torvalds-just-discovered.html
micron
tn-29-17
nand
flash
design
use
considerations
introduction
micron
technology
inc.
2006
papailiopoulos
dimakis
locally
repairable
codes
ieee
trans
information
theory
vol
it-60
5843-55
october
2014
patel
two-level
coding
error-control
magnetic
disk
storage
products
ibm
journal
research
development
vol
470–84
1989
plank
blaum
sector-disk
erasure
codes
mixed
failure
modes
raid
systems
acm
transactions
storage
vol
article
january
2014
plank
blaum
hafner
codes
erasure
codes
designed
storage
systems
really
fail
11th
usenix
conference
file
storage
technolo-
gies
fast
santa
clara
february
2013
prakash
kamath
lalitha
kumar
optimal
linear
codes
local-error-correction
property
isit
2012
ieee
international
symposium
infor-
mation
theory
2776–80
july
2012
arxiv:1202.2414
february
2012
rawat
koyluoglu
silberstein
vishwanath
optimal
locally
repairable
secure
codes
distributed
storage
systems
ieee
trans
infor-
mation
theory
vol
it-60
212-36
january
2014
sathiamoorthy
asteris
papailiopoulos
dimakis
vadali
chen
borthakur
xoring
elephants
novel
erasure
codes
big
data
proceedings
vldb
vol
325–336
august
2013
song
dau
yuen
optimal
locally
repairable
linear
codes
ieee
journal
selected
areas
communications
vol
1019–36
may
2014
tamo
barg
family
optimal
locally
recoverable
codes
ieee
trans
information
theory
vol
it-60
4661–76
august
2014
tamo
wang
bruck
zigzag
codes
mds
array
codes
optimal
rebuilding
ieee
trans
information
theory
vol
it-59
1597–616
march
2013
tang
koetter
novel
method
combining
algebraic
decoding
it-
erative
processing
isit
2006
ieee
international
symposium
information
theory
474–78
july
2006
wang
zhang
repair
locality
multiple
erasure
tolerance
ieee
trans
information
theory
vol
it-60
6979–87
november
2014
generalized
integrated
interleaving
codes
submitted
publication
2015
zeh
yaakobi
bounds
constructions
codes
multiple
localities
arxiv:1601.02763
january
2016
zinoviev
generalized
cascade
codes
probl
pered
inform.
vol
5-15
1976
