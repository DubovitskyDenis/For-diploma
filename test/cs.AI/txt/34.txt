consideration
publication
theory
practice
logic
programming
d-flat
declarative
problem
solving
using
tree
decompositions
answer-set
programming
bernhard
bliem
michael
morak
stefan
woltran
institute
information
systems
184/2
vienna
university
technology
favoritenstrasse
9–11
1040
vienna
austria
e-mail
surname
dbai.tuwien.ac.at
abstract
work
propose
answer-set
programming
asp
tool
rapid
prototyping
dynamic
programming
algorithms
based
tree
decompositions
fact
many
algorithms
designed
found
way
implementation
main
obstacle
lack
easy-to-use
systems
take
care
building
tree
decomposition
provide
interface
declarative
speciﬁcations
dynamic
programming
algorithms
paper
present
d-flat
novel
tool
relieves
user
handle
technical
details
concerned
parsing
tree
decomposition
handling
data
structures
etc
instead
dynamic
programming
algorithm
speciﬁed
asp
language
d-flat
employs
asp
solver
order
compute
local
solutions
dynamic
programming
algorithm
paper
give
examples
illustrating
use
d-flat
describe
main
features
system
moreover
report
experiments
show
asp-based
d-flat
encodings
problems
outperform
monolithic
asp
encodings
instances
small
treewidth
appear
theory
practice
logic
programming
tplp
introduction
computationally
hard
problems
found
almost
every
area
computer
science
hence
quest
general
tools
methods
help
designing
solutions
prob-
lems
one
central
research
challenges
ﬁeld
one
particularly
successful
approach
answer-set
programming
niemel¨a
1999
marek
truszczy´nski
1999
brewka
2011
—asp
short—where
highly
sophisticated
solvers
leone
2006
gebser
2011
provide
rich
declarative
language
specify
given
problem
intuitive
succinct
manner
hand
concept
dynamic
program-
ming
larson
1967
wagner
1995
denotes
general
recursive
strategy
optimal
solution
problem
deﬁned
terms
optimal
solutions
subproblems
thus
constructing
solution
bottom-up
simpler
complex
problems
one
particular
application
dynamic
programming
design
algorithms
proceed
along
tree
decompositions
robertson
seymour
1984
problem
hand
rather
graph
representation
signiﬁcance
approach
highlighted
courcelle
seminal
result
see
e.g.
courcelle
1990
states
every
problem
de-
ﬁnable
monadic
second-order
logic
solved
linear
time
structures
bounded
treewidth
formal
deﬁnitions
concepts
provided
section
2.2.
sug-
gests
two-phased
methodology
problem
solving
ﬁrst
tree
decomposition
bliem
morak
woltran
given
problem
instance
obtained
subsequently
used
second
phase
solve
problem
speciﬁcally
designed
algorithm
usually
employing
dynamic
programming
traversing
tree
decomposition
see
e.g.
bodlaender
koster
2008
overview
approach
tree
decomposition
based
algorithms
successful
sev-
eral
applications
including
constraint
satisfaction
problems
max-sat
koster
2002
also
bio-informatics
2005
cai
2008
good
heuristics
obtain
tree
decompositions
exist
dermaku
2008
bod-
laender
koster
2010
implementations
thereof
available
actual
implemen-
tation
dynamic
programming
algorithms
work
tree
decompositions
yet
often
done
scratch
paper
present
new
method
declaratively
specifying
dynamic
programming
part
namely
means
asp
programs
men-
tioned
dynamic
programming
relies
evaluation
subproblems
often
combinatorial
nature
thanks
guess
check
principle
asp
paradigm
using
asp
describe
treatment
subproblems
thus
natural
choice
also
separates
approach
existing
systems
discuss
conclu-
sion
section
paper
using
asp
language
order
describe
constituent
elements
dynamic
programming
algorithm
obviously
suggests
also
employ
sophis-
ticated
off-the-shelf
asp
systems
internal
machinery
evaluating
speciﬁed
al-
gorithm
thus
approach
takes
full
advantage
rich
syntax
asp
offers
describe
dynamic
programming
algorithm
also
delegates
burden
local
computations
highly
efﬁcient
asp
systems
implemented
approach
novel
system
d-flat1
takes
care
computation
tree
decompositions
also
handles
bottom-up
data
ﬂow
dynamic
programming
algorithm.2
required
users
idea
al-
gorithm
hence
d-flat
serves
tool
rapid
prototyping
dynamic
programming
algorithms
also
considered
educational
purposes
well
asp
users
provided
easy-to-use
interface
decompose
problem
instances—an
issue
might
allow
large
instances
practical
importance
solved
far
could
handled
asp
systems
summarize
d-flat
provides
new
method
problem
solving
combining
advantages
asp
tree
decomposition
based
dynamic
pro-
gramming
attempts
ease
speciﬁcation
dynamic
programming
algorithms
already
exist
see
section
aware
system
employs
asp
dynamic
programming
tree
decompositions
structure
paper
follows
section
ﬁrst
brieﬂy
recall
logic
pro-
gramming
answer-set
semantics
provide
necessary
background
hy-
per
tree
decompositions
dynamic
programming
section
introduce
fea-
tures
d-flat
step-by-step
providing
asp
speciﬁcations
several
standard
also
novel
dynamic
programming
algorithms
section
4.1
gives
system
speciﬁcs
section
4.2
reports
preliminary
experimental
evaluation
conclusion
paper
address
related
work
give
brief
summary
outlook
ynamic
programming
ramework
ocal
execution
ree
decompositions
available
http
//www.dbai.tuwien.ac.at/research/project/dynasp/dflat/
concerning
decomposition
employ
htdecomp
library
dermaku
2008
making
system
amenable
hypertree
decompositions
well
fact
allows
decompose
arbitrary
ﬁnite
structures
thus
extending
range
applicability
system
d-flat
declarative
problem
solving
using
tree
decompositions
asp
preliminaries
2.1
logic
programs
answer-set
semantics
proposed
system
d-flat
uses
asp
specify
dynamic
programming
algorithm
section
therefore
brieﬂy
introduce
syntax
semantics
asp
reader
referred
brewka
2011
thorough
introduction
logic
program
consists
set
rules
form
···
bm+1
call
atoms
literal
either
atom
default
negation
obtained
putting
front
rule
call
head
body
divided
positive
body
negative
body
bm+1
note
head
may
empty
case
call
integrity
constraint
body
empty
called
fact
symbol
omitted
rule
satisﬁed
set
atoms
called
interpretation
iff
cid:54
cid:54
cid:54
model
set
rules
iff
satisﬁes
rule
answer
set
program
iff
subset-minimal
model
program
called
gelfond-lifschitz
reduct
gelfond
lifschitz
1991
w.r.t
paper
use
input
language
gringo
gebser
2010
logic
pro-
grams
atoms
language
predicates
whose
arguments
either
variables
ground
terms
programs
seen
abbreviations
variable-free
programs
variables
instantiated
i.e.
replaced
ground
terms
process
instantiation
also
called
grounding
results
propositional
program
represented
set
rules
adhere
deﬁnition
example
instance
3-col
problem3
covered
section
3.1
consists
set
vertices
set
edges
following
set
facts
represents
valid
instance
vertex
vertex
vertex
vertex
vertex
edge
edge
edge
edge
edge
edge
following
logic
program
solves
3-col
instances
form
color
red
green
blue
map
color
vertex
edge
map
map
solving
3-col
instance
amounts
grounding
encoding
together
in-
stance
input
solving
resulting
ground
program
line
encoding
expanded
grounder
three
facts
state
red
green
blue
colors
line
contains
cardinality
constraint
head
conceptually
expanded
map
red
map
green
map
blue
vertex
grounder
expands
rule
substituting
ground
terms
roughly
speak-
ing
cardinality
constraint
satisﬁed
interpretation
iff
least
literals
true
therefore
rule
question
3-col
deﬁned
problem
deciding
whether
given
graph
exists
3-coloring
i.e.
mapping
red
green
blue
s.t
edge
holds
cid:54
bliem
morak
woltran
figure
graph
corresponding
semi-normalized
tree
decomposition
expresses
choice
exactly
one
map
red
map
green
map
blue
vertex
finally
integrity
constraint
line
encoding
ensures
answer
set
maps
color
adjacent
vertices
space
reasons
refer
reader
gebser
2010
details
input
language
2.2
hypertree
decompositions
tree
decompositions
treewidth
originally
deﬁned
robertson
seymour
1984
well
known
tool
tackle
computationally
hard
problems
see
e.g.
bodlaender
1993
bodlaender
2005
overview
informally
treewidth
measure
cyclic-
ity
graph
many
np-hard
problems
become
tractable
treewidth
bounded
intuition
behind
tree
decompositions
obtaining
tree
potentially
cyclic
graph
subsuming
multiple
vertices
one
node
thereby
isolating
parts
re-
sponsible
cyclicity
several
problems
better
represented
hypergraphs
concept
tree
decomposition
generalized
see
e.g.
gottlob
2002
following
therefore
deﬁne
hypertree
decompositions
tree
decompositions
special
case
hypergraph
pair
set
vertices
set
hyperedges
hyperedge
set
vertices
hypertree
decomposition
hypergraph
pair
cid:104
cid:105
rooted
tree
set
nodes
set
edges
labeling
function
node
so-called
bags
meet
following
requirements
every
exists
node
every
exists
node
every
set
induces
connected
subtree
hypertree
decomposition
cid:104
cid:105
called
semi-normalized
node
two
children—nodes
zero
resp
one
two
children
called
leaf
resp
ex-
change
join
nodes—and
join
node
children
holds.4
figure
depicts
semi-normalized
tree
decomposition
example
graph
given
problem
instance
section
2.1.
deﬁning
width
hypertree
decomposition
cid:104
cid:105
hypergraph
need
additional
labeling
function
every
terminological
remarks
reason
use
term
semi-normalized
restrictive
concept
normalized
also
called
nice
tree
decompositions
appears
literature
normalized
tree
decom-
positions
also
semi-normalized
moreover
hypertree
decompositions
generalize
notion
tree
decom-
positions
case
hypergraphs
therefore
often
use
terms
interchangeably
dealing
ordinary
graphs
even
though
strictly
speaking
d-flat
always
produces
hypertree
decomposition
cid:83
d-flat
declarative
problem
solving
using
tree
decompositions
asp
e∈λ
hypertree
decomposition
called
complete
hyper-
edge
exists
node
width
hypertree
decomposition
maximum
λ-set
size
nodes
minimum
width
possible
hypertree
decompositions
called
generalized
hypertree
width
idea
parameter
capture
inherent
difﬁculty
given
problem
smaller
generalized
hypertree
width
i.e.
level
cyclicity
easier
prob-
lem
solve
see
e.g.
gottlob
2002
ordinary
graph
width
tree
decomposition
cid:104
cid:105
deﬁned
differently
namely
maximum
bag
size
minus
one
given
hypergraph
np-hard
compute
hyper-
tree
decomposition
minimum
width
however
efﬁcient
heuristics
developed
offer
good
approximations
dermaku
2008
bodlaender
koster
2010
noted
general
exist
many
possible
hypertree
decompositions
given
hypergraph
always
exists
least
one
degenerated
hypertree
de-
composition
consisting
single
node
covers
entire
hypergraph
d-flat
expects
dynamic
programming
algorithms
provided
user
work
semi-
normalized
hypertree
decomposition
users
worry
currently
determine
decomposition
generated
heuristic
methods
htdecomp
library
attempt
construct
decompositions
small
width
2.3
dynamic
programming
hypertree
decompositions
value
hypertree
decompositions
size
linear
size
given
graph
moreover
provide
suitable
structure
design
dynamic
programming
algorithms
wide
range
problems
algorithms
generally
start
leaf
nodes
traverse
tree
root
whereby
node
set
partial
solutions
gener-
ated
taking
solutions
account
computed
child
nodes
difﬁcult
part
constructing
algorithm
identify
appropriate
data
structure
represent
partial
solutions
node
one
hand
data
struc-
ture
must
contain
sufﬁcient
information
compute
representation
partial
solutions
node
corresponding
representation
child
node
hand
size
data
structure
depend
size
bag
total
size
instance
solve
purpose
tree
decomposition
node
maintain
data
structure
call
table
table
contains
rows
call
tuples
i.e.
mappings
assign
value
current
bag
element
store
partial
solutions
additionally
tuple
non-leaf
nodes
may
associated
tuples
child
nodes
means
pointers
pointers
determine
child
tuples
tuple
originated
used
construct
complete
solutions
respective
partial
solutions
computation
tables
ﬁnished
illustrate
idea
3-col
problem
consider
given
graph
corre-
sponding
tree
decomposition
node
decomposition
basically
compute
valid
colorings
subgraph
induced
i.e.
current
bag
store
colorings
rows
table
associated
hence
tuple
node
decision
problem
needs
solved
pointers
necessary
general
algorithm
structure
tables
depend
problem
type
greco
scarcello
2010
gottlob
2009
bliem
morak
woltran
figure
3-col
tuple
tables
instance
tree
decomposition
given
figure
table
assigns
either
vertex
contained
current
bag
far
steps
taken
dynamic
programming
algorithm
differ
general
guess
check
approach
3-col.
however
computing
colorings
exchange
node
start
colorings
child
node
cid:48
adapt
respect
new
vertices
cid:48
addition
also
keep
track
tuples
cid:48
give
rise
newly
calculated
tuples
figure
depicts
respective
tables
node
semi-normalized
tree
decomposition
figure
table
column
contains
index
tuple
used
column
potential
parent
node
reference
exchange
nodes
entry
column
set
pointers
child
tuples
join
nodes
entry
column
set
pairs
resp
references
tuple
left
resp
right
child
node
using
pointers
possible
enumerate
complete
solutions
entire
problem
ﬁnal
top-down
traversal
note
size
tables
depends
width
tree
decomposition
number
tables
linear
size
input
graph
thus
width
bounded
constant
search
space
subproblem
remains
constant
well
number
subproblems
grows
linear
factor
larger
instances
d-flat
example
section
introduce
usage
d-flat
system
means
speciﬁc
example
problems
begin
relatively
simple
case
illustrate
basic
functionality
system
continue
complex
applications
course
gradually
introduce
features
d-flat
special
predicates
responsible
communication
d-flat
user
programs
predicates
summarized
table
future
reference
general
description
system
possible
applications
delegated
section
4.1
3.1
graph
coloring
ﬁrst
example
solve
np-complete
problem
using
d-flat
consider
col
3-colorability
problem
graphs
already
given
encoding
3-col
d-flat
declarative
problem
solving
using
tree
decompositions
asp
table
reserved
predicates
communication
user
programs
d-flat
input
predicate
meaning
current
introduced
removed
childtuple
childtuplel
childtupler
mapped
childcost
root
element
current
bag
introduced
current
bag
removed
current
bag
identiﬁer
child
tuple
exchange
nodes
tuple
left
resp
right
child
node
join
nodes
child
tuple
assigns
value
total
cost
partial
solution
corresponding
child
tuple
indicates
current
node
root
node
exchange
nodes
output
predicate
meaning
map
chosenchildtuple
chosenchildtuplel
chosenchildtupler
cost
currentcost
assign
value
current
bag
element
declare
identiﬁer
child
tuple
prede-
cessor
currently
described
one
exchange
nodes
necessary
decision
problems
declare
identiﬁers
preceding
child
tuples
left
resp
right
child
node
join
nodes
necessary
decision
problems
let
total
cost
current
partial
solution
required
solving
optimization
problem
let
local
cost
current
tuple
required
exchange
nodes
solving
optimization
problem
using
default
join
implementation
section
2.1.
since
program
together
instance
input
solves
whole
problem
call
monolithic
encoding
3-col
ﬁxed-parameter
tractable
w.r.t
treewidth
take
advantage
low
treewidths
solving
problem
dynamic
programming
algorithm
operates
tree
decomposition
original
input
graph
sketched
dynamic
programming
algorithm
3-col
section
2.3.
d-flat
provides
means
specify
dynamic
programming
algorithm
asp
language
reads
instance
stores
graph
representation
con-
structs
semi-normalized
tree
decomposition
order
d-flat
obtain
graph
rep-
resentation
instance
user
needs
specify
command
line
predicates
indicate
hyper
edges
graph
representation
case
edge/2
following
idea
dynamic
programming
wish
compute
table
tree
decomposition
node
table
computed
using
tables
child
nodes
bliem
morak
woltran
figure
workﬂow
calculating
tree
decomposition
node
table
data
ﬂow
processing
exchange
node
data
ﬂow
processing
join
node
exchange
program
instance
current
table
answer
sets
asp
solver
bag
child
tuples
child
table
join
program
instance
current
table
answer
sets
asp
solver
bag
left
tuples
right
tuples
left
table
right
table
i.e.
perform
calculations
bottom-up
manner
since
semi-normalized
tree
de-
compositions
allow
two
kinds
nodes—exchange
nodes
one
child
join
nodes
exactly
two
children
contents
join
node—
sufﬁces
provide
d-flat
asp
program
computes
table
exchange
nodes
exchange
program
short
program
computes
table
join
nodes
join
program
short
two
programs
required
user
solve
problem
d-flat
traverses
tree
decomposition
post-order
node
invokes
asp
solver
proper
program
i.e.
exchange
program
exchange
nodes
join
program
join
nodes
illustration
single
steps
given
figure
input
exchange
join
program
consists
original
problem
instance
supplied
user
tuples
child
nodes
set
facts
current
bag
i.e.
current
introduced
removed
vertices
set
facts
answer
sets
constitute
current
node
table
d-flat
takes
care
processing
ﬁlling
appropriate
data
structures
new
tuples
thus
stored
proceeds
next
node
procedure
continues
root
processed
present
exchange
program
3-col.
regarding
input
sup-
plied
d-flat
set
current
introduced
removed
vertices
given
pred-
icates
current/1
introduced/1
removed/1
respectively
child
tuple
identiﬁer
declared
fact
childtuple
corresponding
mapping
given
facts
form
mapped
signiﬁes
tu-
ple
vertex
assigned
color
predicate
name
mapped
chosen
analogy
present
tense
term
map
fact
d-flat
produces
tree
decompositions
leaves
well
root
node
empty
bag
empty
leaf
nodes
advantage
involve
problem-speciﬁc
computation
least
use
cases
considered
far
deliver
empty
tuple
cost
parent
node
default
behavior
mirrored
d-flat
sense
currently
supports
user-speciﬁed
asp
programs
exchange
join
nodes
hand
empty
root
node
guarantees
ﬁnal
actions
dynamic
programming
algorithm
always
speciﬁed
program
exchange
nodes
d-flat
declarative
problem
solving
using
tree
decompositions
asp
color
red
green
blue
chosenchildtuple
childtuple
map
chosenchildtuple
mapped
current
map
color
introduced
edge
map
map
program
based
intuition
exchange
node
child
tuple
gives
rise
set
new
tuples
new
tuples
coincide
coloring
common
vertices
line
coloring
introduced
vertices
guessed
line
followed
check
line
uses
edge/2
predicate
problem
instance
answer
set
constitutes
exactly
one
new
tuple
current
node
table
output
predicate
map/2
used
specify
partial
coloring
new
tuple
like
used
monolithic
encoding
must
assign
color
vertex
current
node
another
output
predicate
recognized
d-flat
chosenchildtuple/1
indicates
child
tuple
partial
coloring
characterized
answer
set
corresponds
must
course
one
child
tuple
identiﬁer
extension
predicate
required
reconstruction
complete
solutions
tables
computed
therefore
omitted
decision
problem
solved
still
remains
provide
d-flat
program
processing
kind
nodes
viz.
join
nodes
join
program
purpose
could
look
like
chosenchildtuplel
childtuplel
chosenchildtupler
childtupler
chosenchildtuplel
chosenchildtupler
mapped
mapped
join
equal
tuples
map
chosenchildtuplel
mapped
answer
set
obviously
must
state
two
child
nodes
chosen
pre-
ceding
tuple
indicated
chosenchildtuplel
chosenchildtupler
case
3-col
two
tuples
match
i.e.
joined
new
tuple
iff
partial
assign-
ments
coincide
line
tuple
resulting
join
also
equal
two
matching
child
tuples
line
particular
join
behavior
basic
also
applies
common
problems
therefore
d-flat
offers
quite
efﬁcient
default
implementation
behavior
users
resort
sufﬁces
instead
writing
join
programs
would
like
point
difference
role
exchange
join
nodes
particular
one
might
wonder
join
nodes
default
implementa-
tion
often
used
whereas
none
exchange
nodes
difference
due
idea
dynamic
programming
one
hand
involves
solving
partial
problems
hand
requires
combining
partial
solutions
clearly
separated
thanks
concept
semi-normalized
tree
decompositions
obviously
combining
explicitly
done
join
nodes
whereas
usually
solving
partial
problems
performed
exchange
nodes
therefore
require
problem-speciﬁc
code
exchange
nodes
always
require
problem-speciﬁc
code
since
entire
problem
seen
sin-
gle
degenerated
exchange
node
hence
parts
exchange
programs
resemble
monolithic
encodings
much
even
though
technically
irrelevant
d-flat
indeed
ex-
change
programs
seen
general
monolithic
encodings
since
correct
exchange
program
must
principle
also
solve
entire
problem
cases
however
knowledge
problem
also
needed
join
nodes
next
subsection
show
bliem
morak
woltran
3.2
boolean
satisﬁability
instances
satisﬁability
problem
sat
given
predicates
pos
neg
denoting
propositional
variable
occurs
positively
resp
negatively
clause
clause
variable
declared
using
predicates
clause/1
atom/1
respectively
following
monolithic
encoding
solves
instances
map
true
map
false
atom
sat
pos
map
true
sat
neg
map
false
clause
sat
obtain
graph
representation
sat
instance
constructing
incidence
graph
i.e
graph
obtained
considering
clauses
variables
vertices
connect-
ing
clause
vertex
variable
vertex
edge
iff
respective
variable
occurs
respective
clause
order
d-flat
transform
input
graph
representation
user
required
state
pos/2
neg/2
indicate
edges
dynamic
programming
algorithm
model
counting
problem
working
tree
decompositions
incidence
graph
given
samer
szeider
2010
present
possible
asp
encoding
exchange
node
follows
work
general
idea
algorithm
generalizes
semi-normalized
tree
decompositions
noted
primarily
assign
truth
values
current
propositional
atoms
like
monolithic
encoding
consequence
also
assign
true
false
current
clause
depending
whether
satisﬁed
partial
interpretation
represented
tuple
need
information
status
clause
clause
removed
tuples
satisfying
clause
must
eliminated
chosenchildtuple
childtuple
clause
removed
chosenchildtuple
mapped
true
map
true
chosenchildtuple
mapped
true
current
map
true
map
false
atom
introduced
map
true
pos
current
map
true
map
true
neg
current
map
false
map
false
current
map
true
mentioned
elimination
non-satisfying
truth
assignments
performed
check
line
child
tuple
partial
interpretation
retained
lines
extended
guess
introduced
atoms
line
clause
satisﬁed
point
remains
due
line
whereas
lines
mark
clauses
satisﬁed
current
partial
assignment
sat
problem
use
d-flat
default
implementation
join
nodes
reason
order
joined
two
tuples
need
coincide
values
assign
clauses
assignments
atoms
given
truth
assign-
ment
current
atoms
clause
satisﬁed
either
child
tuple
also
satisﬁed
tuple
resulting
joining
two
following
join
program
follows
idea
chosenchildtuplel
childtuplel
chosenchildtupler
childtupler
mapped
true
mapped
false
atom
chosenchildtuplel
chosenchildtupler
mapped
false
mapped
true
atom
chosenchildtuplel
chosenchildtupler
map
true
chosenchildtuplel
mapped
true
map
true
chosenchildtupler
mapped
true
map
false
current
map
true
d-flat
declarative
problem
solving
using
tree
decompositions
asp
3.3
minimum
vertex
cover
encodings
outlined
sufﬁce
instruct
d-flat
solve
respective
enumeration
problems
solutions
counting
problems
many
solutions
exist
decision
problems
solution
often
also
desired
solve
optimization
problems
additional
information
regarding
cost
partial
solution
must
supplied
encodings
example
brieﬂy
introduce
drosophila
ﬁxed-parameter
algorithms
minimum
vertex
cover
problem
solved
instances
given
vertex/1
edge/2
begin
mono-
lithic
encoding
comparison
map
map
vertex
edge
map
map
cost
count
map
minimize
cost
means
minimize
statement
leave
asp
solver
ﬁlter
subopti-
mal
solutions
however
mistake
use
optimization
statement
writing
exchange
program
d-flat
one
would
ﬁlter
tuples
whose
local
cost
might
exceed
others
end
would
yield
better
global
solution
exchange
program
minimum
vertex
cover
could
look
like
chosenchildtuple
childtuple
map
current
chosenchildtuple
mapped
introduced
map
map
edge
map
map
currentcost
count
map
cost
chosenchildtuple
childcost
count
cost/1
predicate
recognized
d-flat
speciﬁes
cost
partial
so-
lution
obtained
extending
current
tuple
predecessors
recursively
number
computed
line
adding
preceding
tuple
cost
provided
d-flat
childcost/2
cost
due
introduced
vertices—in
case
number
vertices
guessed
peculiarity
using
default
join
implementation
example
tuple
need
store
cost
corresponding
partial
solution
also
cost
tuple
declared
currentcost/1
upon
joining
two
coinciding
tuples
adding
total
costs
associated
partial
solutions
portion
cost
due
coinciding
child
tuples
counted
twice
must
thus
subtracted
sum
d-flat
also
recognizes
currentcost/1
predicate
implementing
join
program
manually
predicate
useless
calculating
cost
tuple
resulting
join
user
note
soon
root
tree
decomposition
processed
d-flat
possesses
information
required
determining
cost
number
optimal
solutions
constant
time
i.e.
without
additional
tree
traversal
well
enumer-
ating
optimal
solutions
linear
delay
traversing
tree
top-down
following
tuple
pointers
predecessors
construct
solutions
processing
optimiza-
tion
problem
instance
different
problems
without
optimization
except
partial
solution
costs
must
speciﬁed
tuple
bliem
morak
woltran
3.4
cyclic
ordering
always
used
graph
representation
problem
instance
problems
however
represented
naturally
hypergraph
example
cyclic
ordering
problem
takes
instance
set
described
predi-
cate
vertex/1
set
triples
described
order
declared
vertices
called
ordering
vertices
triple
order
said
satisﬁed
ordering
iff
objective
bring
vertices
ordering
triples
satisﬁed
following
monolithic
encoding
achieves
map
v,1..n
vertex
count
vertex
map
map
map
map
sat
order
sat
order
sat
order
order
sat
one
naturally
represent
problem
hypergraph
one
considers
elements
vertices
triples
hyperedges
ensures
vertices
triple
must
appear
together
least
one
bag
triple
therefore
checked
exchange
node
use
opportunity
introduce
distinction
two
ways
write
exchange
encodings
either
cases
bottom-
way
i.e.
selecting
preceding
child
tuples
constructing
new
tuples
originating
dealing
decision
problem
another
possibility
proceed
top-down
i.e.
guessing
ﬁrst
assignment
values
current
vertices
checking
child
tuple
exists
valid
predecessor
guess
advantage
avoid
guess
potentially
huge
number
child
tuples
probably
many
resulting
tuples
would
coincide
following
exchange
encoding
cyclic
ordering
proceeds
top-down
map
v,1..n
current
count
current
map
map
map
map
sat
order
sat
order
sat
order
order
current
sat
gtchild
mapped
mapped
current
nomatch
gtchild
match
childtuple
nomatch
match
ﬁrst
seven
lines
similar
monolithic
encoding
remainder
program
makes
sure
valid
predecessor
among
child
tuples
note
approach
employed
decision
problems
counting
enumerating
solutions
require
pointers
child
tuples
fact
problem
differs
previously
discussed
insofar
set
values
mapped
vertex
ﬁxed
e.g.
three
colors
truth
value
whereas
would
required
assign
vertex
number
total
number
vertices
monolithic
d-flat
declarative
problem
solving
using
tree
decompositions
asp
program
one
really
construct
solution
problem
approach
would
violate
principles
dynamic
programming
subproblems
would
depend
whole
problem
however
note
line
local
ordering
i.e.
ordering
current
bag
elements
guessed
value
mapped
vertex
position
ordering
vertices
3.5
examples
overview
section
illustrated
functioning
d-flat
via
several
examples
course
also
introduced
step-by-step
special
predicates
d-flat
provides
recognizes
d-flat
solutions
problems
provided
system
website
http
//www.dbai.tuwien.ac.at/research/project/dynasp/
dflat/
let
noted
also
possible
handle
problems
higher
polynomial
hierarchy
instance
one
solve
propositional
asp
d-flat
instance
implementing
algorithm
presented
jakl
2009
purposes
like
d-flat
allows
assignments
vertices
gen-
erally
hierarchy
assignments
example
top-level
assignment
dealing
might
subsidiary
assignments
used
determine
respective
top-level
assignment
valid
detailed
account
beyond
scope
paper
refer
reader
system
website
examples
let
brieﬂy
summarize
main
features
d-flat
many
cases
user
implement
program
exchange
nodes
join
nodes
d-flat
offers
default
implementation
certain
problems
default
overridden
programs
users
exploit
full
language
accepted
gringo
restriction
predicates
reserved
d-flat
table
gives
summary
predicates
also
points
circumstances
depending
program
problem
type
predicates
used
predicates
used
facts
constitute
problem
instance
supplied
verbatim
exchange
join
programs
d-flat
system
4.1
system
description
d-flat
written
c++
compiled
many
platforms
main
libraries
used
sharp
framework7
takes
care
constructing
tree
decomposition
input
graph
semi-normalizing
well
sharp
provides
skeleton
flat
data
management
sharp
uses
htdecomp
library8
implements
several
heuristics
hyper
tree
decompositions
see
also
dermaku
2008
gringo/clasp9
family
asp
tools
see
also
gebser
2011
recent
survey
ﬁnally
used
grounding
solving
user-speciﬁed
asp
programs
figure
depicts
control
ﬂow
components
simpliﬁed
way
d-flat
initially
parses
instance
constructs
hypergraph
representation
used
htdecomp
see
http
//www.dbai.tuwien.ac.at/research/project/sharp/
see
http
//www.dbai.tuwien.ac.at/proj/hypertree/downloads.html
see
http
//potassco.sourceforge.net/
bliem
morak
woltran
figure
ﬂowchart
illustrating
simpliﬁed
interplay
d-flat
components
asp
solver
compute
tuples
detailed
figure
d-flat
parse
instance
populate
table
flatten
child
tables
materialize
solution
htdecomp
decompose
sharp
visit
next
node
post-order
done
yes
build
hypertree
decomposition
sharp
responsible
traversing
tree
post-order
node
calls
d-flat
ﬂattens
child
tables
i.e.
converts
set
facts
given
asp
solver
compute
new
tuples
answer
sets
collected
d-flat
populates
current
node
table
nodes
processed
like
d-flat
reconstructs
solutions
tables.10
since
leave
decomposition
part
well
solving
asp
programs
ex-
ternal
libraries
d-flat
immediately
takes
advantage
improvements
libraries
thus
also
possible
switch
another
asp
solver
altogether
without
changing
d-flat
internals
except
course
parts
calling
solver
likewise
approach
allows
replace
tree
decomposition
part
weaker
efﬁcient
concepts
like
graph
cuts
etc
since
user
provides
asp
programs
exchange
optionally
join
nodes
runtime
d-flat
independent
particular
problem
solved
means
need
recompile
order
change
dynamic
programming
algorithm
used
box
rapid
prototyping
tool
wide
range
problems
executing
d-flat
binary
user
adjust
behavior
using
command-
line
options
important
ones
brieﬂy
described
table
problem
instance
must
set
facts
read
standard
input
parser
d-flat
recognizes
predicates
declare
hyper
edges
whose
names
given
command-line
options
fact
introduces
hyper
edge
instance
graph
arguments
hyper
edge
predicates
implicitly
declare
instance
graph
set
vertices
note
tree
decomposition
algorithm
used
currently
allow
isolated
vertices
real
limitation
usually
solutions
modiﬁed
instance
without
isolated
vertices
trivially
extended
executing
d-flat
binary
dflat
illustrated
following
example
call
pre-
supposing
3-col
instance
ﬁle
name
instance.lp
exchange
program
ﬁle
name
exchange.lp
section
3.1
instructing
d-flat
print
num-
ber
solutions
enumerate
dflat
edge
exchange.lp
instance.lp
data
ﬂow
procedure
within
node
indicated
dashed
box
illustrated
figure
note
d-flat
also
features
default
join
implementation
use
asp
depicted
d-flat
declarative
problem
solving
using
tree
decompositions
asp
table
d-flat
important
command-line
options
argument
meaning
edge_predicate
mandatory
least
exchange_program
mandatory
join_program
optional
problem_type
optional
edge_predicate
used
problem
instance
predicate
declaring
hyper
edges
arguments
predicate
implicitly
declare
vertices
input
graph
exchange_program
ﬁle
name
asp
program
processing
exchange
nodes
join_program
ﬁle
name
asp
program
process-
ing
join
nodes
omitted
default
implementation
used
problem_type
speciﬁes
kind
solution
user
in-
terested
either
enumeration
default
counting
decision
opt-enum
opt-counting
opt-value
4.2
experiments
section
brieﬂy
report
ﬁrst
experimental
results
discussed
problems
compared
d-flat
encodings
monolithic
ones
using
gringo
clasp
in-
stance
limited
minutes
cpu
time
memory
instances
con-
structed
small
treewidth
starting
tree-like
structure
introducing
random
elements
desired
ﬁxed
decomposition
width
reached
traditional
asp
solvers
employ
clever
heuristics
quickly
either
ﬁnd
model
detect
unsatisﬁability
thereby
able
solve
decision
variant
problems
partic-
ularly
well
contrast
dynamic
programming
approach
d-flat
currently
always
calculates
tuple
tables
way
whatever
problem
variant
may
be—it
ﬁnal
materialization
stage
solutions
assembled
differently
depending
problem
type
3-col
sat
prime
examples
problems
traditional
asp
solvers
successful
solving
decision
variant
efﬁciently
however
longer
sufﬁces
merely
ﬁnd
model
e.g.
dealing
counting
enumeration
problems
decomposition
exploited
d-flat
pays
small
treewidths
especially
great
number
solutions
experiments
monolithic
encodings
indeed
soon
hit
time
limit
d-flat
hand
even
sooner
ran
memory
enumeration
due
materializing
solutions
memory
time
number
solutions
increased
rapidly
larger
instances
motivation
improve
materialization
procedure
future
incremental
solving
techniques
d-flat
excelled
counting
variant
problems
could
solve
instance
matter
seconds
monolithic
program
ran
time
soon
figure
illustrates
strengths
weaknesses
d-flat
counting
decision
variants
sat
although
monolithic
program
almost
instantaneously
solved
decision
problem
test
instances
running
time
counting
problem
soon
exploded
standard
asp-solvers
provide
dedicated
functionality
counting
bliem
morak
woltran
figure
comparison
d-flat
monolithic
encodings
decision
counting
variant
sat
in-
stances
treewidth
determining
optimum
cost
minimum
vertex
cover
instances
treewidth
thus
implicitly
enumerate
answer
sets
whereas
d-flat
remained
almost
unaffected
average
although
time
traditional
asp-solvers
perform
efﬁciently
decision
problems
problems
difﬁculties
particular
grounding
becomes
huge
investigations
show
cyclic
ordering
problem
d-flat
often
outperforms
monolithic
program
could
also
observed
d-flat
running
time
heavily
dependent
constructed
tree
decomposition
reason
averaged
performance
multiple
tree
decompositions
instance
size
minimum
vertex
cover
problem
proved
strong
suit
d-flat
figure
optimization
problems
general
stopping
ﬁrst
solution
found
option
traditional
solvers
since
yet
undiscovered
solutions
might
lower
cost
another
advantage
d-flat
traditional
solvers
least
case
clasp
require
two
runs
counting
enumerating
optimal
solutions
ﬁrst
run
serves
determine
optimum
cost
second
starts
scratch
outputs
models
cost
d-flat
contrast
requires
one
run
end
immediately
information
needed
determine
optimum
cost
concluding
remark
recall
d-flat
main
purpose
provide
means
specify
dynamic
programming
algorithms
declaratively
compete
tradi-
tional
asp
solvers
refrain
extensive
benchmarks
paper
nonetheless
concluded
d-flat
particularly
successful
optimization
counting
problems
provided
treewidth
small
especially
number
solutions
size
monolithic
grounding
explodes
conclusion
summary
introduced
d-flat
novel
system
allows
specify
dynamic
programming
algorithms
hyper
tree
decompositions
means
answer-set
pro-
gramming
end
d-flat
employs
asp
system
underlying
inference
engine
compute
local
solutions
speciﬁed
algorithm
provided
case
studies
illustrating
rich
syntax
asp
allows
succinct
easy-to-read
speciﬁcations
llllll20253035020406080100number
variablestime
lmonolithic
counting
monolithic
decision
d−flat
counting
decision
llllllllllllll45505560657075010203040number
verticestime
lmonolithicd−flat
d-flat
declarative
problem
solving
using
tree
decompositions
asp
algorithms
system—together
example
programs
given
section
benchmark
instances
used
section
4.2—is
free
software
available
http
//www.dbai.tuwien.ac.at/research/project/dynasp/dflat/
related
work
several
forms
support
dynamic
programming
exist
world
prolog
tabling
intermediate
results
natural
concept
mention
systems
tlp
guo
gupta
2008
b-prolog
zhou
2011
world
datalog
refer
dyna
system
eisner
filardo
2011
provides
wide
range
features
memoization
side
spectrum
work
gottlob
2010
shows
simple
formalism
monadic
datalog
placed
instead
monadic
second-order
mso
logic
meta-theorems
ﬁxed-parameter
tractability
terms
treewidth
courcelle
latter
approach
thus
theoretical
interest
main
difference
d-flat
mentioned
systems
user
make
use
full
language
asp
particular
employ
guess
check
methodology
subproblems
however
mentioned
system
far
supports
dynamic
programming
connection
hyper
tree
decompositions
future
work
next
step
compare
d-flat
detail
aforemen-
tioned
approaches
terms
modeling
capacities
performance
issues
well
plan
provide
different
decomposition
options
within
d-flat
particular
antic-
ipate
even
rather
simple
efﬁcient
decomposition
graph
say
simple
split
two
parts
might
practice
lead
performance
gains
monolithic
encodings
an-
line
optimization
concerns
lazy
evaluation
strategies
incremental
asp
techniques
gebser
2011
developed
finally
relation
approach
reactive
asp
gebser
2011
might
provide
interesting
new
research
directions
acknowledgments
supported
vienna
university
technology
special
fund
innova-
tive
projekte
9006.09/008
references
bodlaender
1993.
tourist
guide
treewidth
acta
cybern
1-2
1–22
bodlaender
2005.
discovering
treewidth
proc
sofsem
lncs
vol
3381.
springer
1–16
bodlaender
koster
2008.
combinatorial
optimization
graphs
bounded
treewidth
comput
255–269
bodlaender
koster
2010.
treewidth
computations
upper
bounds
inf
comput
208
259–275
brewka
eiter
truszczynski
2011.
answer
set
programming
glance
commun
acm
92–103
cai
huang
liu
rosamond
song
2008.
parameterized
complexity
biopolymer
sequence
comparison
comput
270–291
courcelle
1990.
graph
rewriting
algebraic
logic
approach
handbook
theoret-
ical
computer
science
volume
formal
models
sematics
van
leeuwen
elsevier
mit
press
193–242
bliem
morak
woltran
dermaku
ganzow
gottlob
mcmahan
musliu
samer
2008.
heuristic
methods
hypertree
decomposition
proc
micai
lncs
vol
5317.
springer
1–11
eisner
filardo
2011.
dyna
extending
datalog
modern
full
ver-
sion
available
http
//cs.jhu.edu/˜jason/papers/eisner+filardo
datalog11-long.pdf
gebser
grote
kaminski
schaub
2011.
reactive
answer
set
program-
ming
proc
lpnmr
lncs
vol
6645.
springer
54–66
gebser
kaminski
kaufmann
ostrowski
schaub
thiele
2010.
user
guide
gringo
clasp
clingo
iclingo
preliminary
draft
available
http
//potassco.sourceforge.net
gebser
kaufmann
kaminski
ostrowski
schaub
schneider
2011.
potassco
potsdam
answer
set
solving
collection
commun
107–124
gebser
sabuncu
schaub
2011.
incremental
answer
set
programming
based
system
ﬁnite
model
computation
commun
195–212
gelfond
lifschitz
1991.
classical
negation
logic
programs
disjunctive
databases
new
generation
comput
3/4
365–386
gottlob
greco
scarcello
2009.
tractable
optimization
problems
hypergraph-based
structural
restrictions
proc
icalp
lncs
vol
5556.
springer
16–30
gottlob
leone
scarcello
2002.
hypertree
decompositions
tractable
queries
comput
syst
sci
579–627
gottlob
pichler
wei
2010.
monadic
datalog
ﬁnite
structures
bounded
treewidth
acm
trans
comput
log
greco
scarcello
2010.
structural
tractability
enumerating
csp
solutions
proc
2010.
lncs
vol
6308.
springer
236–251
guo
h.-f.
gupta
2008.
simplifying
dynamic
programming
via
mode-directed
tabling
softw.
pract
exper
75–94
jakl
pichler
woltran
2009.
answer-set
programming
bounded
treewidth
proc
ijcai
aaai
press
816–822
koster
van
hoesel
kolen
2002.
solving
partial
constraint
satis-
faction
problems
tree-decomposition
networks
170–180
larson
1967.
survey
dynamic
programming
computational
procedures
ieee
trans
automat
contr
767–774
leone
pfeifer
faber
eiter
gottlob
perri
scarcello
2006.
dlv
system
knowledge
representation
reasoning
acm
trans
comput
log
499–562
marek
truszczy
´nski
1999.
stable
models
alternative
logic
program-
ming
paradigm
logic
programming
paradigm
25-year
perspective
springer
375–398
niemel
1999.
logic
programming
stable
model
semantics
constraint
programming
paradigm
ann
math
artif
intell
3–4
241–273
robertson
seymour
1984.
graph
minors
iii
planar
tree-width
comb
theory
ser
49–64
samer
szeider
2010.
algorithms
propositional
model
counting
discrete
algorithms
50–64
wagner
1995.
dynamic
programming
mathematica
journal
42–51
jiao
berger
2005.
tree-decomposition
approach
protein
structure
pre-
diction
proc
csb
2005
247–256
zhou
n.-f.
2011.
language
features
architecture
b-prolog
corr
abs/1103.0812
