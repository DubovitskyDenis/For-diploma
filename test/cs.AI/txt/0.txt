grounding
recursive
aggregates
preliminary
report
martin
gebser1,3
roland
kaminski3
torsten
schaub2,3⋆
aalto
university
hiit
inria
rennes
university
potsdam
abstract
problem
solving
answer
set
programming
consists
two
steps
ﬁrst
grounding
phase
systematically
replacing
variables
terms
second
solving
phase
computing
stable
models
obtained
ground
pro-
gram
intricate
part
phases
treatment
aggregates
popular
language
constructs
allow
expressing
properties
sets
paper
elaborate
upon
treatment
aggregates
grounding
gringo
series
consequently
approach
applicable
grounding
based
semi-naive
database
evaluation
techniques
particular
provide
series
algorithms
detailing
treatment
recursive
aggregates
illustrate
running
example
introduction
modern
grounders
like
one
dlv
gringo
based
semi-naive
database
evaluation
techniques
3,4
avoiding
duplicate
work
grounding
grounding
seen
iterative
bottom-up
process
guided
successive
expansion
program
herbrand
base
set
variable-free
atoms
constructible
signature
program
hand
process
ground
rule
pro-
duced
positive
body
atoms
belong
current
herbrand
base
case
head
atom
added
current
herbrand
base
basic
idea
semi-naive
database
evaluation
focus
process
new
atoms
generated
iteration
order
avoid
reproducing
ground
rules
idea
based
observation
production
new
ground
rule
relies
existence
atom
new
previous
iteration
accordingly
ground
rule
produced
positive
body
contains
least
one
atom
produced
last
iteration
follows
show
grounding
framework
relying
upon
semi-naive
database
evaluation
techniques
extended
incorporate
recursive
aggregates
example
aggregate
shown
table
giving
encoding
company
controls
problem
company
controls
company
directly
indirectly
controls
shares
aggregate
sum
implements
summa-
tion
positive
integers
notably
takes
part
recursive
deﬁnition
controls/2
table
corresponding
problem
instance
given
table
note
systematic
instantiation
four
variables
table
eight
constants
table
results
ground
rules
however
taken
together
encoding
instance
equivalent
program
table
consists
four
ground
rules
fact
liter-
afﬁliated
simon
fraser
university
canada
iiis
grifﬁth
university
australia
controls
sum
owns
controls
owns
company
company
table
company
controls
encoding
company
company
company
company
owns
owns
owns
owns
table
company
controls
instance
als
table
even
evaluated
view
problem
instance
moreover
allows
evaluate
aggregate
atoms
grounding
com-
pany
controls
instance
boils
four
facts
controls
controls
controls
controls
accordingly
goal
paper
elaborate
upon
efﬁcient
computation
relevant
grounding
programs
recursive
aggregates
section
starts
recalling
formal
preliminaries
section
provides
basic
grounding
algo-
rithms
paving
way
sophisticated
algorithms
addressing
recur-
sive
aggregates
section
summarize
contribution
relate
state
art
section
developed
approach
implemented
gringo
series
formal
preliminaries
section
recalls
formal
preliminaries
regarding
syntax
semantics
gringo
input
language
developed
2.1
syntax
alphabet
consider
numerals
symbolic
constants
variables
aggregate
names
along
symbols
numerals
strings
numbers
optionally
preceded
minus
symbol
constants
strings
letters
underscores
numbers
starting
lowercase
letter
vari-
ables
strings
letters
underscores
numbers
starting
uppercase
letter.5
terms
numerals
constants
variables
terms
given
constant
term
tuple
term
well
variable-free
term
said
ground
equality
included
treated
specially
gringo
description
beyond
scope
paper
use
denote
anonymous
variables
i.e.
stands
unique
variable
controls
sum
owns
company
company
controls
sum
owns
company
company
controls
sum
owns
controls
owns
company
company
controls
sum
controls
owns
company
company
table
relevant
grounding
company
controls
interpretation
numerals
aggregates
numeral
corresponds
integer
total
order
ground
terms
extending
numerals
integers
ground
term
tuple
weight
ﬁrst
element
numeral
form
otherwise
aggregate
name
associated
function
set
sets
ground
term
tuples
set
ground
terms
given
set
ground
term
tuples
con-
sider
aggregate
names/functions
deﬁned
dsum
σt∈t
weight
subset
tuples
non-zero
weights
ﬁnite
\sum
σt∈t
weight
0weight
subset
tuples
positive
otherwise
weights
ﬁnite
otherwise.6
atoms
literals
symbolic
atoms
form
constant
term
tuple
comparison
atoms
form
terms
use
atom
denote
comparison
atom
false
e.g.
use
analogously
simple
literals
form
symbolic
comparison
atom
aggregate
atoms
form
aggregate
name
term
tuple
tuple
simple
literals
one
symbols
term
also
called
guard
holds
numeral
finally
literals
form
either
symbolic
comparison
aggregate
atom.7
rules
programs
rules
form
symbolic
atom
literal
program
ﬁnite
set
rules
miscellaneous
deﬁnitions
use
following
projection
functions
rules
head
rule
form
body
rule
form
body+
body
symbolic
atom
body−
body
symbolic
atom
body±
body+
body−
following
body
literals
marked
binary
relation
holds
literal
body
rule
marked
marked
body
literals
indicated
substitution
mapping
variables
ground
terms
represent
substi-
tutions
sets
form
variable
ground
term
substitution
form
applied
literal
written
replaces
occurrences
variables
corresponding
terms
moreover
associate
follows
occurrence
aggregate
logic
program
unique
identiﬁer
use
refer
aggregate
func-
tion
tuple
global
variables
guard
aggregate
occurrence
identiﬁed
refers
ground
guard
variables
listed
tuple
furthermore
replaced
corresponding
terms
tuple
aggregate
together
relation
monotone
sets
ground
term
tuples
ground
term
implies
2.2
semantics
semantics
programs
rests
upon
translation
inﬁnitary
propositional
for-
mulas
along
stable
models
ground
simple
literals
mapped
via
propositional
atoms
follows
ground
symbolic
atom
relation
holds
otherwise
literal
global
variables
variable
global
simple
literal
occurs
literal
aggregate
literal
occurs
guard
rule
global
head
body
literal
gringo
well
semantic
underpinnings
also
allow
double
negated
literals
form
∼∼a
aggregate
literals
translation
extends
aggregate
atoms
follows
instance
aggregate
element
obtained
substituting
variables
ground
terms
let
stand
conjunction
applications
ground
simple
literals
let
set
instances
aggregate
elements
set
justiﬁes
relation
holds
guard
conjunction
formulas
∈e\∆
sets
justify
negative
aggregate
literal
treated
analogous
negative
simple
literal
rules
programs
instance
rule
obtained
substituting
global
variables
ground
terms
set
formulas
instances
rule
sr∈p
program
stable
models
stable
models
logic
program
stable
models
inﬁnitary
propositional
formula
2.3
safety
rule
dependency
graph
global
variable
safe
rule
bound
positive
symbolic
literal
rule
body
non-global
variable
safe
aggregate
element
bound
positive
symbolic
literal
corresponding
aggregate
element
rule
safe
variables
safe
program
safe
rules
safe
follows
consider
safe
programs
rule
dependency
graph
normal
logic
program
directed
graph
body±
head
uniﬁes
positive
rule
dependency
graph
deﬁned
similarly
considers
edges
induced
positive
literals
body+
basic
grounding
algorithms
section
provides
basic
algorithms
underlying
semi-naive
evaluation
based
grounding
see
also
apply
normal
logic
programs
thus
independent
treatment
recursive
aggregates
described
next
section
illustrate
basic
algorithms
means
hamiltonian
cycle
example9
using
graph
figure
graph
represented
problem
instance
table
actual
problem
encoding
given
resulting
hamiltonian
cycle
expressed
instances
predicate
path/2
detailed
discussion
encodings
found
8,9,10
uniﬁcation
assumes
variables
distinct
even
name
https
//en.wikipedia.org/wiki/hamiltonian_path_problem
node
node
node
node
start
edge
edge
edge
edge
edge
edge
edge
fig
hamiltonian
cycle
instance
graph
table
hamiltonian
cycle
instance
path
edge
∼omit
omit
edge
∼path
path
path
path
path
on_path
path
path
node
∼on_path
reach
start
reach
reach
path
node
∼reach
3.1
analyzing
logic
programs
function
analyze
given
algorithm
takes
logic
program
classiﬁes
oc-
currences
recursive
symbolic
atoms
groups
rules
components
suitable
successive
grounding
classiﬁcation
atoms
used
apply
on-the-ﬂy
simpliﬁcations
following
algorithms
algorithm
analyze
ﬁrst
determines
strongly
connected
components
program
dependency
graph
lines
2-3
graph
contains
dependencies
induced
pos-
itive
negative
literals
outer
loop
lines
5-10
iterates
components
topological
order.10
component
reﬁned
terms
positive
de-
pendency
graph
lines
6-7
set
recursive
symbolic
atoms
determined
line
body
literals
whose
atom
uniﬁes
head
rule
current
following
com-
ponent
finally
reﬁned
component
together
recursive
atoms
appended
list
line
10.
list
result
algorithm
returned
line
11.
figure
shows
dependency
graph
encoding
given
positive
edges
depicted
solid
lines
negative
ones
dashed
lines
recursive
atoms
typeset
bold
negative
edge
component1,2
component1,1
due
fact
path
negative
body
uniﬁes
path
head
furthermore
occurrence
path
recursive
induces
edge
later
component
topological
ordering
hand
contrast
pos-
itive
literals
recursiveness
negative
literals
depends
topological
ordering
component
precedes
edge
function
analyze
let
dependency
graph
strongly
connected
components
foreach
let
positive
dependency
graph
strongly
connected
components
foreach
let
body±
head
uniﬁes
return
algorithm
analyze
logic
programs
grounding
component1,1
omit
edge
∼path
component1,2
path
edge
∼omit
component2,1
path
path
component3,1
path
path
component4,1
on_path
path
path
component5,1
node
∼on_path
component6,1
reach
start
component7,1
reach
reach
path
component8,1
node
∼reach
fig
hamiltonian
cycle
dependency
graph
instance
omit
would
recursive
topological
order
obtained
ex-
changing
component1,1
component1,2
regarding
component7,1
occurrence
reach
body
recursive
uniﬁes
head
rule
accordingly
induces
self-loop
dependency
graph
3.2
preparing
components
grounding
function
prepare
sets
rules
component
grounding
w.r.t
recursive
atoms
end
adds
one
subscripts
predicate
names
atoms
positive
rule
bodies
given
component.11
subscripts
alphabet
section
allow
predicate
names
subscripts
ground-
ing
temporarily
extend
alphabet
predicate
names
function
prepare
foreach
let
body+
foreach
∪
head
∈body+
vl∈body
\body+
head
∈body+
vl∈body
\body+

return
algorithm
prepare
components
indicate
new
old
atoms
belonging
current
materialization
herbrand
base
turn
used
course
semi-naive
database
evaluation
avoid
duplicate
work
grounding
component
w.r.t
expanding
herbrand
base
loop
lines
3-10
iterates
rules
component
hand
rule
expanded
set
rules
loop
lines
6-8
w.r.t
recursive
atoms
body
line
ﬁrst
row
line
predicate
names
recursive
atoms
already
considered
set
receive
subscript
predicate
name
recursive
atom
receives
subscript
second
row
recursive
atoms
yet
considered
well
non-recursive
atoms
positive
body
receive
subscript
finally
third
row
remaining
body
literals
kept
unmodiﬁed
recursive
atoms
line
subscript
added
positive
body
elements
ﬁrst
row
line
case
recursive
atoms
remaining
body
literals
kept
unmodiﬁed
second
row
result
preparing
components
dependency
graph
figure
given
figure
rules
contain
non-recursive
positive
body
literals
adorned
subscript
unlike
non-recursive
positive
body
literal
path
adorned
recursive
one
reach
receives
subscript
since
one
recursive
body
atom
one
rule
generated
3.3
grounding
rules
rule
grounding
algorithm
relies
upon
two
auxiliary
functions
first
function
order
returns
safe
body
order
rule
body.12
safe
body
order
body
tuple
safe
example
runtime
instantiation
algorithms
sensitive
chosen
body
order
context
asp
heuristics
ordering
body
literals
studied
component1,1
omit
edge
∼path
component1,2
path
edge
∼omit
component2,1
path
path
component3,1
path
path
component4,1
on_path
path
path
component5,1
node
∼on_path
component6,1
reach
start
component7,1
reach
reachn
path
component8,1
node
∼reach
fig
prepared
hamiltonian
cycle
encoding
safe
body
order
second
given
sym-
bolic
atom
substitution
set
ground
atoms
function
matches
returns
set
matches
w.r.t
match
⊆-minimal
substitution
aσ′
instance
matches
yields
functions
hand
assemble
basic
algorithm
groundrule
grounding
individual
rules
algorithm
note
original
rule
along
marking
ignored
context
relevant
treating
aggregates
section
4.13
algorithm
proceeds
along
safe
body
order
determined
line
20.
body
literals
remain
ground
rule
generated
line
provided
head
among
established
facts
moreover
rule
focus
become
fact
head
added
line
remainder
constitutes
case
analysis
upon
type
left-most
body
literal
positive
body
literal
instance
added
turn
partial
ground
body
match
however
done
literal
marked
instance
yet
belong
established
facts
negative
body
literal
instance
obtained
applying
current
substitution
added
ground
body
done
literal
marked
literal
recursive
already
derivation
substitutions
instance
fact
skipped
altogether
finally
comparison
literals
directly
evaluated
rule
instantiation
pursued
test
successful
illustration
trace
figure
application
groundrule
rule
viz
omit
edge
∼path
figure
figure
also
gives
rule
application
function
prepare
positive
body
literals
free
subscripts
conditions
line
respectively
tautological
section
function
groundrule
let
original
version
rule
function
groundrule′
head
head
head
else
foreach
matches
groundrule′
else
b1σ
groundrule′
else
b1σ
true
groundrule′
rule
instance
positive
literals
negative
literals
comparison
atoms
groundrule′
order
body
return
algorithm
grounding
rules
edge
∼path
omit
path
edge
∼path
omit
edge
∼path
omit
edge
∼path
omit
edge
∼path
omit
edge
∼path
omit
edge
∼path
omit
edge
∼path
omit
edge
edge
edge
edge
edge
edge
edge
=

fig
call
groundrule
contents
respective
sets
atoms
tackling
ﬁrst
component
figure
header
figure
contains
ordered
body
followed
rule
head
starting
ﬁrst
positive
body
literal
edge
results
eight
distinct
matches
edge
atoms
resulting
set
matches
connected
undirected
edges
figure
note
none
instances
edge
added
function
ground
foreach
analyze
repeat
foreach
prepare
groundrule
head
body+
return
algorithm
grounding
logic
programs
empty
body
since
found
facts
looking
trace
ﬁrst
match
observe
groundrule
next
called
empty
body
singleton
∼path
substitution
given
atom
path
fact
recursive
simpliﬁcations
apply
indicated
underlining
instance
added
body
following
call
body
∼path
empty
tuple
substitution
results
ground
rule
omit
∼path
analogously
six
matches
result
instances
3.4
grounding
logic
programs
functions
put
together
algorithm
grounding
entire
normal
logic
programs
function
ground
takes
partition
program
genuine
rules
atoms
stemming
facts
returns
upon
termination
set
ground
in-
stantiated
rules
latter
incrementally
constructed
following
topological
order
components
determined
analyze
turn
adorned
rule
prepared
component
instantiated
via
groundrule
loop
lines
5-11
exe-
cuted
whenever
component
free
recursive
positive
body
literals
otherwise
new
head
atoms
forthcoming
accomplished
manip-
ulating
following
sets
atoms
set
relevant
atoms
current
grounding
step
set
atoms
atoms
newly
instantiated
previous
grounding
step
set
atoms
new
w.r.t
previous
step
set
atoms
resulting
current
grounding
step
set
atoms
corresponding
fact
set
comprises
relevant
herbrand
base
algorithm
terminates
illustration
let
trace
ground
figure
grounding
last
one
component
figure
precise
deals
prepared
version
component7,1
containing
rule
viz
reach
reachn
path
recursive
nature
rule
results
three
iterations
loop
lines
5-11.
reach
path
reach
reach
reach
path
reach
path
reach
reach
path
reach
path
reach
reach
path
reach
path
reach
reach
path
reach
1.1

reach
path
path
path
path
path
path
path
reach
=
reach
reach
reach
1.2
1.3
fig
grounding
component7,1
accordingly
index
atom
sets
figure
reﬂect
state
respective
iteration
moreover
provide
parts
relevant
grounding
otherwise
conventions
follow
ones
figure
ﬁrst
iteration
atom
reach
obtained
grounding
component6,1
used
obtain
rule
instances
reach
path
reach
path
note
reach
removed
rule
bodies
belongs
estab-
lished
facts
moreover
iteration
yields
new
atoms
reach
reach
used
next
iteration
obtain
four
rule
instances
reach
reach
path
reach
reach
path
reach
reach
path
reach
reach
path
unlike
simpliﬁcations
performed
facts
involved
iteration
brings
single
new
atom
reach
yields
rule
instance
reach
reach
path
function
rewrite
loop
stands
sign
aggregate
literal
foreach
body
let
unique
identiﬁer
global
variables
replace
occurrence
⋄aggr
=vl∈body
simple
literal
accu
neutral
←bα
accu
tuple
←vl∈lj
aggr
accu
return
algorithm
rewrite
logic
programs
iteration
produces
new
atoms
ends
instantiation
component7,1
components
grounded
analogously
within
single
iteration
due
lack
recursive
positive
body
literals
enforced
second
stop
criterion
line
algorithm
grounding
recursive
aggregates
laid
foundations
grounding
normal
logic
programs
continue
treatment
recursive
aggregates
idea
translate
aggregate
atoms
normal
logic
programs
roughly
one
rule
per
aggregate
element
reuse
basic
grounding
machinery
much
possible
addition
aggregate-speciﬁc
propagation
takes
place
end
resulting
aggregate
instances
re-assembled
corresponding
rules
4.1
rewriting
logic
programs
aggregates
function
rewrite
given
algorithm
takes
input
logic
program
possibly
recursive
aggregates
rewrites
normal
logic
program
additional
predicates
capturing
aggregates
aggregate
elements.14
aggregate
occurrence
replaced
atom
form
aggr
line
unique
identiﬁer
associated
aggregate
occurrence
global
variables
occurring
aggregate
idea
atom
predi-
cate
aggr
grounding
rewriting
corresponds
ground
aggregate
substituted
atom
ﬁnal
grounding
represent
aggregate
elements
like
auxiliary
rules
deﬁning
atoms
form
accu
added
line
global
variables
tuple
aggregated
special
constant
neutral
idea
inspect
assume
predicates
aggr
accu
used
elsewhere
program
controls
aggr
accu
neutral
accu
tuple
owns
accu
tuple
controls
owns
aggr
accu
company
company
table
rewritten
company
controls
encoding
grounding
rules
atoms
accu
head
enough
atoms
accumulated
satisfy
aggregate
corresponding
atoms
aggr
added
herbrand
base
ground
program
ﬁrst
rule
line
handles
special
case
aggregate
satisﬁed
empty
set
tuples
e.g.
anti-monotone
aggregates
like
sum
body
contains
comparison
literal
checks
whether
empty
aggregate
satisﬁed
furthermore
make
sure
rule
safe
instantiated
purpose
simple
literals
rule
aggregate
occurs
added
rule
body
via
function
hence
original
rule
safe
auxiliary
rule
also
safe
global
variables
bound
positive
symbolic
literals
furthermore
literals
responsible
binding
global
variables
marked
via
second
set
rules
line
charge
accumulating
tuples
aggregate
elements
rule
body
contains
literals
condition
aggregate
element
well
marked
literals
necessary
ensuring
rule
safety
remember
resulting
ground
rules
represent
ground
aggregate
atoms
marking
used
distinguish
literals
belonging
conditions
reconstituted
aggregate
elements
finally
one
last
rule
added
line
ensuring
dependencies
induced
aggregate
kept
intact
since
rule
contains
never
produces
instances
though
result
rewriting
company
controls
encoding
table
given
table
global
variables
single
aggregate
occur
ﬁrst
atoms
aggr
1/2
accu
1/3
since
empty
aggregate
satisﬁed
rule
accumulating
neutral
tuple
never
produces
instances
could
principle
dropped
rewriting
4.2
analyzing
preparing
logic
programs
aggregates
figure
captures
result
function
analyze
prepare
called
component
rewritten
company
controls
encoding
table
rules
component1,1
component2,1
depend
facts
thus
induce
singleton
component
component3,1
contains
remaining
rules
aggregate
company
controls
encoding
recursive
component
view
atom
controls
second
aggregate
element
note
aggregate
elements
involved
recursion
given
direct
shares
accumulated
via
rule
component2,1
component1,1
accu
neutral
component2,1
accu
tuple
owns
component3,1
aggr
accu1n
controls
aggr1n
accu
tuple
controlsn
owns
company
company
fig
dependency
graph
company
controls
program
function
propagate
foreach
accu
let
accu
tuple
relevant
accu
tuple
relevant
true
exists
wherebαi
aggregate
monotone
andbαi
aggr
aggr
return
algorithm
propagation
aggregates
4.3
propagating
aggregates
function
propagate
inspects
partial
grounding
aggregate
instance
view
grounded
aggregate
elements
end
checks
atoms
predicate
accu
obtained
grounding
loop
lines
3-10
iterates
given
ag-
gregate
indices
tuples
global
variables
stored
atoms
predicate
accu
appearing
among
atoms
whenever
enough
tuples
captured
atoms
satisfy
corresponding
aggregate
propagate
adds
atoms
predicate
aggr
instantiation
line
collects
tuples
necessar-
ily
accumulated
aggregate
function
line
gathers
tuples
whose
conditions
possibly
hold
also
note
relevance
check
skips
tuples
change
result
aggregate
function.15
sum
aggregates
amounts
excluding
zero-
weight
tuples
stipulating
weight
given
sets
tuples
line
checks
whether
aggregate
satisﬁed
using
tuples
accumulated
far
sum
ag-
non-recursive
aggregates
ﬂag
false
line
checks
whether
empty
relevant
tuples
gathered
function
assemble
foreach
aggr
occurring
body
assumed
convert
tuple
literals
let
body
head
accu
tuple
replace
occurrences
aggr
remove
rules
atoms
accu
head
return
algorithm
assembling
aggregates
gregates
tested
adding
weights
factual
tuples
one
hand
negative
weights
obtain
minimum
min
positive
weights
obtain
maximum
max
depending
relation
aggregate
satisﬁable
max
min
min
true
true
max
true
test
line
succeeds
ground
aggregate
atom
added
new
atoms
line
10.
addition
given
non-recursive
monotone
aggregate
corresponding
ground
aggregate
atom
added
whenever
aggregate
found
true
point
non-recursive
aggregate
true
elements
facts
line
monotone
aggregate
true
enough
facts
satisfy
aggregate
accumu-
lated
line
finally
sets
new
factual
atoms
returned
line
4.4
assembling
aggregates
rewrite
decomposed
aggregate
atoms
normal
program
rules
assemble
given
algorithm
reconstructs
grounded
counterparts
rewritten
ground
program
occurrences
atoms
form
aggr
re-
placed
corresponding
aggregates
aggregate
elements
re-
constructed
rules
head
atoms
accu
tuple
line
element
consists
term
tuple
along
condition
expressed
rule
body.16
actual
replacement
takes
place
line
followed
deletion
obsolete
rules
line
finally
reconstructed
ground
program
returned
line
4.5
grounding
logic
programs
aggregates
algorithm
extends
ground
function
algorithm
logic
program
aggregates
end
extended
ground
function
uses
algorithms
rewrite
propagate
assemble
previous
subsections
changes
algo-
rithm
highlighted
gray
background
parts
left
untouched
ﬁrst
change
line
function
rewrite
called
turn
logic
program
normal
logic
program
calling
analyze
lines
recall
marked
literals
added
safety
stripped
groundrule
algorithm
function
ground
foreach
analyze
rewrite
let
aggr
occurs
rule
head
head
accu
body+
repeat
foreach
prepare
groundrule
head
propagate
false
propagate
true
body+
return
assemble
algorithm
grounding
logic
programs
aggregates
added
loop
charge
grounding
component
ag-
gregate
indices
propagated
instantiation
component
collected
first
indices
rule
aggr
head
appears
com-
ponent
gathered
remember
rules
contribute
instances
belongs
bodies
third
row
line
algorithm
instead
propagate
adding
atoms
aggr
second
line
aggregate
indices
associated
recursive
aggregates
collected
positive
recursion
involves
aggre-
gate
element
indicated
rule
head
atom
accu
yet
without
considering
auxiliary
body
part
marked
collected
indices
lines
12-15
used
propagate
corresponding
ag-
gregates
current
component
propagation
aggregates
triggered
whenever
new
atoms
obtained
grounding
loop
lines
9-11.
first
non-
recursive
aggregates
instantiated
point
least
one
ground
atom
form
accu
aggregate
elements
corresponding
aggre-
gate
uniquely
determined
terms
global
variables
gathered
aggregate
thus
propagated
function
propagate
apply
additional
sim-
pliﬁcations
line
algorithm
afterwards
recursive
aggregates
propagated
line
15.
case
assume
aggregate
elements
already
accumulated
propagation
thus
use
simpliﬁcations
applicable
non-recursive
aggregates
distinction
implemented
set-
ting
second
argument
propagate
true
finally
line
aggregates
reconstructed
intermediate
grounding
calling
function
assemble
a1n
g1n
propagate
propagate
propagate
1.1
2.1
3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.8
3.9
accu
aggr
controls
company
owns
neutral
tuple
fig
grounding
company
controls
figure
traces
whole
grounding
process
rewritten
company
controls
en-
coding
given
figure
grounding
component
separated
horizontal
double
line
instantiation
component
shown
analogously
figure
due
lack
space
refrain
giving
sets
component
indicated
number
right
contained
rules
listed
ﬁrst
followed
grounding
iterations
component
focus
iteration
separated
solid
line
indexed
iteration
number
right
instances
three
rules
component3,1
separated
dashed
lines
symbol
indicates
body
literal
match
corresponds
case
groundrule
function
algorithm
backtracks
grounding
component1,1
produces
rule
instances
comparison
atom
false
putting
literal
ﬁrst
safe
body
order
remaining
rule
body
completely
ignored
next
grounding
component2,1
direct
shares
given
facts
owns/3
accumulated
obtained
atoms
accu
1/3
classiﬁed
facts
well
trace
grounding
component3,1
ﬁrst
iteration
none
rules
produces
instances
atoms
controls/2
aggr
1/2
yet
hence
aggregate
propagation
triggered
resulting
aggregate
atoms
aggr
aggr
enough
shares
accumulated
upon
grounding
component2,1
note
since
aggregate
mono-
tone
atoms
established
facts
second
iteration
newly
obtained
aggregate
atoms
used
instantiate
second
rule
component
leading
new
atoms
controls/2
observe
putting
aggr
ﬁrst
safe
body
order
groundrule
instantiate
rule
without
backtracking
third
iter-
ation
newly
obtained
atoms
controls/2
yield
accu
via
instance
third
rule
component
turn
leads
aggregate
atom
aggr
following
iterations
proceed
similar
fashion
new
tuples
accumulated
grounding
loop
terminates
conﬁned
original
predicate
controls/2
instantiation
generates
four
atoms
controls
controls
controls
controls
produced
facts
note
utilized
safe
body
order
affects
amount
backtracking
rule
instantiation
one
particular
strategy
used
gringo
prefer
recursive
atoms
subscript
ordering
rule
body
seen
grounding
component3,1
helps
avoid
backtracking
upon
generating
new
rule
instances
further-
company
controls
encoding
simpliﬁcations
ensure
program
evaluated
facts
general
guaranteed
programs
stratiﬁed
negation
monotone
aggregates
discussion
presented
algorithmic
framework
grounding
logic
programs
based
semi-naive
database
evaluation
techniques
framework
implemented
gringo
series
constitutes
ﬁrst
approach
capturing
full-ﬂedged
aggregates
ferraris
semantics
13,6
semi-naive
evaluation
techniques
trace
back
ﬁeld
database
systems
3,4
introduction
grounding
asp
pioneered
dlv
system
laying
basic
semi-naive
grounding
algorithms
sim-
ilar
section
given
proximity
grounding
techniques
handling
recursive
aggregates
could
adopted
within
dlv
far
restricted
strati-
ﬁed
aggregates
grounding
approaches
pursued
gidl
lparse
earlier
versions
gringo
17,18,2
latter
two
also
support
recursive
con-
vex
aggregates
limited
necessity
bind
non-global
variables
domain
predicates
given
programs
λ-restricted
respectively
un-
like
approach
merely
relies
safety
condition
restriction
imposed
input
language
regarding
implementation
approach
aims
reusing
existing
grounding
techniques
normal
logic
programs
end
programs
aggregates
rewritten
conventional
semi-naive
evaluation
extended
propagation
step
aggregates
eventually
ground
aggregates
reconstructed
obtained
rule
instances
post-processing
step
present
paper
considered
sum
sum
aggregates
approach
applicable
aggregate
function
fact
count
min
max
aggregates
also
supported
gringo
series
easily
amenable
aggregates
extending
propagate
function
acknowledgments
work
funded
aof
grant
251170
dfg
grants
scha
550/8
550/9
well
daad
aof
joint
project
57071677
279121
references
faber
leone
perri
intelligent
grounder
dlv
247–264
gebser
kaminski
könig
schaub
advances
gringo
series
delgrande
faber
eds
proceedings
eleventh
international
conference
logic
program-
ming
nonmonotonic
reasoning
lpnmr
springer-verlag
2011
345–351
ullman
principles
database
knowledge-base
systems
computer
science
press
1988
abiteboul
hull
vianu
foundations
databases
addison-wesley
1995
mumick
pirahesh
ramakrishnan
magic
duplicates
aggregates
mcleod
sacks-davis
schek
eds
proceedings
sixteenth
international
conference
large
data
bases
vldb
morgan
kaufmann
publishers
1990
264–277
gebser
harrison
kaminski
lifschitz
schaub
abstract
gringo
theory
practice
logic
programming
4-5
2015
449–463
truszczy´nski
connecting
ﬁrst-order
asp
logic
reducts
543–559
niemelä
logic
programs
stable
model
semantics
constraint
programming
paradigm
annals
mathematics
artiﬁcial
intelligence
3-4
1999
241–273
marek
truszczy´nski
stable
models
alternative
logic
programming
paradigm
apt
marek
truszczy´nski
warren
eds
logic
programming
paradigm
25-year
perspective
springer-verlag
1999
375–398
10.
gebser
kaminski
kaufmann
schaub
answer
set
solving
practice
mor-
gan
claypool
publishers
2012
11.
leone
perri
scarcello
improving
asp
instantiators
join-ordering
methods
280–294
12.
alviano
calimeri
faber
leone
perri
unfounded
sets
well-founded
semantics
answer
set
programs
aggregates
journal
artiﬁcial
intelligence
research
2011
487–527
13.
ferraris
logic
programs
propositional
connectives
aggregates
acm
transac-
tions
computational
logic
2011
25:1–25:44
14.
leone
pfeifer
faber
eiter
gottlob
perri
scarcello
dlv
system
knowledge
representation
reasoning
acm
transactions
computational
logic
2006
499–562
15.
wittocx
mariën
denecker
grounding
bounds
journal
artiﬁcial
intelligence
research
2010
223–269
16.
syrjänen
omega-restricted
logic
programs
267–279
17.
gebser
schaub
thiele
gringo
new
grounder
answer
set
programming
baral
brewka
schlipf
eds
proceedings
ninth
international
conference
logic
programming
nonmonotonic
reasoning
lpnmr
springer-verlag
2007
266–271
18.
gebser
kaminski
ostrowski
schaub
thiele
input
language
asp
grounder
gringo
erdem
lin
schaub
eds
proceedings
tenth
inter-
national
conference
logic
programming
nonmonotonic
reasoning
lpnmr
springer-verlag
2009
502–508
19.
erdem
lee
lierler
pearce
eds
correct
reasoning
essays
logic-based
honour
vladimir
lifschitz
springer-verlag
2012
20.
eiter
faber
truszczy´nski
eds
proceedings
sixth
international
confer-
ence
logic
programming
nonmonotonic
reasoning
lpnmr
springer-verlag
2001
