hardware
acceleration
boolean
satisfiability
solver
applying
belief
propagation
algorithm
te-hsuan
chen
ju-yi
department
electrical
engineering
computer
science
university
michigan
ann
arbor
48109
usa
tehsuan
juyi
umich.edu
abstract
boolean
satisﬁability
sat
extensive
application
domain
computer
science
especially
electronic
design
automation
applications
circuit
synthesis
optimization
verification
problems
solved
transforming
original
problems
sat
problems
however
sat
problem
known
np-complete
problem
means
efficient
method
solve
sat
problems
therefore
design
efficient
sat
solver
enhance
performance
always
desired
paper
proposed
hardware
acceleration
method
boolean
sat
problems
surveying
properties
sat
problems
decoding
low-density
parity-check
ldpc
codes
special
class
error-correcting
codes
eccs
discover
constraint
satisfaction
problems
csps
belief
propagation
algorithm
bpa
successfully
applied
corresponding
decoder
hardware
designs
extensively
studied
therefore
proposed
belief
propagation
based
algorithm
solve
sat
problems
algorithm
sat
solver
accelerated
hardware
software
simulator
implemented
verify
proposed
algorithm
performance
improvement
estimated
experiment
results
show
time
complexity
increase
size
sat
problems
proposed
method
achieve
least
30×
speedup
compared
minisat
decoding
ldpc
keywords
sat
boolean
satisfiability
belief
propagation
algorithm
introduction
boolean
satisﬁability
sat
class
problems
establishes
exist
assignment
variables
boolean
formula
evaluates
true
boolean
formula
usually
conjunctive
normal
form
cnf
expression
conjunction
clauses
clause
disjunction
literals
literal
either
variable
negation
sat
extensive
application
domain
logic
design
synthesis
optimization
verification
many
problems
placement
route
test
pattern
generation
equivalence
checking
model
checking
etc.
expressed
variables
whose
values
set
𝑡𝑟𝑢𝑒
𝑓𝑎𝑙𝑠𝑒
1,0
sat
problem
first
known
np-complete
decision
problem
means
efficient
algorithm
solve
sat
problems
although
theoretically
finding
set
assignment
achieved
exhaustively
trying
possible
assignments
method
becomes
infeasible
quickly
number
literals
clauses
increases
set
algorithms
solve
sat
problems
called
sat
solvers
however
due
np-complete
nature
sat
solve
sat
problems
within
reasonable
time
becomes
important
issue
much
research
conducted
improve
efficiency
sat
solvers
algorithm
far
efficiently
solve
sat
instances
goal
paper
using
hardware
accelerate
sat
solvers
approaches
solve
sat
problem
divided
software
solvers
solving
problem
using
computer
simulation
hardware
solver
implement
verilog
code
running
fpga
virtual
machine
hardware
sat
solver
main
two
categories
instance-specific
instance
dependence
application-specific
work
try
implement
instance-specific
model
resource
efficient
accommodate
single
fpga
satisfy
cnf
i.e
find
set
value
makes
cnf=1
clause
must
therefore
clause
represents
constraint
must
satisfied
simultaneously
constraint
three
components
satisfaction
problem
csp
consists
set
variables
set
domains
one
variable
set
constraints
specify
allowable
combinations
values
domain
consists
set
allowable
values
variable
constrain
consists
pair
〈𝑠𝑐𝑜𝑝𝑒
𝑟𝑒𝑙〉
𝑠𝑐𝑜𝑝𝑒
tuple
variables
participate
constrain
𝑟𝑒𝑙
relation
defines
values
variables
take
problem
solved
variable
value
satisfies
constraints
variable
definition
csp
found
boolean
sat
special
case
csp
set
domains
𝑡𝑟𝑢𝑒
𝑓𝑎𝑙𝑠𝑒
1,0
constraints
defined
set
clauses
must
satisfied
simultaneously
error
correction
codes
ecc
provide
one
cost-
effective
ways
achieve
noise
protection
applying
ecc
data
errors
corrected
detected
code
maps
binary
k-tuple
called
message
block
binary
n-tuple
called
codeword
block
usually
message
codeword
blocks
represented
vector
forms
mapping
defined
set
matrix
multiplications
decoding
special
class
ecc
low-density
parity-check
ldpc
codes
constraint
satisfaction
problem
parity-check
equations
specially
designed
equations
equal
zero
inputs
correct
goal
decoding
ldpc
codes
find
set
input
assignments
parity-check
equations
equal
therefore
decoding
ldpc
codes
actually
csp
symbol
codeword
variable
parity
check
corresponds
constraint
csp
besides
domain
variables
limited
𝑡𝑟𝑢𝑒
𝑓𝑎𝑙𝑠𝑒
1,0
ldpc
codes
therefore
decoding
ldpc
codes
modeled
sat
problem
decoding
ldpc
codes
procedure
illustrated
bipartite
graph
contains
two
types
nodes
variable
nodes
parity-check
nodes
use
iterative
belief
propagation
decoding
method
find
solutions
since
decoding
ldpc
codes
sat
solvers
csps
decoding
ldpc
codes
accomplished
specific
designed
hardware
comes
question
extend
ldpc
algorithm
belief
propagation
algorithm
bpa
solve
sat
problems
sat
solver
speeded
hardware
paper
show
bpa
also
applied
sat
solvers
since
solve
csps
also
possible
hardware
circuit
using
similar
architecture
also
used
accelerate
sat
solvers
therefore
propose
method
utilize
hardware
based
ldpc
decoder
improve
speed
sat
solvers
1.1
contribution
main
contribution
paper
applying
algorithm
decoding
ldpc
codes
cnf-based
sat
problems
evaluating
proposed
modified
bpa
simulator
written
c/c++
estimating
time
need
proposed
sat
solver
comparing
minisat
1.2
organization
paper
organized
follows
section
gives
quick
review
ldpc
codes
belief
propagation
algorithm
sat
solving
algorithm
based
belief
propagation
algorithm
proposed
section
section
provides
experimental
results
section
discusses
related
work
section
gives
conclusion
low-density
parity
check
code
originally
proposed
1962
robert
gallager
re-
discovered
david
mackay
1996
ldpc
codes
iterative
decoding
closely
approaching
shannon
channel
capacity
ldpc
codes
went
unnoticed
1990s
hardware
could
support
effective
decoder
implementations
however
mackay
research
development
semiconductor
technology
hardware
implementation
ldpc
codes
became
feasible
algorithms
performance
ldpc
code
linear
block
code
parity
check
matrix
interest
low
density
ones
ldpc
code
represented
matrices
assume
codeword
set
binary
linear
block
code
matrix
generation
matrix
𝐺|𝑥⃑𝜖
0,1
length-k
message
matrix
parity
check
matrix
𝑐⃑|𝑐⃑𝜖
0,1
codeword
words
ldpc
code
designed
satisfy
every
codeword
equation
always
holds
ldpc
codes
also
represented
using
graphs
parity-check
matrix
associated
graph
called
bipartite
graph
graph
contains
two
set
nodes
variable
nodes
check
nodes
v-nodes
c-nodes
rule
constructing
graph
c-node
connected
v-node
whenever
element
hij
example
let
parity-check
matrix
3×4
matrix
corresponding
bipartite
graph
shown
figure
v-nodes
c-nodes
example
figure
example
bipartite
graph
besides
cycle
length
bipartite
graph
path
comprised
edges
node
back
node
example
bipartite
graph
fig
cycle
length
short
cycles
usually
considered
bad
graphs
used
iterative
decoding
based
message
passing
increase
dependence
information
received
node
message
passing
may
lead
latch-up
problems
ldpc
codes
depend
message
passing
decoding
algorithm
called
belief
propagation
algorithm
bpa
sum-product
algorithm
spa
bpa
efﬁcient
decoding
algorithm
iteratively
decodes
ldpc
code
based
belief
propagation
bpa
decodes
data
probability
computation
received
signals
based
characteristic
channel
input
bit
probabilities
called
priori
probabilities
received
bits
known
advance
running
ldpc
decoder
besides
two
sets
probabilities
computation
handled
decoder
one
related
decoding
criterion
determines
value
received
bit
value
received
signal
sets
probabilities
referred
posterior
probabilities
figure
iterative
update
bpa
check
node
variable
node
form
variable
node
check
node
probability
related
satisfaction
check
sum
given
received
signal
bit
bpa
decoding
decode
data
iterative
update
two
sets
probabilities
determined
ﬁrst
sets
probabilities
parity-check
equations
goal
decoder
find
maximum
posteriori
probability
map
codeword
bit
words
aim
spa
maximize
probability
parity-check
constraints
satisfied
codeword
bit
satisfaction
received
bits
v1v2v3v4c1c2c3v4c2c3v1v2v3c1r1,1q2,1q3,1v4v1v3q2,1c2c3v2c1r2,2r3,2
initialize
bit
included
parity
check
i.e
ℎ𝑖𝑗
−1|𝑐𝑗
2𝑦𝑖
pass
information
check
nodes
variable
nodes
2𝑞𝑗′
𝑗′∈
ℎ𝑖𝑗≠0
𝑖≠𝑗
pass
information
variable
nodes
check
nodes
𝑟𝑖′
𝑖′∈
ℎ𝑖𝑗≠0
𝑖≠𝑗
𝑟𝑖′
𝑖′∈
ℎ𝑖𝑗≠0
𝑖≠𝑗
compute
posteriori
probability
ℎ𝑖𝑗≠0
ℎ𝑖𝑗≠0
compute
hard
decisions
𝑣̂𝑗
𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒
repeat
syndrome
figure
bpa
decoding
ecc
figure
illustrate
basic
concept
bpa
figure
part
bipartite
graph
shows
nodes
edges
connected
parity-check
relation
xor
satisfy
parity-check
must
two
bpa
handles
two
sets
probabilities
first
set
related
decoding
criterion
quantities
defined
iterative
computed
bpa
high
probability
must
high
satisfy
hand
v-node
figure
partial
graph
shows
parity-check
nodes
use
node
receives
information
probabilities
satisfy
parity-checks
involves
uses
information
update
probability
example
figure
passes
probability
using
information
form
another
set
probability
related
decoding
criterion
also
calculated
denoted
representing
probability
checks
involving
jth
bit
satisfied
probability
also
called
pseudo-posterior
probability
five
steps
bpa
shown
figure
original
algorithm
designed
communication
system
assuming
signals
modulated
binary
phase-shift
keying
bpsk
logic
modulated
voltage
logic
voltage
noise
assumed
additive
white
gaussian
noise
awgn
general
form
bpa
follows
belief
propagation
sat
section
discuss
proposed
belief
propagation
algorithm
sat
problem
bpa-sat
sat
problems
3.1
discuss
adopted
modification
belief
propagation
apply
sat
solver
3.2
provide
overview
proposed
bpa-sat
detail
implementation
3.1
adaption
bpa-sat
bpa
adopted
sat
problem
treat
check
nodes
clauses
variable
nodes
literal
also
initialization
probability
less
important
conventional
bpa
prior
information
literal
assignment
initialization
sat
problem
initial
values
literals
set
0.5
show
bias
assignment
without
prior
information
pass
information
clauses
literals
since
operators
cnf
clauses
𝑟1,1
represents
probability
true
giventhe
probability
therefore
modified
equation
𝑟1,1
1|𝑣1
represents
vector
pass
information
literals
clauses
neglect
multiplication
initial
values
affect
value
since
contain
useful
information
probability
given
probabilities
variables
𝑞𝑖𝑗
𝑟𝑖′
𝑖′∈
ℎ𝑖𝑗≠0
𝑖≠𝑗
probability
parity
checks
compute
posteriori
probability
involving
except
satisfied
remove
multiplication
example
𝑟1,1
probability
given
information
𝑞2,1
𝑞2,1
note
since
𝑞2,1
𝑞2,1
high
i.e
probability
ℎ𝑖𝑗≠0

3.2
bpa-sat
overview
figure
flow
chart
whole
bpa-sat
two
loop
bpa-sat
inner
loop
core
algorithm
bpa-sat
iteratively
calculates
outer
loop
break-and-restart
mechanism
prevent
bpa-sat
running
forever
randomly
assign
another
start
point
initial
value
set
100
figure
completeness
bpa-sat
4.2
execution
iteration
speedup
evaluation
estimate
speedup
algorithm
take
fpga
xilinx
virtex
xc2v6000-5
reference
model
based
experimental
result
desired
fpga
computation
ability
second
per
iteration
spi
calculated
equation
figure
flow
chart
bpa
cnf-based
sat
problems
𝑆𝑃𝐼
𝐶𝑜𝑑𝑒𝑤𝑜𝑟𝑑
𝑙𝑒𝑛𝑔𝑡ℎ
𝑇ℎ𝑟𝑜𝑢𝑔ℎ𝑝𝑢𝑡
𝐼𝑡𝑒𝑟𝑎𝑡𝑖𝑜𝑛
3969
1417𝑀
1.86
10−7𝑠𝑒𝑐/𝑖𝑡𝑒𝑟𝑎𝑡𝑖𝑜𝑛
experimental
result
section
present
evaluation
completeness
speedup
belief
propagation
sat
problem
3sat
benchmarks
satlib
ran
bpa
sat
simulator
speedup
compares
estimated
execution
time
bpa
sat
running
fpga
xilinx
virtex
xc2v6000-5
real
execution
time
minisat
solver
running
two
6-core
intel
xeon
cpu
e5645
2.40ghz
processor
4.1
completeness
sub-section
investigate
completeness
bpa-sat
experiment
instances
benchmark
satisifiable
completeness
defined
fraction
testbench
instance
solved
bpa-sat
figure
examines
completeness
bpa
sat
benchmark
set
satisifiable
benchmark
uf20-91
indicates
literal
number
clause
number
91.
shows
bpa
sat
worse
solving
ability
problem
size
become
larger
adopting
random
restart
mechanism
average
improvement
therefore
improve
completeness
main
issue
future
works
moreover
ecc
decoder
bpa
works
well
literal-clause
ratio
greater
literal-clause
ratio
sat
problem
typically
smaller
0.25.
fundamental
difference
believed
crucial
factor
incompleteness
proposed
bpa
sat
𝐶𝑜𝑑𝑒𝑤𝑜𝑟𝑑
𝑙𝑒𝑛𝑔𝑡ℎ
bandwidth
fpga
execute
parallel
single
iteration
𝐼𝑡𝑒𝑟𝑎𝑡𝑖𝑜𝑛
experimental
result
iteration
number
therefore
estimated
speedup
derived
𝐒𝐩𝐞𝐞𝐝𝒖𝒑
𝑻𝒎𝒊𝒏𝒊𝒔𝒂𝒕/𝑻𝒆𝒙𝒆𝒄
𝑻𝒎𝒊𝒏𝒊𝒔𝒂𝒕/
𝒊𝒕𝒆𝒓𝒂𝒕𝒊𝒐𝒏
𝑺𝑷𝑰
𝑇𝑚𝑖𝑛𝑖𝑠𝑎𝑡
average
running
time
minisat
solver
solve
single
sat
instance
𝑇𝑒𝑥𝑒𝑐
estimated
execution
time
bpa
sat
running
fpga
speedup
5.e+04
5.e+04
4.e+04
4.e+04
3.e+04
3.e+04
2.e+04
2.e+04
1.e+04
5.e+03
0.e+00
44095.23
15406.13
7991.27
32.37
38.21
83.26
178.131078.671932.1
140
120
100
iteration
speedup
figure
average
iteration
estimated
speedup
startcompute
rcompute
qcompute
qsat
max
iter
random
restartend
solution
foundend
solution
foundmax
restart
initialize
qynnyny
figure
takes
closer
look
every
solved
instance
find
relation
propagation
iteration
scale
sat
problem
blue
histogram
indicates
average
iteration
solved
instances
line
chart
represents
average
speedup
compared
execution
time
minisat
sat
solver
average
iteration
number
solved
instance
show
trend
growth
growth
problem
size
imply
constant
timing
complexity
regardless
scale
sat
problem
line
chart
comes
equation
speedup
grows
exponential
execution
time
minisat
grows
exponential
spike
uf200-860
caused
large
standard
deviation
sample
number
small
chart
indicates
main
advantage
adopting
bpa
sat
iteration
propagation
independent
size
sat
problem
also
mentioned
computation
depends
previous
iteration
result
implemented
parallel
easily
buffer
storing
previous
value
moreover
sparse
literal-clause
matrix
release
competing
shared
memory
issue
applicable
implement
fpga
gpu
even
asic
devices
reduce
synthesis
timing
overhead
related
work
mainstream
application-specific
architecture
hardware
accelerating
sat
problem
avoid
time-consuming
fpga
synthesis
time
implemented
boolean
constraint
propagation
computation
parallel
storage
literal-clause
instance
former
stored
data
using
embedded
dram
latter
relied
modern
fpga
block
ram
bram
relied
input/output
queue
provide
parallel
value
assignment
intensive
bcp
computation
done
parallel
partitioning
clause
set
several
subset
synchronization
scheme
also
proposed
conflict
detection
serial
type
architecture
problem
size
large
latter
one
since
size
bram
constraint
hardware
implementation
capacity
extended
64k
variables
176k
clauses
skliarova
implemented
application-specific
architecture
storing
whole
literal-clause
matrix
fpga
block
inference
conflict-detection
backtracking
implemented
based
orthogonal
matrix
multiplication
computations
done
hardware
implementation
backstracking
process
supported
stack
memory
handled
software
conclusion
paper
belief
propagation
algorithm
cnf-based
sat
problems
bpa-sat
presented
bpa-sat
based
belief
propagation
algorithm
bpa
used
decoding
class
error-correcting
codes
low-density
parity-check
ldpc
codes
since
bpa
implemented
hardware
bpa-sat
solver
accelerated
hardware
furthermore
time
complexity
bpa-sat
increase
size
sat
problems
therefore
speed
solver
degrade
dramatically
size
cnf
increases
main
issue
completeness
investigated
experimental
results
show
algorithm
also
completeness
decreases
significantly
size
cnf
increases
experimental
results
estimation
show
instants
bpa-sat
solve
bpa-sat
achieve
30×
44k×
speedup
compared
state-of-art
sat
solver
minisat
references
wagner
bertacco
post-silicon
runtime
verification
modern
processors
springer
december
2010
cook
complexity
theorem-proving
third
annual
acm
procedures
proceedings
symposium
theory
computing
pp.151-158
1971
russell
norvig
artificial
intelligence
modern
approach
prentice
hall
edition
december
2009
gallager
low
density
parity
check
codes
cambridge
mit
press
1963
een
sörensson
extensible
sat-solver
sat
pp.502–518
2003
mackay
neal
near
shannon
limit
performance
low
density
parity
check
codes
electronics
letters
1996
skliarova
brito
ferrari
reconfigurable
hardware
sat
solvers
survey
systems
computers
ieee
transactions
vol.53
no.11
1449-
1461
nov.
2004
moon
error
correction
coding
mathematical
methods
algorithms
john
wiley
sons
jun
2005
800
pages
lin
costello
error
control
coding
fundamentals
applications
2nd
pearson-prentice
hall
2004
1260
pages
davis
j.d.
tan
zhang
practical
reconfigurable
hardware
accelerator
boolean
satisfiability
solvers
design
automation
conference
2008.
dac
2008
45th
acm/ieee
vol.
no.
pp.780-785
8-13
june
2008
zhao
malik
moskewicz
madigan
application
accelerating
boolean
satisfiability
specific
processing
system
synthesis
2001.
proceedings
14th
international
symposium
vol.
no.
244-
249
2001
satlib
satisfiability
library
available
http
//www.cs.ubc.ca/~hoos/satlib/index-ubc.html
chen
kang
lin
akella
memory
system
optimization
fpga-based
implementation
quasi-
cyclic
ldpc
codes
decoders
circuits
systems
regular
papers
ieee
transactions
vol.58
no.1
pp.98-
111
jan.
2011
