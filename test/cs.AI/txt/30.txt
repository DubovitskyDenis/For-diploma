consideration
publication
theory
practice
logic
programming
conﬂict-driven
asp
solving
external
sources
thomas
eiter
michael
fink
thomas
krennwallner
christoph
redl∗
institut
f¨ur
informationssysteme
technische
universit¨at
wien
favoritenstraße
9-11
a-1040
vienna
austria
e-mail
eiter
fink
tkren
redl
kr.tuwien.ac.at
submitted
january
2003
revised
january
2003
accepted
january
2003
abstract
answer
set
programming
asp
well-known
problem
solving
approach
based
nonmonotonic
logic
programs
efﬁcient
solvers
enable
access
external
information
hex-programs
extend
programs
external
atoms
allow
bidirectional
communication
logic
program
external
sources
computation
e.g.
description
logic
reasoners
web
resources
current
solvers
evaluate
hex-programs
translation
asp
values
external
atoms
guessed
veriﬁed
ordinary
answer
set
computation
elegant
approach
scale
number
external
accesses
general
particular
presence
nondeterminism
instrumental
asp
paper
present
novel
native
algorithm
evaluating
hex-programs
uses
learning
techniques
particular
extend
conﬂict-driven
asp
solving
techniques
prevent
solver
running
conﬂict
ordinary
hex-programs
show
gain
additional
knowledge
external
source
evaluations
use
conﬂict-driven
algorithm
ﬁrst
target
uninformed
case
i.e.
extra
information
external
sources
extend
approach
case
additional
meta-information
available
experiments
show
learning
external
sources
signiﬁcantly
decrease
runtime
number
considered
candidate
compatible
sets
keywords
answer
set
programming
nonmonotonic
reasoning
conﬂict-driven
clause
learn-
ing
introduction
answer
set
programming
asp
declarative
programming
approach
niemel¨a
1999
marek
truszczy´nski
1999
lifschitz
2002
solutions
problem
correspond
answer
sets
gelfond
lifschitz
1991
logic
program
computed
using
asp
solver
approach
turned
thanks
expressive
efﬁcient
sys-
tems
like
smodels
simons
2002
dlv
leone
2006
assat
lin
zhao
2004
cmodels
giunchiglia
2006
clasp
gebser
2012
gebser
2011
fruitful
range
applications
brewka
2011
current
trends
distributed
systems
world
wide
web
instance
revealed
need
access
external
sources
program
ranging
light-weight
data
access
e.g.
xml
rdf
data
bases
knowledge-intensive
formalisms
e.g.
description
logics
cater
need
hex-programs
eiter
2005
extend
asp
called
research
supported
austrian
science
fund
fwf
project
p20840
p20841
p24090
vienna
science
technology
fund
wwtf
project
ict
08-020
eiter
external
atoms
user
couple
external
data
source
logic
program
roughly
atoms
pass
information
program
given
predicates
constants
external
source
returns
output
values
abstract
function
computes
extension
convenient
exploited
applications
different
areas
eiter
2011
also
expressive
since
recursive
data
exchange
logic
program
external
sources
possible
advanced
reasoning
applications
like
default
reasoning
description
logic
ontologies
eiter
2008
dao-
tran
2009
reasoning
nonmonotonic
multi-context
systems
brewka
eiter
2007
eiter
2010
take
advantage
current
algorithms
evaluating
hex-programs
use
translation
approach
rewrite
ordinary
asp
programs
idea
guess
truth
values
external
atoms
i.e.
whether
particular
fact
output
external
source
access
modiﬁed
program
computing
answer
sets
compatibility
test
checks
whether
guesses
coincide
actual
source
behavior
elegant
approach
bottleneck
advanced
applications
including
mentioned
scale
blind
guessing
leads
explosion
candidate
answer
sets
many
might
fail
compatibility
test
furthermore
blackbox
view
external
sources
disables
pruning
search
space
asp
translation
even
properties
would
known
sheer
impossible
make
use
ordinary
asp
evaluation
on-the-ﬂy
using
standard
solvers
overcome
bottleneck
new
evaluation
method
needed
paper
thus
present
novel
algorithm
evaluating
hex-programs
described
section
avoids
simple
asp
translation
approach
three
key
features
first
natively
builds
model
candidates
ﬁrst
principles
accesses
external
sources
already
model
search
allows
prune
candidates
early
second
considers
external
sources
longer
black
boxes
exploits
meta-knowledge
internals
third
takes
modern
sat
asp
solving
techniques
based
clause
learn-
ing
biere
2009
led
efﬁcient
conﬂict-driven
algorithms
answer-
set
computation
gebser
2012
drescher
2008
extends
external
sources
major
contribution
work
end
introduce
external
behavior
learning
ebl
generates
conﬂict
clauses
nogoods
external
source
evaluation
section
section
ﬁrst
uninformed
case
section
4.1
meta-information
external
source
available
except
certain
in-
put
generates
certain
output
exploit
meta-information1
external
sources
properties
monotonicity
functionality
learn
even
effective
nogoods
restrict
search
space
section
4.2
implemented
new
algorithm
incorporated
dlvhex
prototype
system.2
designed
extensible
fashion
provider
external
sources
specify
reﬁned
learning
functions
exploit
speciﬁc
knowledge
source
theoretical
work
conﬁrmed
experiments
conducted
prototype
synthetic
benchmarks
programs
motivated
real-world
applications
section
confused
semantically
annotated
data
considered
http
//www.kr.tuwien.ac.at/research/systems/dlvhex/
theory
practice
logic
programming
several
cases
signiﬁcant
performance
improvements
compared
previous
algorithm
obtained
shows
suitability
potential
new
approach
preliminaries
section
introduce
syntax
semantics
hex-programs
following
drescher
2008
conﬂict-driven
sat
answer
set
solving
start
basic
deﬁnitions
signed
literal
positive
negated
ground
atom
ground
atom
form
predicate
function-symbol
free
ground
terms
abbreviated
literal
let
denote
negation
i.e
assignment
ﬁnite
set
atoms
consistent
set
signed
literals
expresses
true
false
write
refer
set
elements
refer
extension
predicate
symbol
wrt
assignment
deﬁned
ext
let
a|q
set
signed
literals
atoms
form
list
predicates
let
a|q
a|q1
a|qk
nogood
set
signed
literals
assignment
solution
nogood
resp
set
nogoods
iff
resp
2.1
hex-programs
brieﬂy
recall
hex-programs
introduced
eiter
2005
gen-
eralization
disjunctive
extended
logic
programs
answer
set
semantics
gel-
fond
lifschitz
1991
details
background
refer
eiter
2005
syntax
hex-programs
extend
ordinary
asp
programs
external
atoms
enable
bidirectional
interaction
program
external
sources
computation
external
atoms
list
input
parameters
constants
predicate
names
list
output
parameters
informally
evaluate
external
atom
reasoner
passes
constants
extensions
predicates
input
tuple
external
source
associated
external
atom
plugged
reasoner
external
source
computes
output
tuple
matched
output
list
formally
ground
external
atom
form
constant
input
parameters
predicate
names
object
constants
constant
output
terms
ground
hex-programs
deﬁned
similar
ground
ordinary
asp
programs
deﬁnition
ground
hex-programs
ground
hex-program
consists
rules
form
bm+1
ground
atom
constants
either
classical
ground
atom
ground
external
atom.3
head
rule
body
simplicity
formally
introduce
strong
negation
see
classical
literals
form
new
atoms
together
constraint
disallows
simultaneously
true
eiter
bm+1
call
rule
body
default
literal
positive
body
bm+1
negative
body
sections
also
make
use
non-ground
programs
however
restrict
theoretical
investigation
ground
programs
suitable
safety
conditions
allow
application
grounding
procedure
eiter
2006
semantics
evaluation
semantics
ground
external
atom
wrt
assignment
given
value
1+k+l-ary
boolean
oracle
function
deﬁned
possible
values
thus
true
relative
holds
satisfaction
ordinary
rules
asp
programs
gelfond
lifschitz
1991
extended
hex-rules
programs
obvious
way
notion
extension
ext
external
predicates
input
lists
naturally
deﬁned
ext
answer
sets
hex-program
determined
dlvhex
solver
using
transformation
ordinary
asp
programs
follows
external
atom
replaced
ordinary
ground
replacement
atom
rule
added
program
answer
sets
resulting
guessing
pro-
gram
determined
ordinary
asp
solver
projected
non-replacement
atoms
however
resulting
assignments
necessarily
models
value
different
one
answer
set
thus
can-
didate
compatible
set
model
candidate
must
checked
external
sources
discrepancy
found
model
candidate
compatible
set
precisely
deﬁnition
compatible
set
compatible
set
program
assignment
answer
set
gelfond
lifschitz
1991
guessing
program
iff
external
atoms
i.e
guessed
values
coincide
actual
output
input
compatible
sets
computed
dlvhex
include
modulo
answer
sets
deﬁned
eiter
2005
using
flp
reduct
faber
2011
refer
flp-answer
sets
additional
test
candidate
answer
sets
easily
formulated
compatible
set
existence
variant
flp-answer
sets
obtained
default
dlvhex
computes
compatible
sets
smallest
true
part
original
atoms
leads
answer
sets
follows
deﬁnition
answer
set
dlvhex
answer
set
set
compatible
set
every
compatible
set
answer
sets
deﬁnition
include
flp-answer
sets
fact
often
coincide
examples
consider
computing
minimal
compatible
sets
thus
key
problem
hex-programs
focus
2.2
conﬂict-driven
clause
learning
nonchronological
backtracking
recall
dpll-style
sat
solvers
rely
alternation
drawing
deterministic
conse-
quences
guessing
truth
value
atom
towards
complete
interpretation
deter-
ministic
consequences
drawn
basic
operation
unit
propagation
i.e.
whenever
theory
practice
logic
programming
one
signed
literals
nogood
satisﬁed
last
one
must
false
solver
stores
integer
decision
level
written
postﬁx
signed
literal
atom
set
unit
propagation
gets
highest
decision
level
already
assigned
atoms
whereas
guessing
increments
current
decision
level
modern
sat
solver
conﬂict-driven
i.e.
learn
additional
nogoods
current
assignment
violates
nogood
prevents
solver
running
conﬂict
learned
nogood
determined
initially
setting
conﬂict
nogood
violated
one
long
contains
multiple
literals
decision
level
resolved
reason
one
literals
i.e.
nogood
implied
example
consider
nogoods
suppose
assignment
third
no-
good
unit
implies
violates
fourth
nogood
contains
multiple
literals
set
decision
level
resolved
reason
setting
false
nogood
results
nogood
contains
single
literal
set
decision
level
thus
learned
nogood
standard
clause
notation
nogood
set
corresponds
violated
clause
resolved
results
learned
clause
state-of-the-art
sat
asp
solvers
backtrack
second-highest
decision
level
learned
nogood
example
decision
level
assignments
decision
level
undone
variable
remains
assigned
makes
new
nogood
unit
derives
decision
level
2.3
conﬂict-driven
asp
solving
subsection
summarize
conﬂict-driven
disjunctive
answer-set
solving
gebser
2012
drescher
2008
corresponds
algorithm
hex-cdnl
without
part
section
also
discuss
part
subsequently
provide
summary
base
algorithm
details
refer
gebser
2012
drescher
2008
employ
conﬂict-driven
techniques
sat
solving
asp
programs
repre-
sented
sets
nogoods
program
let
set
atoms
occurring
let
set
rule
bodies
viewed
fresh
atoms
ﬁrst
deﬁne
set
nogoods
encode
set
default
literals
must
assigned
terms
conjunction
elements
conjunction
true
iff
literal
true
clark
completion
program
atoms
set
nogoods
r∈π
body
rule
true
iff
literal
true
body
true
head
literal
must
eiter
also
true
unless
program
tight
fages
1994
clark
completion
fully
capture
semantics
program
unfounded
sets
may
occur
i.e.
sets
atoms
cyclically
support
called
loop
avoidance
unfounded
sets
requires
additional
loop
nogoods
exponentially
many
introduced
on-the-ﬂy
disjunctive
programs
require
additional
concepts
neglecting
details
common
use
additional
nogoods
θsh
derived
shifted
program
encode
loop
formulas
singleton
loops
comprehensive
study
available
drescher
2008
concepts
ready
describe
basic
algorithm
answer
set
compu-
tation
shown
hex-cdnl
algorithm
keeps
set
θsh
static
nogoods
clark
completion
singular
loops
set
dynamic
nogoods
learned
conﬂicts
unfounded
sets
execution
constructing
assignment
algorithm
stores
atom
decision
level
decision
level
initially
incremented
choice
deterministic
consequences
set
assigned
values
decision
level
highest
decision
level
set
main
loop
iteratively
derives
deterministic
consequences
using
propagation
trying
complete
assignment
includes
unit
propagation
unfounded
set
prop-
agation
unit
propagation
derives
nogood
i.e
one
literal
nogood
satisﬁed
therefore
last
one
needs
falsiﬁed
unfounded
set
propagation
detects
atoms
cyclically
support
falsiﬁes
part
checks
conﬂict
i.e
violated
nogood
case
need
backtrack
purpose
use
analysis
compute
learned
nogood
backtrack
decision
level
learned
nogood
added
set
dynamic
no-
goods
assignments
decision
level
undone
otherwise
part
checks
assignment
complete
case
ﬁnal
unfounded
set
check
necessary
due
disjunctive
heads
candidate
founded
answer
set
otherwise
select
violated
loop
nogood
set
loop
nogoods
unfounded
set
deﬁnition
see
drescher
2008
conﬂict
analysis
backtrack
deterministic
consequences
derived
assignment
still
incomplete
need
guess
part
increment
decision
level
function
select
implements
variable
selection
heuristic
simplest
case
chooses
arbitrary
yet
unassigned
variable
state-of-the-art
heuristics
sophisticated
e.g.
goldberg
novikov
2007
prefer
variables
involved
recent
conﬂicts
algorithms
conﬂict-driven
hex-program
solving
present
new
genuine
algorithms
hex-program
evaluation
based
drescher
2008
integrate
additional
novel
learning
techniques
capture
semantics
external
atoms
term
learning
refers
process
adding
nogoods
nogood
set
search
space
explored
classically
derived
conﬂict
situations
avoid
similar
conﬂicts
search
described
add
second
type
learning
captures
behavior
external
sources
called
external
behavior
learning
ebl
whenever
external
atom
evaluated
algorithm
theory
practice
logic
programming
algorithm
hex-eval
input
hex-program
output
answer
sets
ext
atoms
replaced
add
guessing
rules
replacement
atoms
set
dynamic
nogoods
set
compatible
sets
inconsistent
false
inconsistent
false
←hex-cdnl
inconsistent
true
else
compatible
true
external
atoms
evaluate
let
add
compatible
false
compatible
inconsistent
false
compatible
set
algorithm
hex-cdnl
input
program
guessing
program
set
correct
nogoods
∇ofπ
output
answer
set
candidate
compatible
set
solution
nogoods
none
exists
decision
level
true
propagation
θsh
return
analysis
else
at∪af=a
∪ba
∪ba
unfoundedset
let
return
analysis
else
return
else
heuristic
decides
evaluate
evaluate
set
return
⊆-minimal
else
select
might
learn
call
information
internals
source
may
learn
general
input-output-relationships
information
learn
effective
nogoods
general
associate
learning-function
external
source
sake
introducing
evaluation
algorithms
however
section
abstractly
consider
set
nogoods
learned
evaluation
external
predicate
input
list
evaluated
assignment
denoted
next
section
provide
deﬁnitions
particular
nogoods
learned
various
types
external
sources
i.e.
instantiate
crucial
require-
ment
learned
nogoods
correctness
intuitively
holds
nogood
added
without
eliminating
compatible
sets
deﬁnition
correct
nogoods
nogood
correct
wrt
program
compatible
sets
solutions
subsequent
exposition
assume
program
clear
context
overall
approach
consists
two
parts
first
hex-cdnl
computes
model
candidates
essentially
ordinary
asp
solver
includes
calls
external
sources
order
learn
additional
nogoods
external
calls
algorithm
required
correct-
ness
algorithm
may
inﬂuence
performance
dramatically
discussed
sec-
tion
second
algorithm
hex-eval
uses
algorithm
hex-cdnl
produce
model
can-
didates
checks
external
sources
followed
minimality
check
external
calls
crucial
correctness
algorithm
computing
model
candidate
hex-cdnl
basically
employs
conﬂict-driven
ap-
proach
presented
drescher
2008
summarized
section
main
dif-
eiter
ference
addition
part
extension
driven
following
idea
whenever
unit
unfounded
set
propagation
derive
atoms
assignment
still
incomplete
algorithm
possibly
evaluates
external
atoms
driven
heuristic
instead
simply
guessing
truth
values
might
lead
addition
new
nogoods
turn
cause
propagation
procedure
derive
atoms
guessing
truth
values
becomes
necessary
deterministic
conclusions
drawn
evaluation
external
atoms
yield
nogoods
guessing
also
occurs
heuristic
decide
evaluate
formal
treatment
let
set
external
predicates
input
list
occur
let
set
signed
literals
atoms
learning
function
mapping
22d
extend
notion
correct
nogoods
correct
learning
functions
follows
deﬁnition
learning
function
correct
program
iff
correct
restricting
learning
functions
correct
following
results
hold
proposition
input
hex-cdnl
returns
interpretation
answer
set
solution
compatible
set
solution
proof
sketch
proof
mainly
follows
drescher
2008
algorithm
potentially
nogoods
never
produce
answer
sets
elim-
inate
hence
produced
interpretation
answer
set
com-
pleteness
drescher
2008
need
justify
adding
evaluation
eliminate
compatible
sets
purpose
need
show
one
added
nogoods
ﬁres
interpretation
incompatible
external
sources
anyway
follows
correctness
derived
nogoods
completeness
drescher
2008
basic
idea
hex-eval
compute
compatible
sets
loop
checking
subset-minimality
afterwards
computing
compatible
sets
loop
uses
hex-cdnl
compute
answer
sets
i.e.
candidate
compatible
sets
subsequently
checks
compatibility
external
atom
external
calls
crucial
correctness
however
different
translation
approach
ex-
ternal
source
evaluation
serves
compatibility
checking
also
generating
additional
dynamic
nogoods
part
following
result
proposition
hex-eval
computes
answer
sets
proof
sketch
ﬁrst
show
loop
yields
termination
compatible
set
solution
stage
entering
loop
iff
compatible
set
exist
yields
iff
compatible
set
exists
suppose
loop
assigned
returned
hex-cdnl
proposition
follows
answer
set
solution
thus
deﬁnition
holds
compatible
true
loop
guarantees
compatibility
external
sources
deﬁnition
source
output
input
compatible
guess
rejected
added
theory
practice
logic
programming
nogood
otherwise
coincides
behavior
external
sources
i.e.
satisﬁes
deﬁnition
thus
compatible
set
wrt
call
time
correct
nogoods
added
also
compatible
set
wrt
initial
set
otherwise
loop
inconsistent
true
means
call
hex-cdnl
returned
proposition
answer
set
solution
correct
nogoods
added
exists
also
answer
set
solution
original
set
thus
loop
operates
desired
loop
enumerates
one
one
compatible
sets
terminates
update
prevents
recomputing
thus
number
compatible
sets
decreases
deﬁnition
answer
sets
compatible
sets
subset-minimal
true
part
original
literals
overall
algorithm
correctly
outputs
answer
sets
example
let
empty
external
atom
one
nonmonotonic
predicate
input
output
extension
empty
otherwise
consider
program
consisting
rules
dom
dom
dom
dom
empty
algorithm
hex-eval
transforms
guessing
program
ˆπe
dom
dom
dom
dom
empty
empty
empty
dom
traditional
evaluation
strategy
without
learning
produce
model
candi-
dates
hex-cdnl
subsequently
checked
hex-eval
instance
guess
cid:8
tne
empty
empty
tne
empty
cid:9
leads
model
candidate
cid:8
tne
empty
empty
tne
empty
cid:9
neglecting
false
atoms
facts
also
model
candiate
passes
compatibility
check
always
true
therefore
empty
must
also
true
due
deﬁnition
external
atom
allows
deriving
ﬁrst
rule
program
atoms
false
due
minimality
answer
sets
effects
additionally
learned
nogoods
discussed
section
formally
speciﬁed
concrete
various
types
external
sources
nogoods
external
behavior
learning
discuss
nogoods
generated
external
behavior
learning
ebl
detail
ebl
triggered
external
source
evaluations
instead
conﬂicts
basic
idea
integrate
knowledge
external
source
behavior
program
guide
search
program
evaluation
starts
empty
set
learned
nogoods
preprocessor
generates
guessing
rule
ground
external
atom
discussed
section
fur-
ther
nogoods
added
evaluation
information
external
sources
becomes
available
contrast
traditional
evaluation
external
atoms
assigned
arbitrary
truth
values
checked
assignment
completed
ﬁrst
show
construct
useful
learned
nogoods
evaluating
external
atoms
information
internals
external
sources
called
un-
informed
learning
case
learn
simple
input/output
relationships
subse-
quently
consider
informed
learning
additional
information
properties
external
sources
available
allows
using
elaborated
learning
strategies
eiter
table
learned
nogoods
example
tne
empty
learned
nogood
guess
cid:27
empty
cid:26
empty
tne
empty
cid:26
empty
tne
empty
cid:27
empty
cid:27
cid:26
empty
empty
cid:26
empty
empty
cid:27
empty
empty
empty
tne
empty
empty
4.1
uninformed
learning
ﬁrst
assume
information
internals
consider
external
sources
black
boxes
hence
apply
general
rules
learning
when-
ever
external
predicate
input
list
evaluated
assignment
learn
input
a|p
external
atom
produces
output
ext
formalized
following
set
nogoods
deﬁnition
learning
function
general
external
predicate
input
list
program
assignment
deﬁned
cid:8
a|p
ext
cid:9
simplest
case
external
atom
input
learned
nogoods
unary
i.e.
form
thus
learned
certain
tuples
output
external
source
i.e
must
false
external
sources
input
predicates
added
rules
encode
relationship
output
tuples
provided
input
example
ctd
recall
example
without
learning
algorithms
produce
model
candidates
check
subsequently
turns
ebl
allows
falsiﬁ-
cation
guesses
without
actually
evaluating
external
atoms
suppose
reasoner
ﬁrst
tries
guesses
containing
literal
empty
checked
external
sources
described
learning
function
allows
adding
exter-
nally
learned
nogoods
shown
table
observe
combination
reconstructed
also
different
choices
guessing
variables
fact
true
independent
choice
empty
empty
e.g.
guess
empty
empty
empty
leads
extension
allows
reusing
nogood
immediately
invalidated
without
evaluating
external
atoms
different
guesses
input
external
source
allow
reusing
learned
nogoods
latest
candidate
complete
ex-
ternal
source
called
validation
however
often
learning
allows
discarding
guesses
even
earlier
instance
derive
empty
no-
goods
resolution
steps
derived
nogoods
learned
running
couple
conﬂicts
derive
empty
even
truth
value
empty
set
i.e.
external
learning
guides
search
traditional
eval-
uation
algorithm
considers
behavior
external
sources
postprocessing
theory
practice
logic
programming
next
result
let
program
contains
external
atom
form
lemma
assignments
nogoods
def
correct
wrt
proof
sketch
added
nogood
output
tuple
ext
contains
a|p
negated
replacement
atom
nogood
ﬁres
guess
wrong
replacement
atom
guessed
false
tuple
output
hence
interpretation
compatible
answer
set
anyway
4.2
informed
learning
learned
nogoods
form
become
quite
large
include
whole
input
external
source
however
known
properties
external
sources
ex-
ploited
order
learn
smaller
general
nogoods
example
one
input
parameters
external
source
monotonic
necessary
include
informa-
tion
false
atoms
extension
output
shrink
given
larger
input
properties
informed
learning
stated
level
either
predicates
indi-
vidual
external
atoms
former
means
usages
predicate
property
understand
consider
predicate
union
takes
two
predicate
inputs
computes
set
elements
least
one
extensions
always
monotonic
parameters
independently
usage
program
external
source
may
lack
property
general
may
hold
particular
usages
example
consider
external
atom
query
interface
sql
query
processor
evaluates
given
query
given
string
tables
rela-
tions
provided
predicates
general
atom
nonmonotonic
special
queries
e.g.
simple
selection
tuples
monotonic
next
discuss
two
particular
cases
informed
learning
customize
default
learning
function
generic
external
sources
exploiting
properties
external
sources
ﬁnally
present
examples
learning
user-deﬁned
nogoods
might
useful
monotonic
atoms
parameter
external
atom
called
monotonic
implies
a′|pi
a|pi
a′|p′
a|p′
learned
nogoods
evaluating
required
include
fpi
monotonic
external
predicate
in-
put
list
monotonic
input
parameters
nonmonotonic
parameters
set
learned
nogoods
restricted
follows
deﬁnition
learning
function
external
predicate
input
list
pro-
gram
assignment
monotonic
deﬁned
a|pm
a|pn
ext
example
consider
external
atom
diﬀ
computes
set
el-
ements
extension
extension
suppose
evaluated
s.t
ext
ext
output
atom
ext
diﬀ
naively
learned
nogood
diﬀ
however
due
monotonicity
diﬀ
necessary
include
nogood
eiter
output
external
source
shrink
even
becomes
true
therefore
general
nogood
diﬀ
sufﬁces
correctly
describe
input-output
behavior
functional
atoms
evaluating
functional
assignment
one
output
tuple
contained
ext
formally
assignments
therefore
follow-
ing
nogoods
may
added
right
beginning
deﬁnition
learning
function
functional
external
predicate
input
list
program
assignment
deﬁned
cid:8
cid:9
however
implementation
learning
rule
generate
pairs
output
tuples
beforehand
instead
memorizes
generated
output
tuples
evaluation
external
sources
whenever
new
output
tuple
added
also
adds
nogoods
force
previously
derived
output
tuples
false
example
consider
rules
concat
strings
dom
strings
dom
concat
true
iff
string
concatenation
strings
observe
external
atom
involved
cycle
negation
extension
domain
dom
large
many
ground
instances
external
atom
gener-
ated
old
evaluation
algorithm
guesses
truth
values
completely
uninformed
e.g.
concat
replacement
atom
concat
dom
dom
supposed
facts
guess
set
randomly
true
false
independent
previous
guesses
contrast
learning
external
sources
algorithm
learns
ﬁrst
evaluation
concat
must
true
knowing
concat
functional
atoms
concat
must
also
false
next
result
let
program
contains
external
atom
form
lemma
assignments
nogoods
def
correct
wrt
functional
nogoods
def
correct
wrt
proof
sketch
monotonic
external
sources
must
show
negative
input
literals
monotonic
parameters
removed
learned
nogoods
without
affecting
correctness
uninformed
learning
argued
output
tuple
ext
replacement
atom
must
guessed
false
input
a|p
assignment
however
output
grows
monotonically
extension
monotonic
parameter
applies
larger
i.e.
a′|p
a|p
consequently
a′|p
a|p
hence
negative
literals
relevant
wrt
output
tuple
removed
nogood
functional
must
show
nogoods
cid:8
cid:9
correct
due
functionality
external
source
return
one
output
tu-
ple
input
therefore
guess
answer
set
compatible
hence
nogoods
eliminate
possible
answer
sets
theory
practice
logic
programming
user-deﬁned
learning
many
cases
developer
external
atom
in-
formation
internal
behavior
allows
deﬁning
effective
nogoods
therefore
beneﬁcial
give
user
possibility
customize
learning
functions
currently
user-deﬁned
functions
need
directly
specify
learned
nogoods
de-
velopment
user-friendly
language
writing
learning
functions
subject
future
work
example
consider
program
guesses
set
nodes
subgraphs
complete
graph
suppose
checks
edge
selection
transitively
closed
case
output
empty
otherwise
set
missing
transitive
edges
returned
instance
extension
output
edge
missing
order
make
graph
transitively
closed
second
rule
eliminates
subgraphs
transitively
closed
note
nonmonotonic
guessing
program
n−1
naive
implementation
guesses
nodes
subgraphs
checks
tran-
sitive
closure
costly
consider
domain
checking
one
selection
know
selection
con-
taining
three
literals
transitively
closed
formalized
user-
deﬁned
learning
function
suppose
checked
ﬁrst
guess
compared
nogood
learned
gen-
eral
learning
function
nogood
general
description
conﬂict
reason
containing
relevant
edges
immediately
violated
future
guesses
containing
avoided
example
linearity
useful
learning
function
diﬀ
following
whenever
element
belongs
output
external
atom
user-deﬁned
function
works
elementwise
produces
nogoods
three
literals
call
property
linearity
contrast
naive
learning
function
section
4.1
includes
complete
extensions
nogoods
less
general
user-deﬁned
learning
correctness
learning
function
must
asserted
implementation
evaluation
integrated
clasp
reasoner
dlvhex
previous
versions
dlvhex
used
dlv
order
learn
nogoods
external
sources
exploit
clasp
smt
inter-
face
previously
used
special
case
constraint
answer
set
solving
implemented
clingcon
system
gebser
2009
ostrowski
schaub
2012
compare
three
conﬁgurations
dlvhex
dlv
backend
dlvhex
conﬂict-
driven
clasp
backend
without
ebl
dlvhex
clasp
backend
ebl
eiter
experiments
used
variants
examples
dlvhex
test
suite
default
reasoning
ontologies
appeared
learning
high
potential
re-
duce
number
candidate
models
also
number
total
variable
assignments
backtracks
search
decreased
drastically
many
cases
suggests
candidate
rejection
often
needs
parts
interpretations
possible
early
evaluation
benchmarks
carried
machine
two
12-core
amd
opteron
6176
cpus
128
ram
running
linux
using
clasp
2.0.5
dlv
dec
2011
solver
backends
benchmark
instance
average
three
runs
calculated
timeout
300
seconds
memout
run
report
runtime
seconds
gains
speedups
given
factor
set
partitioning
following
program
partitions
set
two
subsets
|s1|
partitioning
criterion
expressed
two
rules
implementation
use
external
atom
diﬀ
example
dom
dom
nsel
dom
diﬀ
dom
sel
sel
dom
diﬀ
dom
nsel
sel
sel
sel
results
table
compare
run
reasoner
different
conﬁgurations
computing
models
resp
ﬁrst
model
cases
using
conﬂict-driven
clasp
reasoner
instead
dlv
backend
already
improves
efﬁciency
adding
ebl
leads
improvement
case
formerly
exponentially
growing
runtime
becomes
almost
constant
computing
answer
sets
runtime
still
exponential
expo-
nentially
many
subset
choices
must
considered
due
encoding
however
also
case
many
pruned
early
learning
makes
runtime
appear
linear
shown
range
instance
sizes
moreover
experiments
show
delay
models
decreases
time
ebl
used
shown
table
constant
without
ebl
due
generation
additional
nogoods
default
reasoning
description
logic
ontologies
consider
re-
alistic
scenario
using
dl-plugin
eiter
2008
dlvhex
integrates
description
logics
knowledge
bases
nonmonotonic
logic
programs
dl-
plugin
allows
access
ontology
using
description
logic
reasoner
racerpro
1.9.0
http
//www.racer-systems.com/
ﬁrst
experiment
consider
program
shown
left
terminological
part
knowledge
base
right
birds
bird
ﬂies
birds
neg
ﬂies
flier
¬nonflier
penguin
bird
neg
ﬂies
birds
flier
ﬂies
¬flier
penguin
nonflier
encoding
realizes
classic
tweety
bird
example
using
dl-atoms
al-
ternative
syntax
external
atoms
example
allows
express
queries
description
logics
accessible
way
ontology
states
flier
disjoint
nonflier
penguins
birds
rules
express
birds
default
i.e.
unless
contrary
derived
program
amounts
ω-transformation
default
logic
ontologies
dl-programs
dao-tran
2009
last
rule
ensures
consistency
guess
ontology
assertional
part
knowledge
base
contains
penguin
tweety
ﬂies
tweety
inconsistent
theory
practice
logic
programming
table
benchmark
results
runtime
seconds
timeout
300s
set
partitioning
bird-penguin
elements
dlv
models
clasp
clasp
w/o
ebl
ebl
ﬁrst
model
dlv
clasp
clasp
w/o
ebl
ebl
individuals
dlv
clasp
clasp
w/o
ebl
ebl
0.07
0.20
12.98
38.51
89.46
218.49
0.07
0.10
0.17
0.19
0.19
0.20
0.28
0.08
0.16
9.56
21.73
49.51
111.37
262.67
0.45
0.42
0.54
0.08
0.08
0.56
0.93
1.69
3.53
8.76
128.79
0.07
0.08
0.28
0.63
1.13
2.31
3.69
62.58
95.39
91.16
0.07
0.07
0.07
0.08
0.08
0.10
0.10
0.12
0.10
0.11
0.50
1.90
4.02
8.32
16.11
33.29
83.75
229.20
0.15
1.98
4.28
7.95
16.39
34.35
94.62
230.75
0.14
0.59
0.25
0.60
0.29
0.35
0.42
4.45
1.10
2.70
wine
ontology
mcs
concept
completion
clasp
w/o
ebl
clasp
max
ebl
gain
avg
contexts
dlv
clasp
clasp
w/o
ebl
ebl
33.02
6.93
16.05
5.78
11.82
4.27
10.09
4.02
6.83
2.87
5.22
2.34
2.83
1.52
1.81
1.14
1.88
1.08
0.07
1.04
0.23
2.63
8.71
0.05
0.68
0.15
1.44
4.39
0.04
0.14
0.05
0.12
0.17
instance
wine
wine
wine
wine
wine
wine
wine
wine
wine
given
dl-program
neg
ﬂies
tweety
derived
monotonicity
atoms
ﬂies
tweety
loses
support
note
defaults
encoded
standard
monotonic
description
logics
achieved
cyclic
interaction
dl-rules
knowledge
base
individuals
appear
extension
predicate
ﬂier
consid-
ered
simultaneously
requires
guess
ability
individual
subsequent
check
leading
combinatorial
explosion
intuitively
however
property
determined
individual
independently
hence
query
may
split
independent
subqueries
achieved
learning
function
linear
sources
example
learned
nogoods
smaller
candidate
models
eliminated
table
shows
runtime
different
numbers
individuals
evaluation
without
ebl
runs
ebl
exhibit
signiﬁcant
speedup
exclude
many
model
candidates
whereas
performance
dlv
clasp
backend
without
ebl
almost
identical
unlike
ﬁrst
example
time
spent
calling
description
logic
reasoner
evaluation
logic
program
ﬁndings
carry
large
ontologies
knowledge
bases
used
real-world
applications
similar
experiments
scaled
version
wine
ontology
http
//kaon2.semanticweb.org/download/test
ontologies.zip
instances
differ
size
abox
ranging
247
individuals
wine
20007
wine
several
eiter
parameters
e.g.
number
concept
inclusions
concept
equivalences
motik
sattler
2006
describe
particular
instances
wine
implemented
number
default
rules
using
analogous
encoding
e.g.
wines
derivable
dry
dry
wines
sweet
assumed
dry
wines
white
default
unless
known
red
discuss
results
latter
scenario
experiments
classiﬁed
wines
main
concepts
ontology
immedi-
ate
subconcepts
concept
wine
e.g.
dessertwine
italianwine
varying
numbers
known
concept
memberships
e.g.
ranging
average
wine
percentiles
red
wines
among
100
average
results
summarized
table
entries
concept
comple-
tion
state
number
classiﬁed
concepts
almost
difference
dlv
clasp
backend
without
ebl
ebl
leads
signiﬁcant
improvement
concepts
ontology
sizes
e.g.
gain
concepts
wine
runs
ebl
exploit
linearity
furthermore
observed
additional
instances
solved
within
300
seconds
time
limit
concept
could
classiﬁed
without
ebl
could
observe
gain
33.02
average
6.93
expected
larger
categories
proﬁt
ebl
reuse
learned
nogoods
instances
besides
dao-tran
2009
describe
transformations
default
rules
description
logics
experiments
transformations
revealed
structure
resulting
hex-programs
prohibits
effective
reuse
learned
nogoods
hence
overall
picture
show
signiﬁcant
gain
ebl
encodings
could
however
still
observe
small
improvement
runs
multi-context
systems
mcs
mcs
brewka
eiter
2007
formalism
inter-
linking
multiple
knowledge-based
systems
contexts
eiter
2010
deﬁne
incon-
sistency
explanations
mcs
present
system
ﬁnding
explanations
top
dlvhex
benchmarks
computed
explanations
inconsistent
multi-
context
systems
contexts
number
computed
average
runtime
several
instances
different
topologies
tree
zigzag
diamond
ran-
domly
created
available
benchmark
generator
report
results
table
unlike
previous
benchmark
could
already
observe
speedup
1.98
using
clasp
instead
dlv
backend
two
reasons
ﬁrst
clasp
efﬁcient
dlv
given
problem
second
clasp
tightly
integrated
dlvhex
whereas
using
dlv
requires
interprocess
communication
however
important
aspect
ebl
leads
signiﬁcant
speedup
factor
25.82
compared
clasp
without
ebl
logic
puzzles
another
experiment
concerns
logic
puzzles
encoded
sudoku
hex-program
logic
program
makes
guess
assignments
ﬁelds
external
atom
used
verifying
answer
case
negative
veriﬁcation
result
external
atom
indicates
user-deﬁned
learning
rules
reason
inconsistency
encoded
pair
assignments
ﬁelds
contradict
one
uniqueness
rules
expected
instances
times
without
ebl
logic
program
information
rules
puzzle
blindly
guesses
assignments
subsequently
checked
external
atom
ebl
sudoku
instances
could
solved
several
seconds
theory
practice
logic
programming
details
experiments
links
benchmarks
benchmark
generators
found
http
//www.kr.tuwien.ac.at/research/systems/dlvhex/experiments.html
discussion
conclusion
basic
idea
algorithm
related
constraint
asp
solving
presented
geb-
ser
2009
ostrowski
schaub
2012
realized
clingcon
system
external
atom
evaluation
algorithm
superﬁcially
regarded
con-
straint
propagation
however
gebser
2009
ostrowski
schaub
2012
consider
particular
application
deal
abstract
interface
external
sources
important
difference
clingcon
ebl
constraint
solver
seen
black
box
whereas
exploit
known
properties
external
sources
moreover
support
user-deﬁned
learning
i.e.
customization
default
construction
conﬂict
clauses
incorporate
knowledge
sources
discussed
section
another
dif-
ference
construction
conﬂict
clauses
asp
special
constraint
atoms
may
contradictory
e.g.
learned
clauses
sets
constraint
literals
kept
small
possible
algorithm
usu-
ally
conﬂicts
ground
external
atoms
output
atoms
mostly
independent
excepting
e.g
functional
sources
instead
strong
relationship
input
output
reﬂected
conﬂict
clauses
usually
con-
sist
relevant
input
atoms
negation
one
output
atom
constraint
asp
solving
key
efﬁciency
keeping
conﬂict
clauses
small
extended
conﬂict-driven
asp
solving
techniques
ordinary
asp
hex-
programs
allow
using
external
atoms
access
external
sources
approach
uses
two
types
learning
classical
type
conﬂict-driven
clause
learning
derives
conﬂict
nogoods
conﬂict
situations
search
tree
traversed
adding
nogoods
prevents
algorithm
running
similar
conﬂicts
main
contribution
second
type
learning
call
external
behavior
learning
ebl
whenever
external
atoms
evaluated
nogoods
may
added
capture
parts
external
source
behavior
simplest
case
nogoods
encode
certain
input
source
leads
certain
output
default
learning
function
customized
learn
shorter
general
nogoods
customization
either
done
explicitly
user
learning
functions
derived
automatically
known
properties
external
atoms
stated
either
level
external
predicates
level
atoms
currently
exploit
monotonicity
functionality
future
work
includes
identiﬁcation
properties
allow
automatic
derivation
learning
functions
plan
development
user-friendly
lan-
guage
writing
user-deﬁned
learning
functions
currently
require
specify
learned
nogoods
hand
may
convenient
write
rules
certain
input
external
source
leads
certain
output
restricted
variant
asp
con-
venient
language
challenge
evaluation
learning
rules
introduces
additional
overhead
hence
another
tradeoff
costs
beneﬁt
ebl
finally
also
development
heuristics
lazy
evaluation
external
sources
subject
future
work
eiter
references
biere
heule
van
maaren
walsh
eds
2009.
handbook
satisﬁability
frontiers
artiﬁcial
intelligence
applications
vol
185.
ios
press
brewka
eiter
2007.
equilibria
heterogeneous
nonmonotonic
multi-context
systems
aaai
aaai
press
385–390
brewka
eiter
truszczy
´nski
2011.
answer
set
programming
glance
commun
acm
92–103
dao-tran
eiter
krennwallner
2009.
realizing
default
logic
descrip-
tion
logic
knowledge
bases
ecsqaru
springer
602–613
drescher
gebser
grote
kaufmann
¨onig
ostrowski
schaub
2008.
conﬂict-driven
disjunctive
answer
set
solving
aaai
press
422–
432.
eiter
fink
ianni
krennwallner
sch
¨uller
2011.
pushing
efﬁcient
evaluation
hex
programs
modular
decomposition
lpnmr
springer
93–106
eiter
fink
sch
¨uller
weinzierl
2010.
finding
explanations
incon-
sistency
multi-context
systems
aaai
press
329–339
eiter
ianni
krennwallner
schindlauer
2008.
exploiting
conjunctive
queries
description
logic
programs
ann
math
artif
intell
1–4
115–152
eiter
ianni
lukasiewicz
schindlauer
tompits
2008.
combining
answer
set
programming
description
logics
semantic
web
artif
intell
172
12-13
1495–1539
eiter
ianni
schindlauer
tompits
2005.
uniform
integration
ijcai
higher-order
reasoning
external
evaluations
answer-set
programming
professional
book
center
90–96
eiter
ianni
schindlauer
tompits
2006.
effective
integration
declar-
ative
rules
external
evaluations
semantic-web
reasoning
eswc
springer
273–
287.
faber
leone
pfeifer
2011.
semantics
complexity
recursive
aggregates
answer
set
programming
artif
intell
175
278–298
fages
1994.
consistency
clark
completion
existence
stable
models
meth
logic
comp
sci
51–60
gebser
kaufmann
kaminski
ostrowski
schaub
schneider
2011.
potassco
potsdam
answer
set
solving
collection
commun
107–124
gebser
kaufmann
schaub
2012.
conﬂict-driven
answer
set
solving
theory
practice
artif
intell
187-188
52–89
gebser
ostrowski
schaub
2009.
constraint
answer
set
solving
iclp
springer
235–249
gelfond
lifschitz
1991.
classical
negation
logic
programs
disjunctive
databases
new
generat
comput
3–4
365–386
giunchiglia
lierler
maratea
2006.
answer
set
programming
based
propositional
satisﬁability
autom
reason
345–377
goldberg
novikov
2007.
berkmin
fast
robust
sat-solver
discrete
appl
math
155
1549–1561
leone
pfeifer
faber
eiter
gottlob
perri
scarcello
2006.
dlv
system
knowledge
representation
reasoning
acm
trans
comput
logic
499–562
lifschitz
2002.
answer
set
programming
plan
generation
artif
intell
138
39–54
lin
zhao
2004.
assat
computing
answer
sets
logic
program
sat
solvers
artif
intell
157
1–2
115–137
theory
practice
logic
programming
marek
truszczy
´nski
1999.
stable
models
alternative
logic
program-
ming
paradigm
logic
programming
paradigm
springer
375–398
motik
sattler
2006.
comparison
reasoning
techniques
querying
large
description
logic
aboxes
lpar
springer
227–241
niemel
1999.
logic
programming
stable
model
semantics
constraint
programming
paradigm
ann
math
artif
intell
3–4
241–273
ostrowski
schaub
2012.
asp
modulo
csp
clingcon
system
theor
pract
log
prog.
special
issue
28th
intl
conf
logic
programming
appear
simons
niemel
soininen
2002.
extending
implementing
stable
model
semantics
artif
intell
138
1-2
181–234
