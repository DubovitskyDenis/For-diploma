consideration
publication
theory
practice
logic
programming
disjunctive
datalog
existential
quantiﬁers
semantics
decidability
complexity
issues
mario
alviano
wolfgang
faber
nicola
leone
marco
manna∗
department
mathematics
university
calabria
italy
e-mail
alviano
faber
leone
manna
mat.unical.it
submitted
january
2003
revised
january
2003
accepted
january
2003
abstract
datalog
one
best-known
rule-based
languages
extensions
used
wide
context
applications
important
datalog
extension
disjunctive
datalog
signiﬁcantly
increases
expressivity
basic
language
disjunctive
datalog
useful
wide
range
applications
ranging
databases
e.g.
data
integration
artiﬁcial
intelligence
e.g.
diagnosis
planning
incomplete
knowledge
however
recent
years
important
shortcoming
datalog-based
languages
became
evident
e.g
context
data-integration
consistent
query-answering
ontology-based
data
access
semantic
web
applications
language
permit
generation
reasoning
unnamed
individuals
obvious
way
general
weak
supporting
many
cases
existential
quantiﬁcation
overcome
problem
datalog∃
recently
proposed
extends
traditional
datalog
existential
quantiﬁcation
rule
heads
work
propose
natural
extension
disjunctive
datalog
datalog∃
called
datalog∃
allows
disjunctions
existential
quantiﬁcation
rule
heads
therefore
attractive
language
knowledge
representation
reasoning
especially
domains
ontology-based
reasoning
needed
formally
deﬁne
syntax
semantics
language
datalog∃
provide
notion
instantiation
prove
adequate
datalog∃
main
issue
datalog∃
hence
also
datalog∃
decidability
longer
guaranteed
typical
reasoning
tasks
order
address
issue
identify
many
decidable
fragments
language
extend
natural
way
analog
classes
deﬁned
non-disjunctive
case
moreover
carry
in-depth
complexity
analysis
deriving
interesting
results
range
logarithmic
space
exponential
time
appear
theory
practice
logic
programming
keywords
datalog
non-monotonic
reasoning
decidability
complexity
introduction
datalog
origins
query
language
database
systems
language
particular
extensions
well
gone
beyond
original
scope
used
variety
applications
see
example
moor
2011
marco
manna
work
supported
european
commission
european
social
fund
calabria
region
alviano
faber
leone
manna
datalog∨
eiter
1997
extension
datalog
rule
heads
may
disjunctions
atoms
proved
especially
rewarding
context
allows
representation
concepts
like
incomplete
knowledge
nonde-
terministic
eﬀects
simple
intuitive
way
examples
use
datalog∨
span
planning
eiter
2004
data-integration
leone
2005
reasoning
ontologies
hustadt
2004
concerning
ontologies
observe
ﬁeld
ontology-based
query
answer-
ing
thriving
data
knowledge
management
calvanese
2007
cal
2009
kollia
2011
cal
2011
companies
ora-
cle
adding
ontological
reasoning
modules
top
existing
software
context
queries
merely
evaluated
extensional
relational
database
logical
theory
combining
ontological
theory
speciﬁcally
describes
rules
constraints
inferring
intensional
knowledge
data
stored
johnson
klug
1984
thus
conjunctive
query
checked
whether
entails
rather
whether
key
issue
ontology-based
design
language
used
specifying
ontological
theory
end
datalog±
family
extensions
datalog
proposed
cal
2009
tractable
ontologies
recently
gained
increasing
interest
mugnier
2011
family
generalizes
well-known
ontology
speciﬁcation
languages
mainly
based
datalog∃
extension
datalog
allows
existentially
quantiﬁed
variables
rule
heads
paper
propose
extension
datalog
allows
disjunctions
existentially
quantiﬁed
variables
rule
heads
called
datalog∃
language
highly
expressive
enables
easy
powerful
knowledge-modeling
combining
ability
disjunction
deal
incomplete
information
power
existential
quantiﬁers
generate
unnamed
individuals
deal
example
consider
scenario
animal
either
carnivore
herbivore
carnivore
preys
least
one
animal
knowledge
modeled
following
datalog∃
rules
left-hand
side
equivalent
ontological
terms
right-hand
side
carnivore
herbivore
animal
preys
carnivore
animal
preys
animal
carnivore
herbivore
carnivore
∃preys.⊤
∃preys−1.⊤
animal
general
datalog∃
allows
naturally
encode
advanced
ontology
properties
role
transitivity
role
hierarchy
role
inverse
concept
products
union
con-
cepts
deﬁne
syntax
language
provide
formal
semantics
datalog∃
programs
since
datalog∃
undecidable
general
case
undecidable
already
subclass
datalog∃
identify
num-
ber
datalog∃
fragments
decidable
lifting
disjunctive
case
several
decidability
results
proved
cal
2009
moreover
analyze
complexity
datalog∃
varying
diﬀerent
parameters
speciﬁcally
main
contributions
following
deﬁne
novel
language
datalog∃
extending
datalog∃
datalog∨
provide
formal
deﬁnition
language
also
specify
datalog∃
semantics
decidability
complexity
issues
notion
universal
model
set
generalizes
concept
universal
model
disjunctive
case
universal
model
set
allows
answering
query
deﬁne
new
concept
instantiation
inst
datalog∃
program
show
adequate
ﬁniteness
inst
suﬃcient
condition
ensure
decidability
since
one
compute
ﬁnite
model
set
inst
case
design
procedure
computing
inst
prove
generalizes
oblivious
chase
procedure
introduced
maier
1979
johnson
klug
1984
deﬁne
classes
guarded
linear
weakly
guarded
datalog∃
pro-
grams
show
extend
corresponding
classes
datalog∃
pro-
grams
checking
membership
classes
doable
polynomial
time
iii
decidable
classes
carry
complexity
analysis
determine
data
complexity
cases
obtained
varying
following
three
parameters
query
atomic
conjunctive
acyclic
class
underlying
datalog∃
program
guarded
linear
weakly
guarded
monadic-linear
multi-linear
iii
allowed
datalog
extension
disjunction
existential
variables
best
knowledge
ﬁrst
paper
proposing
dedicated
exten-
sion
disjunctive
datalog
existential
quantiﬁers
analyzing
decidabil-
ity
complexity
proposals
example
ferraris
2011
interpreting
arbitrary
ﬁrst-order
formulas
stable
model
semantics
general
approach
rather
diﬀerent
motivation
particular
address
decidability
issues
however
literature
many
studies
concerning
decidability
non-disjunctive
datalog∃
frag-
ments
decidable
subclasses
datalog∃
rely
four
main
syntactic
paradigms
called
guardedness
cal
2008
weak-acyclicity
fagin
2005
stickiness
cal
2010a
shyness
leone
2012
guardedness
paradigm
discussed
depth
paper
extended
disjunctive
case
weak-acyclicity
originally
introduced
context
data
exchange
programs
required
ﬁnite
universal
models
fagin
2005
extensions
also
proposed
context
deutsch
2008
marnette
2009
meier
2009
greco
2011
sticky
datalog∃
programs
deﬁned
recently
low
complexity
express
well-known
inclusion
dependencies
since
fo-rewritable
limited
ex-
pressive
power
several
generalizations
stickiness
deﬁned
cal
2010b
example
sticky-join
class
preserves
benign
sticky
complexity
also
encompassing
linear
datalog∃
programs
finally
shy
newest
among
syntactic
datalog∃
families
oﬀers
good
balance
expressivity
complexity
class
signiﬁcantly
extends
class
datalog
linear
datalog∃
programs
preserving
data
combined
complexity
datalog
even
though
includes
existential
quantiﬁers
results
paper
complement
above-mentioned
works
contribute
complete
picture
computational
aspects
extensions
datalog
existential
quantiﬁers
providing
support
choosing
appropriate
setting
ﬁts
particular
needs
practical
applications
alviano
faber
leone
manna
disjunctive
datalog∃
language
section
introduce
syntax
semantics
datalog∃
programs
formally
deﬁne
query
answering
problem
2.1
preliminaries
following
notation
used
throughout
paper
always
denote
countably
inﬁnite
domains
terms
called
constants
nulls
variables
respectively
union
three
domains
null
variables
sets
variables
alphabet
predicate
symbols
say
ﬁxed
nonnegative
arity
atoms
expressions
form
predicate
symbol
tuple
terms
atom
denote
pred
predicate
symbol
formal
structure
containing
atoms
atoms
denotes
set
atoms
terms
denotes
set
terms
occurring
atoms
set
variables
i.e.
terms
also
denoted
structure
called
ground
base
denotes
set
atoms
formed
predicate
symbols
terms
2.1.1
mappings
mapping
function
s.t
implies
implies
let
subset
application
denoted
set
restriction
denoted
µ|t
mapping
s.t
case
also
say
extension
denoted
atom
denote
atom
formal
structure
containing
atoms
denote
structure
obtained
replacing
atom
composition
mapping
mapping
denoted
◦µ1
mapping
associating
let
two
formal
structures
containing
atoms
homomorphism
mapping
s.t
substructure
example
sets
atoms
isomorphism
bijective
homo-
morphism
isomorphism
exists
isomorphic
denoted
substitution
mapping
s.t
implies
implies
datalog∃
rule
ﬁnite
expression
form
2.2
programs
queries
∀x∃y
disj
x′∪y
conj
disjoint
sets
variables
next
called
∀-variables
variables
respectively
iii
disj
x′∪y
nonempty
disjunction
datalog∃
semantics
decidability
complexity
issues
atoms
conj
conjunction
atoms
universal
quantiﬁers
usu-
ally
omitted
lighten
syntax
existential
quantiﬁers
omitted
empty
case
coincides
standard
datalog∨
rule
sets
atoms
disj
x′∪y
atoms
conj
denoted
head
body
respec-
tively
body
|head
usually
referred
fact
particular
called
existential
ground
fact
according
whether
contains
∃-variable
respectively
datalog∃
program
set
datalog∃
rules
w.l.o.g.
assume
rules
share
variable
denote
head
heads
conjunctive
query
also
denoted
form
conj
x∪y
disjoint
sets
variables
conj
x∪y
conjunction
atoms
base
variables
called
free
variables
query
called
acyclic
acq
short
associated
hypergraph
acyclic
chekuri
rajaraman
2000
equivalently
hypertree-width
gottlob
1999
boolean
bcq
query
form
s.t
empty
atomic
query
form
s.t
conj
x∪y
consists
one
atom
2.3
semantics
let
base
model
rule
form
denoted
substitution
s.t
body
substitution
σ|x
s.t
head
model
datalog∃
program
denoted
let
mods
denote
set
models
two
programs
called
fo-equivalent
mods
mods
bcq
true
w.r.t
model
denoted
substitution
s.t
atoms
set
models
true
w.r.t
denoted
program
true
w.r.t
denoted
mods
answer
w.r.t
set
models
denoted
ans
set
substitutions
σ|x
s.t
σ|x
answer
w.r.t
program
denoted
ansp
set
ans
mods
note
bcq
either
ansp
6|=
ansp
σ|∅
σ|∅
identity
mapping
consideration
also
applies
ans
2.4
query
answering
problem
let
class
datalog∃
programs
whose
terms
belong
paper
call
query
answering
following
decision
problem
given
program
bcq
determine
whether
holds
following
call
class
qa-decidable
decidable
observe
computing
ansp
form
turing-
reducible
deﬁned
fact
ansp
deﬁned
set
sub-
stitutions
σ|x
s.t
bcq
σ|x
true
w.r.t
since
σ|x
ansp
implies
σ|x
terms
ﬁnitely
many
substitutions
considered
alviano
faber
leone
manna
universal
model
sets
datalog∃
programs
section
generalize
notion
universal
model
widely
used
context
datalog∃
programs
intuitively
universal
model
datalog∃
program
model
homomorphic
subset
deﬁnition
let
datalog∃
set
mods
universal
model
set
mods
homomorphism
s.t
universal
model
sets
suﬃcient
datalog∃
programs
theorem
universal
model
set
bcq
proof
immediate
mods
deﬁnition
assume
let
model
show
deﬁnition
exist
homomorphism
s.t
since
assumption
implies
substitution
s.t
atoms
therefore
atoms
combining
obtain
atoms
i.e.
design
strategy
identifying
universal
model
set
datalog∃
program
first
introduce
notion
ﬁres
rule
set
datalog∃
ground
rules
next
deﬁne
instantiation
procedure
computing
ground
program
inst
models
form
universal
model
set
let
rule
form
sets
ground
rules
ﬁring
substitution
w.r.t
substitution
s.t
σ|x
body
heads
ﬁring
w.r.t
yields
ground
rule
obtained
extending
σ|x
follows
∃-variables
assigned
least
|y|
nulls
occurring
assume
ﬁxed
well-ordering
variables
processed
according
order
ﬁring
substitution
rule
said
spent
already
ﬁred
procedure
illustrates
overall
instantiation
procedure
consists
ex-
haustive
series
ﬁres
breadth-ﬁrst
level-saturating
fashion
yielding
pos-
sibly
inﬁnite
ground
program
inst
procedure
program-instantiation
input
datalog∃
program
output
ground
program
inst
repeat
foreach
foreach
unspent
ﬁring
substitution
w.r.t
return
datalog∃
semantics
decidability
complexity
issues
example
let
well-ordering
run
procedure
following
program
obtained
one
given
introduction
predicate
renaming
lion
starts
setting
empty
set
ﬁring
substitution
w.r.t
identity
substitution
whose
ﬁre
yields
added
rules
moved
lines
new
ﬁring
sub-
stitution
namely
s.t
σ1|
lion
ﬁre
yields
lion
lion
added
moved
ﬁring
substitution
namely
s.t
σ2|
lion
whose
ﬁre
yields
lion
adding
rule
moving
new
ﬁring
substitution
namely
s.t
σ3|
ﬁre
yields
added
moved
new
ﬁring
substitution
namely
s.t
σ4|
whose
ﬁre
yields
procedure
thus
indeﬁnitely
let
lion
lion
subset-minimal
models
inst
following
forms
si∈
1..k
si≥1
ϕi+1
ϕi+1
ϕi+1
ϕi+1
cid:3
order
show
mods
inst
universal
model
set
ﬁrst
point
relationships
models
inst
lemma
let
datalog∃
program
inst
mods
exist
mods
homomorphism
s.t
heads
iii
h|terms
proof
let
mods
ﬁrst
rules
w.r.t
order
induced
procedure
prove
induction
exist
mods
homomorphism
s.t
heads
|terms
base
case
vacuously
true
choosing
identity
mapping
let
assume
claim
holds
let
extend
order
show
claim
holds
note
rule
ri+1
obtained
substitution
rule
form
note
also
substitution
|terms
induction
hypothesis
body
substitution
s.t
head
model
assumption
otherwise
body
let
let
hi+1
homomorphism
s.t
implies
hi+1
implies
hi+1
let
mi+1
following
set
atoms
atoms
following
properties
hold
construction
mi+1
heads
pi+1
hi+1
mi+1
alviano
faber
leone
manna
hi+1
hi+1|terms
pi+1
hence
complete
proof
prove
mi+1
model
pi+1
fact
case
ri+1
satisﬁed
construction
mi+1
rules
satisﬁed
mi+1
satisﬁed
atoms
mi+1
occur
construction
mi+1
universal
model
set
obtained
mods
inst
allows
answering
queries
performing
reasoning
inst
theorem
let
datalog∃
program
inst
model
set
mods
heads
universal
proof
lemma
mods
homomorphism
s.t
remains
show
mods
i.e.
mods
s.t
heads
implies
mods
let
substitution
s.t
body
ﬁring
substitution
let
rule
obtained
ﬁring
thus
head
i.e.
program
produced
procedure
generalization
oblivious
chase
procedure
maier
1979
johnson
klug
1984
associates
every
datalog∃
program
universal
model
fact
oblivious
chase
procedure
ob-
tained
procedure
replacing
line
head
enough
datalog∃
programs
corollary
let
datalog∃
program
heads
inst
universal
extending
guards-based
classes
datalog∃
next
deﬁne
subclasses
datalog∃
relying
well
known
paradigm
called
guardedness
ﬁrst
introduced
andr´eka
1998
deﬁnition
guarded
fragment
ﬁrst-order
logic
revisited
cal
2008
deﬁning
datalog∃
subclasses
next
section
show
new
classes
depend
easily
checkable
syntactic
properties
qa-decidable
deﬁnition
datalog∃
rule
said
guarded
form
∀x∃y
disj
x′∪y
guard
s-conj
x′′
x′′
subsets
guard
atom
called
guard
denoted
guard
s-conj
x′′
conjunction
atoms
called
sides
denoted
sides
moreover
guarded
rule
called
multi-linear
side
atom
could
chosen
guard
linear
sides
monadic-linear
sides
head
predicates
unary
hereafter
datalog∃
program
called
guarded
resp.
multi-
linear
linear
monadic-linear
rule
either
guarded
resp.
multi-
linear
linear
monadic-linear
empty
body
introduce
notion
aﬀected
positions
atom
positions
nulls
might
occur
output
procedure
datalog∃
semantics
decidability
complexity
issues
deﬁnition
let
datalog∃
program
atom
variable
occurring
position
position
inductively
marked
aﬀected
w.r.t
rule
atom
head
s.t
pred
pred
either
∃-variable
∀-variable
s.t
occurs
body
aﬀected
positions
variable
occurring
body
rule
unaﬀected
aﬀected
deﬁnition
used
deﬁne
class
weakly-guarded
programs
deﬁnition
let
datalog∃
program
rule
form
∀x∃y
disj
x′∪y
wguard
x′′
s-conj
x′′′
x′′
x′′′
rule
said
weakly-guarded
w.r.t
variable
x′′′
x′′
unaﬀected
guard
sides
still
de-
note
weak
guard
side
atoms
respectively
following
weakly-guarded-datalog∃
denote
set
datalog∃
programs
rule
either
weakly-guarded
empty
body
new
datalog∃
subclasses
introduced
section
generalize
important
fragments
guarded-datalog∃
already
analyzed
literature
note
weakly-guarded-datalog∃
generalized
weakly-guarded-datalog∃
disjunction-free
programs
deﬁnition
coincides
notion
aﬀected
position
introduced
cal
2008
proposition
deﬁnitions
generalize
classes
guarded-datalog∃
linear-datalog∃
weakly-guarded-datalog∃
deﬁned
cal
2008
pinpoint
complexity
recognizing
programs
classes
theorem
checking
whether
program
belongs
guarded-datalog∃
linear-datalog∃
weakly-guarded-datalog∃
decidable
doable
polynomial-time
proof
checking
whether
program
guarded
resp.
linear
multi-linear
doable
linear
time
inspection
rule
bodies
concerning
weakly-guarded-datalog∃
program
observe
deﬁnition
introduces
monotone
operator
deter-
mining
aﬀected
positions
number
positions
linear
size
hence
aﬀected
positions
determined
quadratic
time
decidability
results
show
classes
introduced
previous
section
qa-decidable
particular
use
results
recently
established
barany
2010
guarded
fragment
ﬁrst-order
logic
andr´eka
1998
gr¨adel
1999
de-
noted
guarded-fol
inductively
deﬁned
follows
base
alviano
faber
leone
manna
guarded-fol
guarded-fol
¬ψ1
also
belong
guarded-fol
iii
x∪y
base
guarded-fol
free
variables
include
free
vari-
ables
x∪y
x∪y
also
guarded-fol
guarded-datalog∃
program
viewed
guarded-fol
formula
proposition
logarithmic
space
transducer
associating
guarded-datalog∃
pro-
gram
fo-equivalent
guarded-fol
formula
proof
guarded
datalog∃
rule
form
let
disj
x′∪y
1..k
following
fo-equivalent
formula
∪yi
i-th
atom
rule
translated
∃y1h1
1∪y1
∃yk
∪yk
¬s-conj
x′′
guard
∪yi
equivalent
∃yi
whole
disjunction
expression
x′′
guarded-fol
∃yi
∪yi
guarded-fol
since
¬s-conj
x′′
trivially
belongs
guarded-fol
moreover
expression
x′∪
x′′
guard
guarded-fol
since
x′′
x.finally
similar
con-
struction
applies
rules
empty
bodies
∪yi
qa-decidability
guarded-datalog∃
subclasses
established
theorem
conjunctive
decidable
guarded
multi-linear
linear
datalog∃
proof
result
follows
proposition
fact
conjunctive
decidable
guarded-fol
barany
2010
order
prove
weakly-guarded-datalog∃
qa-decidable
well
ﬁrst
introduce
notion
weak
instantiation
deﬁnition
let
weakly-guarded-datalog∃
let
winst
denote
set
partially
ground
rules
associated
consisting
set
set
substitution
x′′′
x′′
terms
according
whether
rule
empty
body
form
respectively
weak
instantiation
denoted
winst
deﬁned
union
winst
deﬁnition
transforms
weakly-guarded-datalog∃
program
fo-equivalent
guarded-datalog∃
program
lemma
let
weakly-guarded-datalog∃
program
winst
guarded-datalog∃
inst
inst
hold
datalog∃
semantics
decidability
complexity
issues
proof
assume
procedure
builds
isomorphic
sets
rules
given
iteration
repeat-until
loop
shall
show
isomorphism
extended
succeeding
iteration
ﬁring
substitution
rule
s.t
substitution
x′′′
x′′
terms
let
therefore
ﬁring
substitution
consider
direction
let
ﬁring
substitution
let
substitution
x′′′
x′′
terms
therefore
σ′◦σ
ﬁring
substitution
isomorphism
thus
extended
opportunely
mapping
new
nulls
thus
conclude
weakly-guarded-datalog∃
qa-decidable
theorem
conjunctive
decidable
weakly-guarded-datalog∃
proof
statement
directly
follows
lemma
theorem
complexity
analysis
section
study
data
complexity
diﬀerent
classes
datalog∃
queries
usual
setting
assume
datalog∃
program
paired
ﬁnite
database
base
set
ground
facts
similarly
←−a
denotes
singleton
atom
denoted
finally
whenever
contains
rule
form
disj
even
|disj|
replace
disj
edb
add
extra
propositional
atom
edb
arity
zero
hereafter
assume
6.1
guarded-datalog∃
start
providing
upper
bound
guarded-datalog∃
theorem
data
complexity
guarded-datalog∃
programs
conp
proof
statement
theorem
barany
2010
data
complexity
de-
ciding
whether
true
w.r.t
guarded-fol
formula
conp
claim
therefore
follows
proposition
pinpoint
complexity
guarded-datalog∃
theorem
data
complexity
guarded-datalog∃
programs
conp-complete
general
conp-hard
already
following
cases
monadic-linear-datalog∨
program
acyclic
multi-linear-datalog∨
program
atomic
query
alviano
faber
leone
manna
proof
conp-hard
already
following
setting
database
acyclic
involving
unary
binary
atoms
single
nonrecursive
monadic-
linear-datalog∨
rule
containing
two
head
atoms
result
follows
theorem
6.4
proof
calvanese
2009
let
2+2-cnf
formula
namely
cnf
formula
clause
exactly
two
positive
two
negative
literals
let
database
containing
atom
lit
propositional
variable
atoms
clause
∨¬x3
∨¬x4
identiﬁer
let
monadic-linear-datalog∨
program
consisting
following
rule
lit
following
acyclic
hence
unsatisﬁable
conp-complete
problem
3-unsat
encoded
means
atomic
query
wrongassignment
following
multi-linear-datalog∨
program
sel
sel
sel
clause
wrongassignment
sel
sel
far
database
concerned
clause
given
3-cnf
formula
encoded
ground
atom
clause
positive
propositional
variable
negative
propositional
variable
satisfying
assignment
model
containing
wrongassignment
6.2
weakly-guarded-datalog∃
disjunction-free
case
complexity
weakly-guarded-datalog∃
harder
guarded-datalog∃
theorem
data
complexity
weakly-guarded-datalog∃
exp-complete
gen-
eral
exp-hard
already
atomic
queries
weakly-guarded-datalog∃
proof
hardness
comes
exp-hardness
weakly-guarded-datalog∃
cal
2008
membership
let
weakly-guarded-datalog∃
program
guarded-datalog∃
program
built
according
deﬁnition
winst
moreover
let
maximum
number
lemma
unguarded
thus
unaﬀected
variables
appearing
rule
num-
ber
constants
occurring
maximum
arity
predicate
point
|d|
|d|
hence
symbols
data
complexity
size
polynomial
cardinality
barany
2010
shown
guarded-fol
formula
2exp
general
case
however
double
exponential
dependence
terms
considered
ﬁxed
complexity
simply
exponential
size
moreover
since
translated
logarithmic
space
fo-
equivalent
guarded-fol
formula
proposition
exp
w.r.t
cardinality
algorithm
deciding
whether
datalog∃
semantics
decidability
complexity
issues
6.3
atomic
queries
linear-datalog∃
following
let
linear-datalog∃
program
boolean
atomic
query
input
database
ﬁrst
introduce
decomposition
property
relying
structure
lemma
let
set
mods
←−a1
mods
←−an
hm1
holds
mods
proof
let
hm1
prove
model
show
whenever
rule
exists
substitution
s.t
body
head
let
pair
s.t
body
since
linear
1..n
s.t
body
since
model
←−a
head
finally
implication
holds
since
let
model
consequently
n-tuple
belongs
entailing
1..n
also
model
←−ai
following
lemma
represents
logspace
turing
reduction
problem
problem
evaluating
←−a
evaluating
lemma
1..n
s.t
←−ai
proof
prove
contrapositive
let
assume
1..n
←−ai
6|=
thus
1..n
exists
model
s.t
6|=
therefore
6|=
lemma
obtain
since
1..n
s.t
←−a
mods
←−a
lemma
6|=
lemma
allows
focussing
analysis
single
database
atom
say
instantiation-tree
←−a
directed
acyclic
graph
tree
←−a
inductively
constructed
follows
root
node
labeled
←−a
node
rule
inst
←−a
s.t
body
appears
head
rule
labeling
add
node
labeled
along
arc
see
example
let
nodes
arcs
denote
nodes
arcs
respectively
label
denotes
ground
rule
used
label
short
nodes
subtree
tree
ﬁnally
depth
depth
deﬁned
length
path
leading
root
deﬁnition
stem
←−a
denoted
stem
←−a
maximal
subtree
obtained
starting
root
tree
←−a
way
path
contains
nodes
labelled
rules
isomorphic
bodies
finally
sinst
←−a
denotes
set
label
stem
←−a
alviano
faber
leone
manna
stem
pex-2
←−−−
fig
instantiation-tree
pex-2
stem
example
consider
database
atom
following
program
pex-2
instantiation-tree
reported
fig
also
highlighted
stem
note
also
many
isomorphic
subtrees
due
structural
property
tree
←−a
highlight
next
lemma
lemma
let
two
nodes
tree
←−a
s.t
body
label
body
label
node
among
siblings
s.t
subtree
subtree
proof
statement
holds
root
root
case
root
contain
rule
empty
body
otherwise
let
parent
nodes
respectively
construction
relying
proce-
dure
body
label
head
label
body
label
head
label
let
label
rule
substitution
let
isomor-
phism
body
label
body
label
thus
child
s.t
label
turn
implies
label
label
use
induction
let
two
isomorphic
paths
subtree
subtree
respectively
still
construction
one-to-one
mapping
children
s.t
child
holds
label
label
given
model
sinst
←−a
shall
show
build
model
inst
←−a
s.t
implies
let
stem
←−a
smallest
subset
nodes
satisfying
following
properties
root
whenever
parent
belongs
body
label
holds
thus
restrict
model
follows
head
label
datalog∃
semantics
decidability
complexity
issues
example
consider
instantiation-tree
reported
fig
let
nodes
colored
gray
note
still
model
program
formally
established
next
lemma
lemma
model
sinst
←−a
also
proof
let
nodes
\c0
parent
unique
atom
body
label
claim
head
label
procedure
since
head
label
moreover
according
deﬁnition
belongs
also
hence
implying
node
s.t
head
label
means
since
child
s.t
label
label
however
since
construction
head
node
nonempty
intersection
head
label
head
label
nonempty
intersection
tree
←−a
deﬁne
total
function
nodes
nodes
follows
node
stem
←−a
remaining
nodes
let
nodes
nodes
s.t
parent
belongs
let
unique
node
path
root
s.t
body
label
body
label
let
either
one
siblings
according
whether
label
label
function
thus
maps
subtree
subtree
total
lemma
remark
moreover
finally
build
set
model
inst
←−a
s.t
implies
initially
coincide
respectively
sub-
sequently
node
nodes
nodes
s.t
parent
body
label
augmented
augmented
set
head
label
isomorphism
prove
performed
considering
rules
stem
lemma
holds
inst
←−a
sinst
←−a
proof
since
sinst
←−a
inst
←−a
model
inst
←−a
also
model
sinst
←−a
let
assume
inst
←−a
holds
let
model
sinst
←−a
since
construction
model
inst
←−a
since
hypothesis
holds
tractability
atomic
linear-datalog∃
established
theorem
data
complexity
atomic
linear-datalog∃
programs
logspace
alviano
faber
leone
manna
proof
armed
lemma
logspace
procedure
iterates
database
atoms
looking
atom
s.t
sinst
←−a
fact
stem
←−a
depth
|π|
maximum
arity
predicate
symbols
number
predicate
symbols
occurring
therefore
cardinality
ground
program
sinst
←−a
depend
neither
number
minimal
models
suﬃcient
6.4
discussion
table
provides
comprehensive
overview
complexity
results
follow
results
obtained
section
literature
row
reports
com-
plexity
classes
deﬁned
section
together
either
atomic
queries
acyclic
conjunctive
queries
acq
conjunctive
queries
row
diﬀerentiate
presence
absence
existential
variables
disjunction
∃-variables
rule
heads
column
disjunctive
heads
column
column
results
-column
cal
2008
cal
2009
results
weakly-guarded-datalog∨
last
cell
column
follow
eiter
1997
since
class
coincides
datalog∨
remaining
conp-completeness
re-
sults
follow
theorem
section
6.1
remaining
exp-completeness
results
follow
theorem
section
6.2
logspace
upper
bounds
follow
theorem
section
6.3.
let
ﬁrst
consider
impact
allowing
disjunction
presence
exis-
tential
quantiﬁers
rule
heads
i.e
columns
versus
see
considered
cases
problem
becomes
potentially
harder
except
class
weakly-guarded
indeed
case
problem
provably
intractable
already
without
disjunctions
turns
remain
including
cases
actually
identify
tractability
boundary
passing
ac0
conp-completeness
notable
exceptions
monadic-linear
linear
atomic
queries
case
problem
remains
tractable
may
slightly
complex
interesting
observe
presence
disjunction
nature
query
huge
impact
complexity
classes
monadic-linear
linear
case
absence
disjunction
table
data
complexity
datalog∃
datalog
restrictions
monadic-
linear
query
structure
acq/cq
multi-linear
aq/acq/cq
datalog
extensions
ac0
ac0
ac0
logspace
logspace
conp-complete
conp-complete
conp-complete
conp-complete
guarded
aq/acq/cq
p-complete
conp-complete
conp-complete
weakly-guarded
aq/acq/cq
exp-complete
conp-complete
exp-complete
datalog∃
semantics
decidability
complexity
issues
let
discuss
impact
adding
existential
quantiﬁcation
presence
disjunction
rule
heads
i.e
columns
versus
see
considered
classes
except
weakly-guarded
adding
existential
quantiﬁers
alter
complexity
notable
result
since
existential
quantiﬁcation
powerful
construct
knowledge
representation
weakly-guarded
obtain
signiﬁcant
rise
conp-completeness
exp-completeness
thus
provable
intractability
future
work
intend
investigate
exact
data
complexity
atomic
monadic-
linear-datalog∃
programs
particular
whether
ac0
also
intend
study
impact
disjunction
tractable
frag-
ments
datalog∃
based
diﬀerent
paradigms
example
stickiness
cal
2010a
shyness
leone
2012
weak-acyclicity
fagin
2005
moreover
would
also
interesting
broaden
study
combined
complexity
limit
ﬁxed
bounded
predicate
arities
finally
also
investigating
implementa-
tion
issues
example
dlv∃
leone
2012
agenda
acknowledgments
authors
want
thank
georg
gottlob
michael
morak
andreas
pieris
useful
discussions
problem
work
partially
supported
miur
pon
projects
frame
tetris
references
andr´eka
n´emeti
van
benthem
1998.
modal
languages
bounded
fragments
predicate
logic
journal
philosophical
logic
217–274
barany
gottlob
otto
2010.
querying
guarded
fragment
proc
25th
annual
ieee
symp
lics
1–10
cal
gottlob
kifer
2008.
taming
inﬁnite
chase
query
an-
swering
expressive
relational
constraints
proc
11th
int
conf
70–80
revised
version
http
//dbai.tuwien.ac.at/staff/gottlob/cgk.pdf
cal
gottlob
lukasiewicz
2009.
general
datalog-based
framework
tractable
query
answering
ontologies
proc
28th
pods
symp
77–86
cal
gottlob
pieris
2010a
advanced
processing
ontological
queries
pvldb
554–565
cal
gottlob
pieris
2010b
query
answering
non-guarded
rules
datalog±
proc
4th
int
conf
vol
6333
1–17
cal
gottlob
pieris
2011.
new
expressive
languages
ontological
query
answering
proc
25th
aaai
conf
1541–1546
calvanese
giacomo
lembo
lenzerini
poggi
rodriguez-
muro
rosati
2009.
ontologies
databases
dl-lite
approach
reasoning
web
lncs
vol
5689.
springer
255–356
calvanese
giacomo
lembo
lenzerini
rosati
2007.
tractable
reasoning
eﬃcient
query
answering
description
logics
dl-
lite
family
autom
reason
385–429
chekuri
rajaraman
2000.
conjunctive
query
containment
revisited
theor
comput
sci
239
211–229
alviano
faber
leone
manna
moor
gottlob
furche
sellers
eds
2011.
datalog
reloaded
first
international
workshop
datalog
2010.
revised
selected
papers
lncs
vol
6702.
springer
verlag
deutsch
nash
remmel
2008.
chase
revisited
proc
27th
pods
symp
149–158
eiter
faber
leone
pfeifer
polleres
2004.
logic
pro-
gramming
approach
knowledge-state
planning
semantics
complexity
acm
tocl
206–263
eiter
gottlob
mannila
1997.
disjunctive
datalog
acm
tods
364–418
fagin
kolaitis
miller
popa
2005.
data
exchange
semantics
query
answering
tcs
336
89–124
ferraris
lee
lifschitz
2011.
stable
models
circumscription
artif
intell
175
236–263
gottlob
leone
scarcello
1999.
hypertree
decompositions
tractable
queries
proc
18th
pods
symp
21–32
gr¨adel
1999.
restraining
power
guards
journal
symbolic
logic
1719–1742
greco
spezzano
trubitsyna
2011.
stratiﬁcation
criteria
rewrit-
ing
techniques
checking
chase
termination
pvldb
1158–1168
hustadt
motik
sattler
2004.
reducing
shiq-
descrption
logic
disjunctive
datalog
programs
proc
9th
int
conf
152–162
johnson
klug
1984.
testing
containment
conjunctive
queries
functional
inclusion
dependencies
comput
syst
sci
167–189
kollia
glimm
horrocks
2011.
sparql
query
answering
owl
ontologies
proc
24th
int
workshop
lncs
vol
6643.
springer
382–396
leone
gottlob
rosati
eiter
faber
fink
greco
ianni
lka
lembo
lenzerini
lio
nowicki
ruzzi
staniszkis
terracina
2005.
infomix
system
advanced
integration
incomplete
inconsistent
data
proc
24th
acm
sigmod
int
conf
management
data
915–917
leone
manna
terracina
veltri
2012.
eﬃciently
computable
datalog∃
programs
proc
13th
int
conf
forthcoming
long
version
www.mat.unical.it/kr2012/shy.pdf
maier
mendelzon
sagiv
1979.
testing
implications
data
dependencies
acm
tods
455–469
marnette
2009.
generalized
schema-mappings
termination
tractability
proc
28th
pods
symp
13–22
meier
schmidt
lausen
2009.
chase
termination
beyond
strat-
iﬁcation
pvldb
970–981
mugnier
m.-l.
2011.
ontological
query
answering
existential
rules
proc
5th
int
conf
2–23
