consider
public
theori
practic
logic
program
declar
problem
solv
use
tree
decomposit
program
bernhard
bliem
michael
morak
stefan
woltran
institut
inform
system
vienna
univers
technolog
favoritenstrass
vienna
austria
surnam
abstract
work
propos
program
asp
tool
rapid
prototyp
dynam
program
algorithm
base
tree
decomposit
fact
mani
algorithm
design
found
way
implement
main
obstacl
lack
system
take
care
build
tree
decomposit
provid
interfac
declar
speciﬁc
dynam
program
algorithm
paper
present
novel
tool
relief
user
handl
technic
detail
concern
pars
tree
decomposit
handl
data
structur
etc
instead
dynam
program
algorithm
speciﬁ
asp
languag
employ
asp
solver
order
comput
local
solut
dynam
program
algorithm
paper
give
exampl
illustr
use
describ
main
featur
system
moreov
report
experi
show
encod
problem
outperform
monolith
asp
encod
instanc
small
treewidth
appear
theori
practic
logic
program
tplp
introduct
comput
hard
problem
found
almost
everi
area
comput
scienc
henc
quest
gener
tool
method
help
design
solut
lem
one
central
research
challeng
ﬁeld
one
particularli
success
approach
program
marek
brewka
highli
sophist
solver
leon
gebser
provid
rich
declar
languag
specifi
given
problem
intuit
succinct
manner
hand
concept
dynam
ming
larson
wagner
denot
gener
recurs
strategi
optim
solut
problem
deﬁn
term
optim
solut
subproblem
thu
construct
solut
simpler
complex
problem
one
particular
applic
dynam
program
design
algorithm
proceed
along
tree
decomposit
robertson
seymour
problem
hand
rather
graph
represent
signiﬁc
approach
highlight
courcel
semin
result
see
courcel
state
everi
problem
ﬁnabl
monad
logic
solv
linear
time
structur
bound
treewidth
formal
deﬁnit
concept
provid
section
gest
methodolog
problem
solv
ﬁrst
tree
decomposit
bliem
morak
woltran
given
problem
instanc
obtain
subsequ
use
second
phase
solv
problem
speciﬁc
design
algorithm
usual
employ
dynam
program
travers
tree
decomposit
see
bodlaend
koster
overview
approach
tree
decomposit
base
algorithm
success
eral
applic
includ
constraint
satisfact
problem
koster
also
cai
good
heurist
obtain
tree
decomposit
exist
dermaku
laender
koster
implement
thereof
avail
actual
tation
dynam
program
algorithm
work
tree
decomposit
yet
often
done
scratch
paper
present
new
method
declar
specifi
dynam
program
part
name
mean
asp
program
tion
dynam
program
reli
evalu
subproblem
often
combinatori
natur
thank
guess
check
principl
asp
paradigm
use
asp
describ
treatment
subproblem
thu
natur
choic
also
separ
approach
exist
system
discu
sion
section
paper
use
asp
languag
order
describ
constitu
element
dynam
program
algorithm
obvious
suggest
also
employ
ticat
asp
system
intern
machineri
evalu
speciﬁ
gorithm
thu
approach
take
full
advantag
rich
syntax
asp
offer
describ
dynam
program
algorithm
also
deleg
burden
local
comput
highli
efﬁcient
asp
system
implement
approach
novel
system
take
care
comput
tree
decomposit
also
handl
data
ﬂow
dynam
program
requir
user
idea
gorithm
henc
serf
tool
rapid
prototyp
dynam
program
algorithm
also
consid
educ
purpos
well
asp
user
provid
interfac
decompos
problem
issu
might
allow
larg
instanc
practic
import
solv
far
could
handl
asp
system
summar
provid
new
method
problem
solv
combin
advantag
asp
tree
decomposit
base
dynam
gram
attempt
eas
speciﬁc
dynam
program
algorithm
alreadi
exist
see
section
awar
system
employ
asp
dynam
program
tree
decomposit
structur
paper
follow
section
ﬁrst
brieﬂi
recal
logic
gram
semant
provid
necessari
background
per
tree
decomposit
dynam
program
section
introduc
ture
provid
asp
speciﬁc
sever
standard
also
novel
dynam
program
algorithm
section
give
system
speciﬁc
section
report
preliminari
experiment
evalu
conclus
paper
address
relat
work
give
brief
summari
outlook
ynamic
program
ramework
ocal
execut
ree
decomposit
avail
http
concern
decomposit
employ
htdecomp
librari
dermaku
make
system
amen
hypertre
decomposit
well
fact
allow
decompos
arbitrari
ﬁnite
structur
thu
extend
rang
applic
system
declar
problem
solv
use
tree
decomposit
asp
preliminari
logic
program
semant
propos
system
us
asp
specifi
dynam
program
algorithm
section
therefor
brieﬂi
introduc
syntax
semant
asp
reader
refer
brewka
thorough
introduct
logic
program
consist
set
rule
form
call
atom
liter
either
atom
default
negat
obtain
put
front
rule
call
head
bodi
divid
posit
bodi
neg
bodi
note
head
may
empti
case
call
integr
constraint
bodi
empti
call
fact
symbol
omit
rule
satisﬁ
set
atom
call
interpret
iff
model
set
rule
iff
satisﬁ
rule
answer
set
program
iff
model
program
call
reduct
gelfond
lifschitz
paper
use
input
languag
gringo
gebser
logic
gram
atom
languag
predic
whose
argument
either
variabl
ground
term
program
seen
abbrevi
program
variabl
instanti
replac
ground
term
process
instanti
also
call
ground
result
proposit
program
repres
set
rule
adher
deﬁnit
exampl
instanc
cover
section
consist
set
vertex
set
edg
follow
set
fact
repres
valid
instanc
vertex
vertex
vertex
vertex
vertex
edg
edg
edg
edg
edg
edg
follow
logic
program
solv
instanc
form
color
red
green
blue
map
color
vertex
edg
map
map
solv
instanc
amount
ground
encod
togeth
stanc
input
solv
result
ground
program
line
encod
expand
grounder
three
fact
state
red
green
blue
color
line
contain
cardin
constraint
head
conceptu
expand
map
red
map
green
map
blue
vertex
grounder
expand
rule
substitut
ground
term
roughli
ing
cardin
constraint
satisﬁ
interpret
iff
least
liter
true
therefor
rule
question
deﬁn
problem
decid
whether
given
graph
exist
map
red
green
blue
edg
hold
bliem
morak
woltran
figur
graph
correspond
tree
decomposit
express
choic
exactli
one
map
red
map
green
map
blue
vertex
final
integr
constraint
line
encod
ensur
answer
set
map
color
adjac
vertex
space
reason
refer
reader
gebser
detail
input
languag
hypertre
decomposit
tree
decomposit
treewidth
origin
deﬁn
robertson
seymour
well
known
tool
tackl
comput
hard
problem
see
bodlaend
bodlaend
overview
inform
treewidth
measur
iti
graph
mani
problem
becom
tractabl
treewidth
bound
intuit
behind
tree
decomposit
obtain
tree
potenti
cyclic
graph
subsum
multipl
vertex
one
node
therebi
isol
part
sponsibl
cyclic
sever
problem
better
repres
hypergraph
concept
tree
decomposit
gener
see
gottlob
follow
therefor
deﬁn
hypertre
decomposit
tree
decomposit
special
case
hypergraph
pair
set
vertex
set
hyperedg
hyperedg
set
vertex
hypertre
decomposit
hypergraph
pair
root
tree
set
node
set
edg
label
function
node
bag
meet
follow
requir
everi
exist
node
everi
exist
node
everi
set
induc
connect
subtre
hypertre
decomposit
call
node
two
zero
resp
one
two
child
call
leaf
resp
chang
join
join
node
child
figur
depict
tree
decomposit
exampl
graph
given
problem
instanc
section
deﬁn
width
hypertre
decomposit
hypergraph
need
addit
label
function
everi
terminolog
remark
reason
use
term
restrict
concept
normal
also
call
nice
tree
decomposit
appear
literatur
normal
tree
posit
also
moreov
hypertre
decomposit
gener
notion
tree
posit
case
hypergraph
therefor
often
use
term
interchang
deal
ordinari
graph
even
though
strictli
speak
alway
produc
hypertre
decomposit
declar
problem
solv
use
tree
decomposit
asp
hypertre
decomposit
call
complet
edg
exist
node
width
hypertre
decomposit
maximum
size
node
minimum
width
possibl
hypertre
decomposit
call
gener
hypertre
width
idea
paramet
captur
inher
difﬁculti
given
problem
smaller
gener
hypertre
width
level
cyclic
easier
lem
solv
see
gottlob
ordinari
graph
width
tree
decomposit
deﬁn
differ
name
maximum
bag
size
minu
one
given
hypergraph
comput
tree
decomposit
minimum
width
howev
efﬁcient
heurist
develop
offer
good
approxim
dermaku
bodlaend
koster
note
gener
exist
mani
possibl
hypertre
decomposit
given
hypergraph
alway
exist
least
one
degener
hypertre
composit
consist
singl
node
cover
entir
hypergraph
expect
dynam
program
algorithm
provid
user
work
normal
hypertre
decomposit
user
worri
current
determin
decomposit
gener
heurist
method
htdecomp
librari
attempt
construct
decomposit
small
width
dynam
program
hypertre
decomposit
valu
hypertre
decomposit
size
linear
size
given
graph
moreov
provid
suitabl
structur
design
dynam
program
algorithm
wide
rang
problem
algorithm
gener
start
leaf
node
travers
tree
root
wherebi
node
set
partial
solut
ate
take
solut
account
comput
child
node
difﬁcult
part
construct
algorithm
identifi
appropri
data
structur
repres
partial
solut
node
one
hand
data
ture
must
contain
sufﬁcient
inform
comput
represent
partial
solut
node
correspond
represent
child
node
hand
size
data
structur
depend
size
bag
total
size
instanc
solv
purpos
tree
decomposit
node
maintain
data
structur
call
tabl
tabl
contain
row
call
tupl
map
assign
valu
current
bag
element
store
partial
solut
addit
tupl
node
may
associ
tupl
child
node
mean
pointer
pointer
determin
child
tupl
tupl
origin
use
construct
complet
solut
respect
partial
solut
comput
tabl
ﬁnish
illustr
idea
problem
consid
given
graph
spond
tree
decomposit
node
decomposit
basic
comput
valid
color
subgraph
induc
current
bag
store
color
row
tabl
associ
henc
tupl
node
decis
problem
need
solv
pointer
necessari
gener
algorithm
structur
tabl
depend
problem
type
greco
scarcello
gottlob
bliem
morak
woltran
figur
tupl
tabl
instanc
tree
decomposit
given
figur
tabl
assign
either
vertex
contain
current
bag
far
step
taken
dynam
program
algorithm
differ
gener
guess
check
approach
howev
comput
color
exchang
node
start
color
child
node
adapt
respect
new
vertex
addit
also
keep
track
tupl
give
rise
newli
calcul
tupl
figur
depict
respect
tabl
node
tree
decomposit
figur
tabl
column
contain
index
tupl
use
column
potenti
parent
node
refer
exchang
node
entri
column
set
pointer
child
tupl
join
node
entri
column
set
pair
resp
refer
tupl
left
resp
right
child
node
use
pointer
possibl
enumer
complet
solut
entir
problem
ﬁnal
travers
note
size
tabl
depend
width
tree
decomposit
number
tabl
linear
size
input
graph
thu
width
bound
constant
search
space
subproblem
remain
constant
well
number
subproblem
grow
linear
factor
larger
instanc
exampl
section
introduc
usag
system
mean
speciﬁc
exampl
problem
begin
rel
simpl
case
illustr
basic
function
system
continu
complex
applic
cours
gradual
introduc
featur
special
predic
respons
commun
user
program
predic
summar
tabl
futur
refer
gener
descript
system
possibl
applic
deleg
section
graph
color
ﬁrst
exampl
solv
problem
use
consid
col
problem
graph
alreadi
given
encod
declar
problem
solv
use
tree
decomposit
asp
tabl
reserv
predic
commun
user
program
input
predic
mean
current
introduc
remov
childtupl
childtuplel
childtupl
map
childcost
root
element
current
bag
introduc
current
bag
remov
current
bag
identiﬁ
child
tupl
exchang
node
tupl
left
resp
right
child
node
join
node
child
tupl
assign
valu
total
cost
partial
solut
correspond
child
tupl
indic
current
node
root
node
exchang
node
output
predic
mean
map
chosenchildtupl
chosenchildtuplel
chosenchildtupl
cost
currentcost
assign
valu
current
bag
element
declar
identiﬁ
child
tupl
cessor
current
describ
one
exchang
node
necessari
decis
problem
declar
identiﬁ
preced
child
tupl
left
resp
right
child
node
join
node
necessari
decis
problem
let
total
cost
current
partial
solut
requir
solv
optim
problem
let
local
cost
current
tupl
requir
exchang
node
solv
optim
problem
use
default
join
implement
section
sinc
program
togeth
instanc
input
solv
whole
problem
call
monolith
encod
tractabl
treewidth
take
advantag
low
treewidth
solv
problem
dynam
program
algorithm
oper
tree
decomposit
origin
input
graph
sketch
dynam
program
algorithm
section
provid
mean
specifi
dynam
program
algorithm
asp
languag
read
instanc
store
graph
represent
struct
tree
decomposit
order
obtain
graph
resent
instanc
user
need
specifi
command
line
predic
indic
hyper
edg
graph
represent
case
follow
idea
dynam
program
wish
comput
tabl
tree
decomposit
node
tabl
comput
use
tabl
child
node
bliem
morak
woltran
figur
workﬂow
calcul
tree
decomposit
node
tabl
data
ﬂow
process
exchang
node
data
ﬂow
process
join
node
exchang
program
instanc
current
tabl
answer
set
asp
solver
bag
child
tupl
child
tabl
join
program
instanc
current
tabl
answer
set
asp
solver
bag
left
tupl
right
tupl
left
tabl
right
tabl
perform
calcul
manner
sinc
tree
composit
allow
two
kind
node
one
child
join
node
exactli
two
child
content
join
sufﬁc
provid
asp
program
comput
tabl
exchang
node
exchang
program
short
program
comput
tabl
join
node
join
program
short
two
program
requir
user
solv
problem
travers
tree
decomposit
node
invok
asp
solver
proper
program
exchang
program
exchang
node
join
program
join
node
illustr
singl
step
given
figur
input
exchang
join
program
consist
origin
problem
instanc
suppli
user
tupl
child
node
set
fact
current
bag
current
introduc
remov
vertex
set
fact
answer
set
constitut
current
node
tabl
take
care
process
ﬁlling
appropri
data
structur
new
tupl
thu
store
proce
next
node
procedur
continu
root
process
present
exchang
program
regard
input
pli
set
current
introduc
remov
vertex
given
icat
respect
child
tupl
identiﬁ
declar
fact
childtupl
correspond
map
given
fact
form
map
signiﬁ
ple
vertex
assign
color
predic
name
map
chosen
analog
present
tens
term
map
fact
produc
tree
decomposit
leaf
well
root
node
empti
bag
empti
leaf
node
advantag
involv
comput
least
use
case
consid
far
deliv
empti
tupl
cost
parent
node
default
behavior
mirror
sens
current
support
asp
program
exchang
join
node
hand
empti
root
node
guarante
ﬁnal
action
dynam
program
algorithm
alway
speciﬁ
program
exchang
node
declar
problem
solv
use
tree
decomposit
asp
color
red
green
blue
chosenchildtupl
childtupl
map
chosenchildtupl
map
current
map
color
introduc
edg
map
map
program
base
intuit
exchang
node
child
tupl
give
rise
set
new
tupl
new
tupl
coincid
color
common
vertex
line
color
introduc
vertex
guess
line
follow
check
line
us
predic
problem
instanc
answer
set
constitut
exactli
one
new
tupl
current
node
tabl
output
predic
use
specifi
partial
color
new
tupl
like
use
monolith
encod
must
assign
color
vertex
current
node
anoth
output
predic
recogn
indic
child
tupl
partial
color
character
answer
set
correspond
must
cours
one
child
tupl
identiﬁ
extens
predic
requir
reconstruct
complet
solut
tabl
comput
therefor
omit
decis
problem
solv
still
remain
provid
program
process
kind
node
join
node
join
program
purpos
could
look
like
chosenchildtuplel
childtuplel
chosenchildtupl
childtupl
chosenchildtuplel
chosenchildtupl
map
map
join
equal
tupl
map
chosenchildtuplel
map
answer
set
obvious
must
state
two
child
node
chosen
cede
tupl
indic
chosenchildtuplel
chosenchildtupl
case
two
tupl
match
join
new
tupl
iff
partial
ment
coincid
line
tupl
result
join
also
equal
two
match
child
tupl
line
particular
join
behavior
basic
also
appli
common
problem
therefor
offer
quit
efﬁcient
default
implement
behavior
user
resort
sufﬁc
instead
write
join
program
would
like
point
differ
role
exchang
join
node
particular
one
might
wonder
join
node
default
tion
often
use
wherea
none
exchang
node
differ
due
idea
dynam
program
one
hand
involv
solv
partial
problem
hand
requir
combin
partial
solut
clearli
separ
thank
concept
tree
decomposit
obvious
combin
explicitli
done
join
node
wherea
usual
solv
partial
problem
perform
exchang
node
therefor
requir
code
exchang
node
alway
requir
code
sinc
entir
problem
seen
gle
degener
exchang
node
henc
part
exchang
program
resembl
monolith
encod
much
even
though
technic
irrelev
inde
chang
program
seen
gener
monolith
encod
sinc
correct
exchang
program
must
principl
also
solv
entir
problem
case
howev
knowledg
problem
also
need
join
node
next
subsect
show
bliem
morak
woltran
boolean
satisﬁ
instanc
satisﬁ
problem
sat
given
predic
po
neg
denot
proposit
variabl
occur
posit
resp
neg
claus
claus
variabl
declar
use
predic
respect
follow
monolith
encod
solv
instanc
map
true
map
fals
atom
sat
po
map
true
sat
neg
map
fals
claus
sat
obtain
graph
represent
sat
instanc
construct
incid
graph
graph
obtain
consid
claus
variabl
vertex
ing
claus
vertex
variabl
vertex
edg
iff
respect
variabl
occur
respect
claus
order
transform
input
graph
represent
user
requir
state
indic
edg
dynam
program
algorithm
model
count
problem
work
tree
decomposit
incid
graph
given
samer
szeider
present
possibl
asp
encod
exchang
node
follow
work
gener
idea
algorithm
gener
tree
decomposit
note
primarili
assign
truth
valu
current
proposit
atom
like
monolith
encod
consequ
also
assign
true
fals
current
claus
depend
whether
satisﬁ
partial
interpret
repres
tupl
need
inform
statu
claus
claus
remov
tupl
satisfi
claus
must
elimin
chosenchildtupl
childtupl
claus
remov
chosenchildtupl
map
true
map
true
chosenchildtupl
map
true
current
map
true
map
fals
atom
introduc
map
true
po
current
map
true
map
true
neg
current
map
fals
map
fals
current
map
true
mention
elimin
truth
assign
perform
check
line
child
tupl
partial
interpret
retain
line
extend
guess
introduc
atom
line
claus
satisﬁ
point
remain
due
line
wherea
line
mark
claus
satisﬁ
current
partial
assign
sat
problem
use
default
implement
join
node
reason
order
join
two
tupl
need
coincid
valu
assign
claus
assign
atom
given
truth
ment
current
atom
claus
satisﬁ
either
child
tupl
also
satisﬁ
tupl
result
join
two
follow
join
program
follow
idea
chosenchildtuplel
childtuplel
chosenchildtupl
childtupl
map
true
map
fals
atom
chosenchildtuplel
chosenchildtupl
map
fals
map
true
atom
chosenchildtuplel
chosenchildtupl
map
true
chosenchildtuplel
map
true
map
true
chosenchildtupl
map
true
map
fals
current
map
true
declar
problem
solv
use
tree
decomposit
asp
minimum
vertex
cover
encod
outlin
sufﬁc
instruct
solv
respect
enumer
problem
solut
count
problem
mani
solut
exist
decis
problem
solut
often
also
desir
solv
optim
problem
addit
inform
regard
cost
partial
solut
must
suppli
encod
exampl
brieﬂi
introduc
drosophila
algorithm
minimum
vertex
cover
problem
solv
instanc
given
begin
lithic
encod
comparison
map
map
vertex
edg
map
map
cost
count
map
minim
cost
mean
minim
statement
leav
asp
solver
ﬁlter
mal
solut
howev
mistak
use
optim
statement
write
exchang
program
one
would
ﬁlter
tupl
whose
local
cost
might
exceed
other
end
would
yield
better
global
solut
exchang
program
minimum
vertex
cover
could
look
like
chosenchildtupl
childtupl
map
current
chosenchildtupl
map
introduc
map
map
edg
map
map
currentcost
count
map
cost
chosenchildtupl
childcost
count
predic
recogn
speciﬁ
cost
partial
lution
obtain
extend
current
tupl
predecessor
recurs
number
comput
line
ad
preced
tupl
cost
provid
cost
due
introduc
case
number
vertex
guess
peculiar
use
default
join
implement
exampl
tupl
need
store
cost
correspond
partial
solut
also
cost
tupl
declar
upon
join
two
coincid
tupl
ad
total
cost
associ
partial
solut
portion
cost
due
coincid
child
tupl
count
twice
must
thu
subtract
sum
also
recogn
predic
implement
join
program
manual
predic
useless
calcul
cost
tupl
result
join
user
note
soon
root
tree
decomposit
process
poss
inform
requir
determin
cost
number
optim
solut
constant
time
without
addit
tree
travers
well
ate
optim
solut
linear
delay
travers
tree
follow
tupl
pointer
predecessor
construct
solut
process
tion
problem
instanc
differ
problem
without
optim
except
partial
solut
cost
must
speciﬁ
tupl
bliem
morak
woltran
cyclic
order
alway
use
graph
represent
problem
instanc
problem
howev
repres
natur
hypergraph
exampl
cyclic
order
problem
take
instanc
set
describ
cate
set
tripl
describ
order
declar
vertex
call
order
vertex
tripl
order
said
satisﬁ
order
iff
object
bring
vertex
order
tripl
satisﬁ
follow
monolith
encod
achiev
map
vertex
count
vertex
map
map
map
map
sat
order
sat
order
sat
order
order
sat
one
natur
repres
problem
hypergraph
one
consid
element
vertex
tripl
hyperedg
ensur
vertex
tripl
must
appear
togeth
least
one
bag
tripl
therefor
check
exchang
node
use
opportun
introduc
distinct
two
way
write
exchang
encod
either
case
way
select
preced
child
tupl
construct
new
tupl
origin
deal
decis
problem
anoth
possibl
proceed
guess
ﬁrst
assign
valu
current
vertex
check
child
tupl
exist
valid
predecessor
guess
advantag
avoid
guess
potenti
huge
number
child
tupl
probabl
mani
result
tupl
would
coincid
follow
exchang
encod
cyclic
order
proce
map
current
count
current
map
map
map
map
sat
order
sat
order
sat
order
order
current
sat
gtchild
map
map
current
nomatch
gtchild
match
childtupl
nomatch
match
ﬁrst
seven
line
similar
monolith
encod
remaind
program
make
sure
valid
predecessor
among
child
tupl
note
approach
employ
decis
problem
count
enumer
solut
requir
pointer
child
tupl
fact
problem
differ
previous
discuss
insofar
set
valu
map
vertex
ﬁxed
three
color
truth
valu
wherea
would
requir
assign
vertex
number
total
number
vertex
monolith
declar
problem
solv
use
tree
decomposit
asp
program
one
realli
construct
solut
problem
approach
would
violat
principl
dynam
program
subproblem
would
depend
whole
problem
howev
note
line
local
order
order
current
bag
element
guess
valu
map
vertex
posit
order
vertex
exampl
overview
section
illustr
function
via
sever
exampl
cours
also
introduc
special
predic
provid
recogn
solut
problem
provid
system
websit
http
let
note
also
possibl
handl
problem
higher
polynomi
hierarchi
instanc
one
solv
proposit
asp
instanc
implement
algorithm
present
jakl
purpos
like
allow
assign
vertex
eral
hierarchi
assign
exampl
assign
deal
might
subsidiari
assign
use
determin
respect
assign
valid
detail
account
beyond
scope
paper
refer
reader
system
websit
exampl
let
brieﬂi
summar
main
featur
mani
case
user
implement
program
exchang
node
join
node
offer
default
implement
certain
problem
default
overridden
program
user
exploit
full
languag
accept
gringo
restrict
predic
reserv
tabl
give
summari
predic
also
point
circumst
depend
program
problem
type
predic
use
predic
use
fact
constitut
problem
instanc
suppli
verbatim
exchang
join
program
system
system
descript
written
compil
mani
platform
main
librari
use
sharp
take
care
construct
tree
decomposit
input
graph
well
sharp
provid
skeleton
flat
data
manag
sharp
us
htdecomp
implement
sever
heurist
hyper
tree
decomposit
see
also
dermaku
famili
asp
tool
see
also
gebser
recent
survey
ﬁnalli
use
ground
solv
asp
program
figur
depict
control
ﬂow
compon
simpliﬁ
way
initi
par
instanc
construct
hypergraph
represent
use
htdecomp
see
http
see
http
see
http
bliem
morak
woltran
figur
ﬂowchart
illustr
simpliﬁ
interplay
compon
asp
solver
comput
tupl
detail
figur
pars
instanc
popul
tabl
flatten
child
tabl
materi
solut
htdecomp
decompos
sharp
visit
next
node
done
ye
build
hypertre
decomposit
sharp
respons
travers
tree
node
call
ﬂatten
child
tabl
convert
set
fact
given
asp
solver
comput
new
tupl
answer
set
collect
popul
current
node
tabl
node
process
like
reconstruct
solut
sinc
leav
decomposit
part
well
solv
asp
program
ternal
librari
immedi
take
advantag
improv
librari
thu
also
possibl
switch
anoth
asp
solver
altogeth
without
chang
intern
except
cours
part
call
solver
likewis
approach
allow
replac
tree
decomposit
part
weaker
efﬁcient
concept
like
graph
cut
etc
sinc
user
provid
asp
program
exchang
option
join
node
runtim
independ
particular
problem
solv
mean
need
recompil
order
chang
dynam
program
algorithm
use
box
rapid
prototyp
tool
wide
rang
problem
execut
binari
user
adjust
behavior
use
line
option
import
one
brieﬂi
describ
tabl
problem
instanc
must
set
fact
read
standard
input
parser
recogn
predic
declar
hyper
edg
whose
name
given
option
fact
introduc
hyper
edg
instanc
graph
argument
hyper
edg
predic
implicitli
declar
instanc
graph
set
vertex
note
tree
decomposit
algorithm
use
current
allow
isol
vertex
real
limit
usual
solut
modiﬁ
instanc
without
isol
vertex
trivial
extend
execut
binari
dflat
illustr
follow
exampl
call
suppos
instanc
ﬁle
name
exchang
program
ﬁle
name
section
instruct
print
ber
solut
enumer
dflat
edg
data
ﬂow
procedur
within
node
indic
dash
box
illustr
figur
note
also
featur
default
join
implement
use
asp
depict
declar
problem
solv
use
tree
decomposit
asp
tabl
import
option
argument
mean
mandatori
least
mandatori
option
option
use
problem
instanc
predic
declar
hyper
edg
argument
predic
implicitli
declar
vertex
input
graph
ﬁle
name
asp
program
process
exchang
node
ﬁle
name
asp
program
ing
join
node
omit
default
implement
use
speciﬁ
kind
solut
user
terest
either
enumer
default
count
decis
experi
section
brieﬂi
report
ﬁrst
experiment
result
discuss
problem
compar
encod
monolith
one
use
gringo
clasp
stanc
limit
minut
cpu
time
memori
instanc
struct
small
treewidth
start
structur
introduc
random
element
desir
ﬁxed
decomposit
width
reach
tradit
asp
solver
employ
clever
heurist
quickli
either
ﬁnd
model
detect
unsatisﬁ
therebi
abl
solv
decis
variant
problem
ularli
well
contrast
dynam
program
approach
current
alway
calcul
tupl
tabl
way
whatev
problem
variant
may
ﬁnal
materi
stage
solut
assembl
differ
depend
problem
type
sat
prime
exampl
problem
tradit
asp
solver
success
solv
decis
variant
efﬁcient
howev
longer
sufﬁc
mere
ﬁnd
model
deal
count
enumer
problem
decomposit
exploit
pay
small
treewidth
especi
great
number
solut
experi
monolith
encod
inde
soon
hit
time
limit
hand
even
sooner
ran
memori
enumer
due
materi
solut
memori
time
number
solut
increas
rapidli
larger
instanc
motiv
improv
materi
procedur
futur
increment
solv
techniqu
excel
count
variant
problem
could
solv
instanc
matter
second
monolith
program
ran
time
soon
figur
illustr
strength
weak
count
decis
variant
sat
although
monolith
program
almost
instantan
solv
decis
problem
test
instanc
run
time
count
problem
soon
explod
standard
provid
dedic
function
count
bliem
morak
woltran
figur
comparison
monolith
encod
decis
count
variant
sat
stanc
treewidth
determin
optimum
cost
minimum
vertex
cover
instanc
treewidth
thu
implicitli
enumer
answer
set
wherea
remain
almost
unaffect
averag
although
time
tradit
perform
efﬁcient
decis
problem
problem
difﬁculti
particular
ground
becom
huge
investig
show
cyclic
order
problem
often
outperform
monolith
program
could
also
observ
run
time
heavili
depend
construct
tree
decomposit
reason
averag
perform
multipl
tree
decomposit
instanc
size
minimum
vertex
cover
problem
prove
strong
suit
figur
optim
problem
gener
stop
ﬁrst
solut
found
option
tradit
solver
sinc
yet
undiscov
solut
might
lower
cost
anoth
advantag
tradit
solver
least
case
clasp
requir
two
run
count
enumer
optim
solut
ﬁrst
run
serf
determin
optimum
cost
second
start
scratch
output
model
cost
contrast
requir
one
run
end
immedi
inform
need
determin
optimum
cost
conclud
remark
recal
main
purpos
provid
mean
specifi
dynam
program
algorithm
declar
compet
tional
asp
solver
refrain
extens
benchmark
paper
nonetheless
conclud
particularli
success
optim
count
problem
provid
treewidth
small
especi
number
solut
size
monolith
ground
explod
conclus
summari
introduc
novel
system
allow
specifi
dynam
program
algorithm
hyper
tree
decomposit
mean
gram
end
employ
asp
system
underli
infer
engin
comput
local
solut
speciﬁ
algorithm
provid
case
studi
illustr
rich
syntax
asp
allow
succinct
speciﬁc
variablestim
lmonolith
count
monolith
decis
count
decis
verticestim
declar
problem
solv
use
tree
decomposit
asp
algorithm
exampl
program
given
section
benchmark
instanc
use
section
free
softwar
avail
http
relat
work
sever
form
support
dynam
program
exist
world
prolog
tabl
intermedi
result
natur
concept
mention
system
tlp
guo
gupta
zhou
world
datalog
refer
dyna
system
eisner
filardo
provid
wide
rang
featur
memoiz
side
spectrum
work
gottlob
show
simpl
formal
monad
datalog
place
instead
monad
mso
logic
tractabl
term
treewidth
courcel
latter
approach
thu
theoret
interest
main
differ
mention
system
user
make
use
full
languag
asp
particular
employ
guess
check
methodolog
subproblem
howev
mention
system
far
support
dynam
program
connect
hyper
tree
decomposit
futur
work
next
step
compar
detail
tion
approach
term
model
capac
perform
issu
well
plan
provid
differ
decomposit
option
within
particular
ipat
even
rather
simpl
efﬁcient
decomposit
graph
say
simpl
split
two
part
might
practic
lead
perform
gain
monolith
encod
line
optim
concern
lazi
evalu
strategi
increment
asp
techniqu
gebser
develop
final
relat
approach
reactiv
asp
gebser
might
provid
interest
new
research
direct
acknowledg
support
vienna
univers
technolog
special
fund
tive
projekt
refer
bodlaend
tourist
guid
treewidth
acta
cybern
bodlaend
discov
treewidth
proc
sofsem
lnc
vol
springer
bodlaend
koster
combinatori
optim
graph
bound
treewidth
comput
bodlaend
koster
treewidth
comput
upper
bound
inf
comput
brewka
eiter
truszczynski
answer
set
program
glanc
commun
acm
cai
huang
liu
rosamond
song
parameter
complex
biopolym
sequenc
comparison
comput
courcel
graph
rewrit
algebra
logic
approach
handbook
ical
comput
scienc
volum
formal
model
semat
van
leeuwen
elsevi
mit
press
bliem
morak
woltran
dermaku
ganzow
gottlob
mcmahan
musliu
samer
heurist
method
hypertre
decomposit
proc
micai
lnc
vol
springer
eisner
filardo
dyna
extend
datalog
modern
full
sion
avail
http
gebser
grote
kaminski
schaub
reactiv
answer
set
ming
proc
lpnmr
lnc
vol
springer
gebser
kaminski
kaufmann
ostrowski
schaub
thiel
user
guid
gringo
clasp
clingo
iclingo
preliminari
draft
avail
http
gebser
kaufmann
kaminski
ostrowski
schaub
schneider
potassco
potsdam
answer
set
solv
collect
commun
gebser
sabuncu
schaub
increment
answer
set
program
base
system
ﬁnite
model
comput
commun
gelfond
lifschitz
classic
negat
logic
program
disjunct
databas
new
gener
comput
gottlob
greco
scarcello
tractabl
optim
problem
structur
restrict
proc
icalp
lnc
vol
springer
gottlob
leon
scarcello
hypertre
decomposit
tractabl
queri
comput
syst
sci
gottlob
pichler
wei
monad
datalog
ﬁnite
structur
bound
treewidth
acm
tran
comput
log
greco
scarcello
structur
tractabl
enumer
csp
solut
proc
lnc
vol
springer
guo
gupta
simplifi
dynam
program
via
tabl
pract
exper
jakl
pichler
woltran
program
bound
treewidth
proc
ijcai
aaai
press
koster
van
hoesel
kolen
solv
partial
constraint
faction
problem
network
larson
survey
dynam
program
comput
procedur
ieee
tran
automat
contr
leon
pfeifer
faber
eiter
gottlob
perri
scarcello
dlv
system
knowledg
represent
reason
acm
tran
comput
log
marek
truszczi
stabl
model
altern
logic
ming
paradigm
logic
program
paradigm
perspect
springer
niemel
logic
program
stabl
model
semant
constraint
program
paradigm
ann
math
artif
intel
robertson
seymour
graph
minor
iii
planar
comb
theori
ser
samer
szeider
algorithm
proposit
model
count
discret
algorithm
wagner
dynam
program
mathematica
journal
jiao
berger
approach
protein
structur
diction
proc
csb
zhou
languag
featur
architectur
corr
