discrete
mathematics
theoretical
computer
science
dmtcs
vol
20:1
2018
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
kasper
szabo
lyngsie
technical
university
denmark
denmark
received
5th
jan.
2017
revised
16th
apr
2018
accepted
24th
may
2018.
let
set
integers
graph
said
s-property
exists
s-edge-weighting
two
adjacent
vertices
different
sums
incident
edge-weights
paper
characterise
bridgeless
bipartite
graphs
trees
without
0,1
-property
particular
problem
belongs
graphs
np-complete
graphs
keywords
1-2-3-conjecture
neighbour-sum-distinguishing
edge-weightings
bipartite
graphs
introduction
problems
investigated
paper
highly
related
well-known
1,2,3-conjecture
formulated
one
way
approach
conjecture
see
example
study
-property
graphs
two
integers
deﬁned
following
way
graph
said
-property
exists
mapping
pairs
adjacent
vertices
e∈e
denote
edges
incident
respectively
cid:80
e∈e
cid:54
cid:80
call
neighbour
sum-distinguishing
edge-weighting
weights
investigated
problem
determining
whether
given
bipartite
graph
-property
restriction
bipartite
graphs
motivated
result
dudek
wajc
saying
problem
np-complete
general
graphs
particular
asked
natural
question
whether
problem
polynomial
bipartite
graphs
considered
problem
results
present
paper
answer
afﬁrmative
bridgeless
bipartite
graphs
trees
also
proved
following
theorem
theorem
property
skowronek-kazi´ow
investigated
problem
determining
whether
graph
-edge-
weighting
following
vertex-colouring
proper
vertex
assign
product
edge-weights
incident
colour
product-property
-property
skowronek-kazi´ow
veriﬁed
various
classes
bipartite
graphs
example
bipartite
graphs
distributed
creative
commons
attribution
4.0
international
license
issn
1365–8050
every
2-connected
3-edge-connected
bipartite
graph
cid:13
2018
author
kasper
szabo
lyngsie
minimum
degree
least
skowronek-kazi´ow
also
asked
characterization
bipar-
tite
graphs
particular
trees
-edge-weightings
property
mentioned
results
present
paper
give
characterization
trees
bridgeless
bipartite
graphs
bipartite
graph
without
0,1
-property
said
bad
thomassen
zhang
gave
complete
characterisation
bipartite
graphs
without
property
graph
odd
multi-cactus
deﬁned
follows
take
collection
cycles
length
modulo
edges
coloured
alternately
red
green
form
connected
simple
graph
pasting
cycles
together
one
one
tree-like
fashion
along
green
edges
finally
replace
every
green
edge
multiple
edge
multiplicity
graph
one
edge
two
vertices
also
called
odd
multi-cactus
easily
checked
odd
multi-cactus
property
mentioned
graphs
characterise
bipartite
graphs
without
1,2
-property
theorem
multi-cactus
since
odd
multi-cactus
recognisable
polynomial-time
answers
part
problem
concerning
-property
pointed
theorem
extends
positive
edge-
weights
distinct
parity
edge-weights
also
remarked
bipartite
graph
minimum
degree
least
-property
pairs
non-negative
integers
distinct
parity
thus
remains
open
characterise
bipartite
graphs
cut-vertices
minimum
degree
0,1
-property
gave
following
example
bad
graph
-property
two
6-cycles
connected
path
length
noted
construct
inﬁnite
number
bad
graphs
property
following
procedure
take
two
graphs
without
-property
join
path
length
modulo
even
generalise
procedure
let
integer
let
path
length
modulo
join
intermediate
vertex
bad
graphs
edges
join
end-vertices
bad
graphs
see
figure
create
new
bad
graph
-property
connected
bipartite
graph
without
-property
odd
fig
construction
bad
graphs
1,2
-property
although
preceding
paragraph
shows
large
class
bipartite
graphs
without
0,1
-property
list
still
complete
even
trees
demonstrated
tree
figure
·········v1v2vn−1vng2,1g2,2g2
sgn−1,1gn−1,2gn−1
...
gn,1gn,2gn
s+1
...
g1,1g1,2g1
s+1
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
fig
tree
without
0,1
-property
thus
large
class
bad
graphs
odd
multi-cacti
seems
0,1
-property
different
1,2
-property
however
note
procedure
always
create
bridges
gives
hint
0,1
-property
1,2
-property
might
behave
similar
way
allow
bridges
indeed
true
prove
section
theorem
connected
bridgeless
bipartite
graph
without
-property
odd
multi-cactus
mentioned
theorem
odd
multi-cactus
recognisable
polynomial
time
answers
part
problem
concerning
0,1
-property
bridgeless
bipartite
graphs
section
provide
additional
operations
constructing
trees
without
-property
class
trees
without
-property
obtain
using
operations
call
recognisable
polynomial
time
whilst
class
difﬁcult
describe
show
gives
full
characterisation
bad
trees
theorem
tree
0,1
-property
unless
member
taken
together
theorems
show
marked
difference
0,1
-problem
1,2
problem
indeed
bridgeless
bipartite
graphs
theorems
show
class
graphs
without
0,1
-property
class
graphs
without
1,2
-property
precisely
hand
theorems
show
far
case
trees
e∈e
cid:54
cid:80
bridgeless
bipartite
graphs
without
0,1
-property
weighting
vertex
call
sum
cid:80
let
bipartite
graph
-weighting
map
given
e∈e
weighted
degree
cent
vertices
holds
cid:80
induced
colour
induced
convenience
weighted
degree
vertex
also
denoted
say
-weighting
neighbour
sum-distinguishing
proper
pairs
adja-
e∈e
induced
vertex-colouring
proper
-weighting
two
adjacent
vertices
weighted
degree
say
edge
conﬂict
two
adjacent
vertices
weighted
degree
parity
call
edge
parity
conﬂict
note
parity
conﬂict
necessarily
conﬂict
mapping
spanning
subgraph
vertices
mod
say
f-factor
modulo
factors
play
important
role
investigations
-properties
bipartite
graphs
particular
following
result
mentioned
lemma
cid:80
v∈v
mod
contains
f-factor
modulo
let
connected
graph
mapping
satisfying
kasper
szabo
lyngsie
also
pointed
immediately
implies
bipartite
graphs
one
bi-
partition
set
even
size
-property
numbers
different
parity
since
weighted
degree
vertices
belonging
even-sized
bipartition
set
get
odd
weighted
degree
vertices
get
even
weighted
degree
problem
reduced
case
bipartition
sets
odd
size
another
useful
tool
lemma
let
natural
number
let
connected
graph
let
lemma
independent
set
vertices
vertex
degree
least
vertex
except
possibly
one
degree
least
assume
vertex
adjacent
bridge
vertex
edge
incident
deletion
results
connected
graph
unless
|a|
vertices
degree
six
components
joined
two
distinct
vertices
seen
later
paper
lemma
work
well
together
assumptions
following
way
let
simple
bipartite
graph
odd
number
vertices
biparti-
tion
sets
let
vertex
belonging
least
neighbours
cutvertex
assume
neighbour
greater
degree
vertex
said
local
maximum
degree
neighbour
degree
incident
bridge
furthermore
assume
exceptional
case
lemma
remove
choose
neighbours
degree
ﬁnd
proper
-weighting
follows
remove
edge
incident
maintain
connectivity
lemma
call
resulting
graph
cid:48
first
consider
case
even
degree
lemma
ﬁnd
-weighting
cid:48
vertices
odd
weighted
degree
vertices
even
weighted
degree
extend
-weighting
whole
assigning
weight
edges
incident
weight
edges
parity
conﬂicts
neighbours
edges
weight
weighted
degree
strictly
greater
neighbours
case
odd
degree
ﬁnd
-weighting
cid:48
vertices
even
weighted
degree
vertices
odd
weighted
degree
extend
-weighting
whole
assigning
weight
edges
incident
weight
edges
note
shows
whenever
consider
vertex
cutvertex
ﬁnd
-weighting
edges
incident
weight
parity
conﬂicts
neighbours
prove
theorem
need
three
facts
simple
odd
multi-cacti
formulated
lem-
mas
odd
multi-cactus
deﬁnition
contains
least
two
cycles
containing
two
adjacent
vertices
least
three
neighbours
vertices
two
neighbours
unless
single
cycle
possibly
multiple
edges
cycles
type
called
end-cycles
lemma
let
cid:54
simple
odd
multi-cactus
vertex
weighting
vertices
opposite
bipartition
set
get
weighted
degree
vertices
get
weighted
degree
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
proof
proof
induction
number
vertices
easy
check
statement
true
single
cycle
length
modulo
assume
let
end-cycle
vertex
two
neighbours
assume
6-cycles
since
subdividing
edges
four
vertices
preserves
conclusion
lemma
thus
say
v1v2
···
v6v1
least
three
neighbours
since
use
induction
hypothesis
extend
-weighting
whole
let
-weighting
let
vertex
let
natural
number
finally
let
denote
vertex-colouring
induced
let
denote
colouring
obtained
replacing
colour
colour
proper
vertex-colouring
say
proper
-weighting
degree
increased
may
thought
neighbour
sum-distinguishing
edge-weighting
vertex
pre-assigned
weight
lemma
let
cid:54
simple
odd
multi-cactus
furthermore
let
two
vertices
belonging
bipartition
set
possibly
proper
-weighting
weighted
degrees
increased
weighted
degree
increased
proof
first
note
case
follows
lemma
assume
cid:54
proof
induction
number
vertices
easy
check
statement
holds
single
cycle
length
modulo
proof
lemma
choose
end-cycle
one
say
vertex
two
neighbours
may
assume
v1v2
···
v6v1
least
three
neighbours
use
induction
hypothesis
get
proper
-weighting
weighted
degree
increased
easily
extend
-weighting
whole
contradiction
assume
one
cases
similar
one
say
use
lemma
choosing
special
vertex
get
-weighting
vertices
opposite
bipartition
set
get
weight
vertices
get
weight
extend
-weighting
whole
deﬁning
v1v6
v4v5
v2v3
v3v4
v5v6
use
lemma
choosing
special
vertex
get
-weighting
extend
whole
deﬁning
v1v6
v3v4
v2v3
v4v5
v5v6
leaves
case
one
assume
bipartition
set
start
considering
case
case
use
induction
hypothesis
choosing
special
vertices
extend
-weighting
letting
edge
v1v6
play
role
extra
weight
deﬁning
v1v6
v2v3
different
weighted
degrees
induction
hypothesis
choose
weights
v3v4
v5v6
different
avoid
conﬂicts
finally
deﬁne
v4v5
avoid
conﬂicts
case
remains
use
lemma
choosing
special
vertex
extend
-weighting
deﬁning
v2v3
v1v6
v3v4
v5v6
v4v5
using
lemma
induction
proof
lemma
easily
derive
lemma
kasper
szabo
lyngsie
lemma
let
odd
multi-cactus
red-green
edge-colouring
unique
cid:48
obtained
replacing
red
edge
edge
multiplicity
-property
graph
suspended
path
suspended
cycle
path
cycle
v1v2
...
intermediate
vertices
degree
end-vertices
degree
least
vertices
...
distinct
except
possibly
suspended
cycle
small
facts
established
ready
proof
theorem
proof
follows
approach
proof
theorem
new
problems
arise
dealt
along
way
end
proof
reader
referred
proof
theorem
sufﬁces
prove
connected
bridgeless
bipartite
graph
without
-property
odd
multi-cactus
suppose
theorem
false
let
smallest
counterexample
among
bridgeless
bi-
partite
graphs
without
0,1
-property
odd
multi-cacti
fewest
vertices
subject
fewest
edges
note
induction
lemma
assume
edge
multiplicity
greater
must
multiplicity
bridge
simple
graph
underlying
let
two
bipartition
sets
remark
following
lemma
assume
odd
size
first
note
vertex
adjacent
one
vertex
cid:48
since
bridgeless
multiplicity
least
edge
cid:48
cid:48
cid:48
cid:54
cid:48
incident
cid:48
graph
cid:48
connected
lemma
graph
cid:48
contains
spanning
subgraph
vertices
cid:48
cid:48
cid:48
odd
degree
vertices
cid:48
even
weighted
degree
assigning
weight
edges
weight
edges
get
proper
-weighting
contradiction
thus
assume
vertex
adjacent
one
vertex
cid:48
let
denote
endblock
note
implies
multiple
edges
claim
contains
suspended
path
length
assume
y1xy2
suspended
path
length
lemma
exists
spanning
subgraph
cid:48
vertices
odd
degree
vertices
even
degree
construct
-weighting
cid:48
cid:48
vertex
odd
weighted
degree
vertex
even
weighted
degree
assigning
weight
edges
weight
edges
outside
extend
weighting
-weighting
whole
graph
deﬁning
xy1
xy2
possible
conﬂicts
xy1
xy2
case
cid:48
cid:48
remove
edge
y1z1
incident
edge
y2z2
incident
cid:48
still
connected
graph
avoid
situation
follows
using
lemma
redeﬁne
subgraph
vertices
odd
weighted
degree
vertices
even
weighted
degree
deﬁne
cid:48
-weighting
assigning
weight
edges
weight
edges
proper
-weighting
assume
remove
two
edges
incident
respectively
cid:48
still
connected
graph
must
cycle
going
cid:48
since
otherwise
lie
distinct
blocks
cid:48
since
degree
least
since
bridgeless
possible
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
remove
edge
still
connected
graph
contradiction
ﬁrst
look
case
cid:48
cid:48
swap
weights
change
1-weights
weights
0-weights
1-weights
change
parity
weighted
degrees
weighted
degree
redeﬁne
cid:48
accordingly
put
back
give
edges
xy1
xy2
weight
gives
proper
0,1
-weighting
assume
cid:48
cid:48
actually
assume
cid:48
since
otherwise
cid:48
repeat
proof
previous
case
swapping
weights
weighted
degree
least
assume
cycles
going
cid:48
also
otherwise
simply
swap
weights
cycle
containing
possible
case
consists
precisely
two
connected
components
bipartition
sets
containing
exactly
one
neighbour
see
figure
let
denote
neighbours
respectively
let
denote
neighbours
respectively
allow
possibility
one
even
size
example
subgraph
consisting
edges
weighted
cid:48
odd
number
odd
degree
vertices
possible
odd
size
sets
must
different
parity
particular
one
say
even
size
furthermore
proper
-weighting
wg2
ﬁnd
proper
-weighting
whole
graph
weight
y1x2
y2z2
follows
weighted
degrees
say
odd
parity
wg2
bipartition
sets
even
size
lemma
implies
proper
0,1
-weighing
wg−g2
get
even
weighted
degree
deﬁne
proper
0,1
-weighting
wg2
wg−g2
y1x2
y2z2
weighted
degree
parity
wg2
without
loss
generality
assume
even
weighted
degree
wg2
odd
weighted
degree
wg2
proper
0,1
-weighting
wg−g2
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
extending
wg−g2
wg2
whole
possible
conﬂict
arise
y1x2
always
avoid
conﬂict
swapping
weights
edges
cycle
containing
kind
argument
shows
proper
-weighting
weighted
degree
increased
increased
since
let
edges
x2y1
z2y2
play
roles
extra
weights
minimality
subgraph
must
either
odd
multi-cactus
contain
bridge
lemma
shows
odd
multi-cactus
hence
contains
bridge
note
shows
cid:54
since
endblock
one
say
cutvertex
also
cutvertex
following
weight
vertices
odd
degree
vertices
even
degree
weight
vertices
odd
degree
vertices
even
degree
two
-weightings
extend
whole
graph
assigning
weight
edges
incident
except
assign
weight
edges
y1x1
y1x2
also
y1x
must
cutvertex
since
end-block
follows
cutvertex
cutvertex
replaced
replaced
possibility
cutvertex
lemma
-weighting
wg1
vertices
x1\
get
odd
weighted
degree
vertices
get
even
weighted
degree
-weighting
wg2
vertices
x2\
get
even
weighted
degree
vertices
get
odd
weighted
degree
extend
wg1
wg2
-weighting
whole
assigning
weight
edges
y1x2
y2x1
weight
edges
y2x
y1x
y2z2
y1x1
kasper
szabo
lyngsie
possible
conﬂicts
weighted
degree
case
since
cutvertex
cycle
containing
two
edges
weight
incident
swap
weights
cycle
avoid
conﬂicts
contradicts
bad
graph
fig
illustration
situation
claim
claim
contains
suspended
path
cycle
length
assume
y1x1y2x2y1
suspended
cycle
length
lemma
proper
weighting
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
proper
-weighting
extended
whole
graph
assigning
weight
edges
y1x1
x2y1
weight
edges
x1y2
y2x2
contradiction
case
y1x1y2x2y3
suspended
path
length
treated
way
sus-
pended
path
length
proof
previous
claim
choose
graph
x1−
y2−
cid:48
claim
contains
suspended
path
cycle
length
least
suppose
y1x1y2x2y3x3
path
degree
delete
add
edge
y1x3
already
edge
resulting
graph
odd
multi-cactus
proper
-weighting
minimal-
ity
-weighting
used
ﬁnd
proper
0,1
-weighting
put
back
vertices
y3x3
originally
give
y1x1
y3x3
weight
y1x3
delete
edge
give
y2x2
opposite
colour
give
x1y2
x2y3
distinct
colours
since
different
colours
two
choices
one
give
proper
-weighting
y1x3
begin
assign
weight
edges
y1x1
y3x3
give
y2x2
weight
give
x1y2
x2y3
distinct
colours
two
choices
one
give
proper
-weighting
contradiction
assume
cid:48
odd
multi-cactus
since
odd
multi-cactus
possibility
obtained
y1xy2g1g2x1x2z1z2
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
odd
multi-cactus
subdividing
green
edge
joining
two
vertices
degree
least
four
vertices
case
ﬁnd
another
path
cid:48
cid:48
deﬁne
cid:48
cid:48
odd
multi-cactus
unless
consists
two
vertices
joined
paths
length
case
easy
check
proper
-weighting
degree
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
claims
degree-2
vertices
endblocks
lie
suspended
path
length
replace
suspended
paths
length
edge
form
multi-graph
edges
arising
suspended
paths
called
blue
edges
note
bridgeless
minimum
degree
endblock
least
let
endblock
possibly
cid:54
let
unique
cutvertex
contained
deletion
pair
neighbouring
vertices
disconnects
deﬁne
graph
cid:48
follows
select
edge
y0z0
disconnected
component
containing
smallest
possible
possibly
one
union
component
together
edges
connecting
called
cid:48
otherwise
deletion
pair
adjacent
vertices
leaves
connected
graph
deﬁne
cid:48
note
case
must
cid:48
since
deletion
together
neighbours
disconnects
claim
end-block
vertices
degree
overall
strategy
proving
claim
ﬁnd
vertex
local
maximum
degree
use
procedure
explained
remark
following
lemma
ﬁnd
proper
-weighting
edges
incident
weight
case
choose
end-block
whose
cutvertex
adjacent
one
block
suppose
claim
false
let
cid:48
choose
distinct
vertex
maximum
degree
want
choose
remove
avoid
exceptional
case
lemma
set
neighbours
degree
exceptional
case
occur
neighbour
degree
exceptional
case
also
avoided
possible
choose
unless
vertices
degree
impossible
avoid
exceptional
case
must
whenever
remove
vertex
four
neighbours
resulting
graph
six
components
exactly
two
neighbours
case
choose
component
arising
deleting
neighbours
six
components
containing
maximal
components
easily
seen
isolated
vertices
otherwise
redeﬁne
neighbour
joined
component
containing
contradict
choice
isolated
vertices
must
degree
contradiction
shows
always
ﬁnd
maximum
degree
avoid
exceptional
case
lemma
set
neighbours
degree
choose
found
deﬁned
back
considering
original
graph
look
three
different
subcases
neighbour
neighbour
cid:54
neighbour
kasper
szabo
lyngsie
subcase
subcase
dealt
described
remark
following
lemma
minimality
none
neighbours
incident
bridge
subcase
assume
degree
strictly
greater
since
otherwise
subcase
implies
degree
least
assume
vertices
maximum
degree
adjacent
since
otherwise
redeﬁne
subcase
note
implies
never
exceptional
case
lemma
delete
vertex
maximum
degree
deﬁne
neighbours
degree
assume
precisely
one
neighbour
component
since
otherwise
subcase
except
also
remove
two
edges
component
end
colour-conﬂict
made
sure
swap
weights
cycle
avoiding
contains
two
edges
weight
incident
avoid
conﬂict
give
proper
weighting
precisely
one
neighbour
component
also
assume
one
component
contains
neighbour
since
otherwise
remove
two
edges
incident
going
two
different
compo-
nents
distinct
use
weight-swapping
argument
avoid
conﬂict
time
cycle
also
neighbour
component
since
discon-
nected
must
case
case
redeﬁne
subcase
assume
component
containing
neighbour
start
giving
maximum
weighted
degree
assigning
least
one
edge
incident
neighbour
degree
also
assign
weight
unique
edge
z0z1
joining
component
actually
since
neighbours
weighted
degree-parity
neighbours
degree
incident
least
two
edges
weighted
assume
weighted
degree
edge
z0y0
weight
otherwise
swap
weights
cycle
using
edges
z0z1
z0y0
avoid
conﬂict
swap
weights
cycle
containing
two
edges
incident
weight
conﬂicts
create
neighbour
degree
conﬂicts
arise
cycle
goes
two
edges
incident
weight
neighbour
degree
incident
two
edges
weight
call
pair
weight
0-edges
forbidden
pair
edges
show
always
ﬁnd
cycle
containing
two
edges
incident
weight
use
forbidden
pair
edges
note
neighbours
incident
forbidden
pair
edges
degree
therefore
neighbours
let
...
denote
neighbours
since
weighted
degree
strictly
greater
vertex
cid:54
sufﬁces
ﬁnd
path
vertex
cid:48
connected
graph
connected
minimality
using
forbidden
pair
edges
since
deﬁne
cycle
z0y0
cid:48
weight
z0z
cid:48
path
z0y0
weight
z0z
cid:48
see
figure
since
graph
connected
path
assume
uses
forbidden
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
pairs
edges
without
loss
generality
let
av1
v1b
ﬁrst
forbidden
pair
edges
uses
starting
since
adjacent
follows
since
otherwise
ﬁnd
path
using
forbidden
pair
edges
shows
path
vertex
using
one
forbidden
pair
edges
look
paths
using
one
pair
forbidden
edges
y0vi
via
...
choose
path
among
goes
neighbours
let
y0vi
via
pair
forbidden
edges
contains
since
y0vi
via
forbidden
pair
vertex
neighbour
cid:48
weight
vertex
path
cid:48
must
since
connected
path
cid:48
cid:48
use
forbidden
pair
edges
otherwise
graph
induced
cid:48
contains
desired
path
vertex
avoiding
forbidden
pairs
edges
let
ﬁrst
pair
forbidden
edges
cid:48
uses
starting
cid:48
must
disjoint
since
otherwise
graph
induced
cid:48
contains
desired
path
avoiding
forbidden
pairs
edges
furthermore
must
since
otherwise
path
cid:48
cid:48
deﬁned
y0v
together
subpath
cid:48
cid:48
ivi
subpath
desired
path
avoiding
forbidden
pairs
edges
path
cid:48
cid:48
contradicts
maximality
takes
care
subcase
neighbour
component
case
noted
subcase
redeﬁning
subpath
cid:48
cid:54
viv
cid:48
followed
cid:48
cid:48
cid:48
fig
illustation
situation
proof
claim
dashed
edges
indicate
pairs
forbidden
edges
subcase
situation
less
subcase
except
vertex
degree
assume
exceptional
case
lemma
remove
deﬁne
set
neighbours
degree
z1z0y001111v2v3w0v1z2h11
kasper
szabo
lyngsie
otherwise
redeﬁne
subcase
case
degree
degree
neighbours
choose
non-neighbour
degree
component
arising
deleting
neighbours
six
components
containing
maximal
components
easily
seen
isolated
vertices
contradicts
minimum
degree
assume
strict
local
degree
maximum
strictly
greater
degree
implies
degree
least
let
denote
bipartition
set
containing
let
denote
opposite
bipartition
set
ﬁnd
-weighting
edges
incident
weight
vertices
weighted
degree
parity
vertices
weighted
degree
parity
different
conﬂict
recall
incident
two
blocks
must
precisely
two
neighbours
since
otherwise
avoid
conﬂict
swapping
weights
cycle
using
two
edges
incident
weight
ar-
gument
assume
weights
two
edges
x0w1
x0w2
different
since
implies
must
least
two
neighbours
joined
edge
weighted
graph
connected
minimality
ﬁnd
cycle
two
edges
x0w3
x0w4
avoiding
swap
weights
cycle
thereby
avoid
conﬂict
completes
case
since
assume
case
case
considering
longest
path
block-tree
case
choose
end-block
incident
endblocks
...
union
blocks
b−1
satisﬁes
b−1
connected
case
proofs
subcases
exactly
situation
different
incident
...
deﬁne
let
denote
bipartition
set
containing
let
denote
opposite
bipartition
set
...
let
denote
vertex
deﬁned
way
instead
assume
neighbours
different
strictly
lower
degree
furthermore
precisely
two
neighbours
vi,1
vi,2
g−1
...
assume
vi,1
...
degree
vi,2
since
otherwise
redeﬁne
vi,2
...
let
denote
part
belonging
respectively
assume
get
conﬂict
whenever
weight
giving
maximal
weighted
degree
noted
get
precisely
weight
cid:54
...
degree
either
look
ﬁve
different
subcases
even
odd
...
...
even
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
...
odd
subcase
least
recall
weighting
giving
weighted
degree
vertex
precisely
one
edge
weighted
going
g−1
...
weighting
giving
weighted
degree
vertex
get
precisely
weight
g−1
...
weight
-weighting
giving
maximum
weighted
degree
implies
sets
y−1
...
odd
size
even
size
since
otherwise
even
size
...
odd
size
subgraph
consisting
edges
weight
odd
number
vertices
odd
degree
similarly
-weighting
giving
maximum
weighted
degree
implies
sets
x−1
...
odd
size
ﬁnd
proper
-weighting
follows
...
weight
lemma
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
also
ﬁnd
-weighting
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
assume
gets
weighted
degree
weighted
degree
swap
weights
cycle
containing
two
edges
incident
union
-weightings
gives
-weighting
parity
conﬂicts
neighbours
however
weighted
degree
neighbours
degree
subcase
least
argument
subcase
sets
x−1
...
odd
size
even
size
sets
y−1
...
odd
size
ﬁnd
proper
-weighting
follows
...
weight
lemma
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
also
ﬁnd
-weighting
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
subcase
assume
weighted
degree
union
-weightings
gives
proper
-weighting
analogously
subcase
first
assume
even
least
deduce
-weighting
gets
weighted
degree
sets
y−1
...
odd
size
even
size
argument
-weighting
shows
sets
y−1
...
odd
size
even
size
contradiction
analogous
argument
holds
odd
subcase
least
sets
x−1
...
odd
size
weight
gets
maximum
weighted
degree
gets
weighted
degree
parity
conﬂicts
around
blocks
cid:54
weight
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
union
-weightings
gives
proper
-weighting
subcase
least
sets
y−1
...
odd
size
one
sets
x−1
...
must
even
size
x−1
even
size
weight
follows
b−1
weight
vertices
x−1
get
odd
weighted
degree
vertices
y−1
get
even
weighted
degree
furthermore
weighted
degree
weight
gets
max-
imum
weighted
degree
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
furthermore
degree
blocks
kasper
szabo
lyngsie
cid:54
weight
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
union
-weightings
gives
proper
-weighting
hence
assume
x−1
odd
size
one
...
say
even
size
weight
follows
weight
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
furthermore
weighted
degree
weight
gets
maximum
weighted
degree
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
weighted
degree
b−1
weight
vertices
x−1
get
odd
weighted
degree
vertices
y−1
get
even
weighted
degree
blocks
weight
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
union
-weightings
gives
proper
-weighting
completes
proof
claim
removal
pair
adjacent
vertices
leaves
connected
graph
must
3-regular
simply
work
otherwise
choose
work
endblock
subgraph
deﬁned
claim
claim
vertices
degree
suppose
ﬁrst
vertices
adjacent
small
argument
shows
unless
isomorphic
k3,3
vertex
removing
neighbours
would
leave
connected
graph
case
ﬁnd
proper
-weighting
lemma
isomorphic
k3,3
remove
vertices
except
resulting
subgraph
odd
number
vertices
lemma
proper
-weighting
without
parity-conﬂicts
edges
may
blue
checked
matter
blue
edges
arranged
-weighting
extended
whole
assume
vertex
adjacent
rest
proof
theorem
choose
non-neighbour
completes
proof
theorem
trees
without
0,1
-property
section
give
complete
characterisation
bad
trees
characterisation
consists
recursive
construction
using
three
classes
trees
certain
properties
immediately
gives
polynomial-time
algorithm
recognising
bad
trees
begin
deﬁning
properties
general
bipartite
graphs
ﬁrst
three
classes
described
follows
let
vertex
connected
bipartite
graph
even
number
vertices
bipartition
set
say
-graph
proper
0,1
-weighting
weighted
degree
increased
deﬁnition
motivated
following
easy
proposition
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
proposition
10.
let
graph
let
vertex
let
cid:48
graph
obtained
adding
two
vertices
edges
vv1
v1v2
graph
-graph
cid:48
bad
following
two
lemmas
show
recursive
way
construct
new
bad
bipartite
graphs
bad
bipartite
graphs
vertices
degree
two
results
hold
bipartite
graphs
trees
lemma
11.
let
simple
connected
bipartite
graph
without
-property
vertex
degree
cid:48
unique
neighbour
edges
incident
cid:48
bridges
proof
lemma
-weighting
parity
conﬂicts
problem
extending
-weighting
weighted
degree
cid:48
might
cid:48
contained
cycle
would
always
able
avoid
lemma
12.
let
simple
connected
bipartite
graph
assume
vertex
degree
let
cid:48
denote
neighbour
let
...
edges
incident
cid:48
cid:48
assume
edges
incident
cid:48
bridges
let
unique
component
containing
let
cid:48
denote
connected
graph
obtained
adding
vertices
cid:48
edges
graph
bad
graphs
cid:48
...
cid:48
bad
...
cid:48
cid:48
proof
figure
shows
illustration
situation
...
let
vertex
bad
proposition
gvi
-graph
adjacent
cid:48
cid:48
follows
proper
-weighting
edge
must
receive
weight
cid:48
weighted
degree
thus
-weighting
exists
bad
assume
bad
let
denote
bipartition
sets
cid:48
...
let
denote
bipartition
sets
lemma
assume
odd
size
lemma
-weighting
parity
conﬂicts
vertices
get
odd
degree
vertices
get
even
degree
problem
extending
-weighting
weight
cid:48
case
even
size
must
even
number
sets
odd
number
vertices
say
...
even
size
lemma
proper
-weighting
cid:48
gets
weighted
degree
apply
lemma
ﬁnd
-weighting
vertices
cid:48
get
odd
weighted
degree
vertices
cid:48
get
even
weighted
degree
weighting
weights
edges
...
weights
zero
extend
weighting
whole
assigning
weight
cid:48
contradicts
bad
even
size
proposition
cid:48
bad
bad
weight
vertex
incident
increased
contradiction
assume
proper
-weighting
weight
vertex
incident
increased
use
lemma
proper
-weighting
easily
extended
contradiction
kasper
szabo
lyngsie
fig
illustration
situation
explained
lemma
12.
describe
second
third
class
trees
use
characterise
bad
trees
special
cases
graphs
deﬁned
follows
let
vertex
connected
bipartite
graph
odd
number
vertices
let
two
non-negative
integers
say
-graph
must
get
weighted
degree
proper
-weightings
must
get
weighted
degree
proper
-weightings
weight
increased
classes
-trees
non-negative
integer
two
interest-
ing
special
cases
want
characterise
bad
trees
need
following
two
lemmas
describing
local
structure
around
-tree
lemma
13.
let
non-negative
integer
let
-tree
obtained
disjoint
union
gv1
gv2
-tree
together
number
trees
type
gv3
gv4
...
gvm
bad
trees
gm+1
...
gm+s
adding
vertex
edges
vv1
vv2
...
vvm
also
edge
bad
trees
gm+1
...
gm+s
proof
figure
illustrates
situation
assume
even
case
odd
similar
let
bipartition
sets
let
...
denote
edges
incident
let
...
denote
corresponding
components
let
denote
bipartition
sets
let
cid:48
denote
number
trees
odd
number
vertices
bipartition
sets
let
cid:48
denote
number
trees
even
number
vertices
bipartition
sets
among
...
let
denote
number
trees
among
...
even
number
vertices
x-bipartition
odd
number
vertices
-bipartition
assume
ordering
...
...
gn1
denote
trees
let
number
trees
among
...
odd
number
vertices
x-bipartition
even
number
vertices
-bipartition
assume
ordering
...
gn1+1
...
gn1+n2
denote
trees
furthermore
assume
trees
gn1+n2+1
...
gn1+n2+s
cid:48
odd
number
vertices
bipartition
sets
trees
gn1+n2+s
cid:48
...
gn1+n2+s
cid:48
cid:48
even
number
vertices
bipartition
sets
...
let
neighbour
···g1g2g3g4gngvv
cid:48
cid:48
g1g
cid:48
1vv
cid:48
g2g
cid:48
2···vv
cid:48
gng
cid:48
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
since
odd
one
|x|
even
however
even
lemma
proper
-weighting
gets
odd
weighted
degree
contradicts
tree
thus
|x|
even
odd
-weighting
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
-weighting
edges
vv1
...
vvn1
must
get
weight
since
otherwise
say
vv1
weighted
subgraph
consisting
edges
weighted
odd
number
odd
degree
vertices
similar
argument
edges
vvn1+1
...
vvn1+n2
get
weight
edges
vvn1+n2+1
...
vvn1+n2+s
cid:48
also
get
weight
follows
cid:48
lemma
edges
vvn1+n2+s
cid:48
...
vvn
get
weight
also
-weighting
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
means
-weighting
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
weight
increased
argue
see
-weighting
edges
vv1
...
vvn1
must
get
weight
edges
vvn1+1
...
vvn1+n2
get
weight
edges
vvn1+n2+1
...
vvn1+n2+s
cid:48
get
weight
edges
vvn1+n2+s
cid:48
...
vvn
get
weight
since
-tree
follows
cid:48
hence
start
showing
trees
gn1+n2+s
cid:48
...
must
trees
type
gvj
assume
case
let
tree
among
gn1+n2+s
cid:48
...
-weighting
weight
vvj
possible
conﬂict
weight
vertices
get
odd
weighted
degree
vertices
get
even
weighted
degree
weight
increased
put
back
let
vvj
play
role
extra
weight
weight
possible
conﬂict
since
-tree
must
conﬂict
also
get
weighted
degree
weight
vertices
get
even
weighted
degree
vertices
get
odd
weighted
degree
put
back
let
vvj
play
role
extra
weight
also
increase
weight
weight
s+2
conﬂicts
anywhere
contradiction
trees
gn1+n2+s
cid:48
...
must
trees
type
gvj
similar
arguments
show
trees
gn1+n2+1
...
gn1+n2+s
cid:48
must
bad
trees
remains
show
two
graphs
trees
type
gv1
gv2
start
showing
clearly
first
assume
even
...
-weighting
weight
vvj
weight
vvi
cid:54
...
weight
edges
vvn1+1
...
vv2n1−1
possible
conﬂict
weight
increased
vvj
...
weight
must
cid:48
cid:48
weight
increased
otherwise
proper
-weighting
weight
increased
cid:48
proper
-weighting
weight
edges
vv1
...
vvn1+n2
gets
weighted
degree
cid:48
contradicts
-tree
case
odd
similar
conclude
remains
show
trees
type
gv1
gv2
lemma
-weighting
weight
edges
vv2
...
vv2+s
cid:48
weight
edges
incident
possible
conﬂict
must
conﬂict
since
s+3
-tree
weighted
degree
proper
-weighting
must
use
-weighting
except
swap
weighted
degree
parities
trees
...
increase
weighted
degree
similarly
conclude
weighted
degree
proper
-weighting
kasper
szabo
lyngsie
degree
increased
must
interchanging
argument
implies
weighted
degree
proper
-weighting
must
weighted
degree
proper
-weighting
degree
increased
must
hence
trees
type
gv1
gv2
fig
illustration
situation
explained
lemma
13.
similarly
proof
lemma
describe
local
structure
around
-tree
lemma
14.
-tree
either
obtained
disjoint
union
gv1
gv2
-tree
together
number
trees
type
gv3
gv4
...
gvm
bad
trees
gm+1
...
gm+s−1
adding
vertex
edges
vv1
vv2
...
vvm
also
edge
bad
trees
gm+1
...
gm+s−1
obtained
disjoint
union
bad
graphs
...
number
graphs
type
gv1
gv2
...
gvn
adding
vertex
edges
vv1
vv2
...
vvn
also
bridges
joining
bad
graphs
vg1g2v1v2···g3g4gmv3v4vm···vm+1vm+2vm+sgm+1gm+2gm+s
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
fig
illustration
two
possible
situations
explained
lemma
14.
lemma
15.
bad
tree
distinct
obtained
either
-tree
adding
vertex
cid:48
joined
edge
k2-graphs
bridges
two
bad
trees
gluing
together
two
edges
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
degree
respectively
cid:48
respec-
cid:48
cid:48
tively
cid:48
degree
respectively
cid:48
cid:48
proof
suppose
lemma
false
look
smallest
counterexample
easy
check
statement
holds
bad
trees
diameter
assume
diameter
least
lemma
also
assume
vertices
degree
adjacent
vertices
degree
let
fourth
last
vertex
longest
path
let
cid:48
third
last
vertex
two
subtrees
obtained
removing
edge
cid:48
form
desired
construction
list
recursive
way
construct
bad
trees
figures
11.
class
bad
trees
obtained
way
starting
smallest
bad
graph
denoted
vg1g2v1v2···g3g4gm···gm+1gm+2gm+s−1v3v4vmvm+1vm+2vm+s−1case
vcase
···g1g2g3gn···b1b2b3bsv3
kasper
szabo
lyngsie
fig
illustrates
recursive
way
construct
-trees
fig
illustrates
obtain
-trees
bad
trees
vertices
constructionofgv
s+3
-treestwogv
s+1
s+2
-trees
v1v2g1g2somegv
cid:48
-trees
v3v4g3g4···vmgmsbadtrees
b1b2···bsv1v2g1g2v3v4g3g4···vmgmb1b2···bsvconstructionofgv
-treesonebadtreewithavertexofdegree1joinedtoavertexofdegree2
g1vg1v
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
fig
illustrates
recursive
way
construct
-trees
constructionofgv
s+1
-treesonegv
s+1
-tree
v1g1somegv
cid:48
-trees
v3v4g3g4···vmgms−1badtrees
b1b2···bs−1v1v2g1g2v3v4g3g4···vmgmb1b2···bs−1vonegv
s−1
s+2
-tree
v2g2orsbadtrees
b1b2···bssomegv
cid:48
-trees
v3v4g3g4···vmgmv3v4g3g4···vmgmb1b2···bsv
kasper
szabo
lyngsie
fig
illustrates
recursive
way
construct
bad
trees
constructions
indeed
describe
bad
trees
proof
theorem
suppose
theorem
false
let
smallest
bad
tree
constructed
recursion
easy
check
diameter
must
least
let
number
vertices
proposition
lemmas
assume
trees
type
vertices
trees
type
vertices
constructed
using
recursion
furthermore
since
smallest
counterexample
bad
trees
fewer
vertices
also
constructed
recursion
lemma
implies
vertex
degree
adjacent
vertex
degree
least
lemma
counterexample
obtained
-tree
cid:48
vertex
joined
k2-graphs
bridges
cid:48
vertices
cid:48
constructed
recursion
contradiction
constructionofbadtreesonegv
s+1
-tree
v1g1avertexjoinedtosk2-graphs
···v2v1g1v2orvv
cid:48
g1g
cid:48
1vv
cid:48
g2g
cid:48
2···vv
cid:48
gng
cid:48
nsomebadtrees
···g1g2g3g4gnvv
cid:48
···
neighbour
sum-distinguishing
0,1
-weightings
bipartite
graphs
concluding
remarks
provided
characterisation
bridgeless
bipartite
graphs
without
0,1
-property
trees
without
0,1
-property
actually
since
0,1
-property
equivalent
-property
non-zero
integer
characterisations
extend
-property
characterisations
also
provide
polynomial
time
algorithms
checking
-property
together
theorem
answers
problem
except
bipartite
graphs
bridges
remains
characterise
bipartite
graphs
bridges
without
0,1
-property
would
interesting
investigate
whether
methods
used
section
extended
characterise
bipartite
graphs
without
0,1
-property
acknowledgements
author
would
like
thank
carsten
thomassen
advice
helpful
discussions
well
thomas
perret
careful
reading
manuscript
references
dudek
wajc
complexity
vertex-colouring
edge-weightings
discrete
mathemat-
ics
theoretical
computer
science
13:347–349
2011
karonski
łuczak
thomason
edge
weights
vertex
colours
combinatorial
theory
ser
91:151–157
2004
khatirinejad
naserasr
newman
seamone
stevens
vertex-colouring
edge-
weightings
two
edge
weights
discrete
mathematics
theoretical
computer
science
14:1
1–20
2012
vertex-colouring
edge-weighting
bipartite
graphs
two
edge
weights
discrete
mathe-
matics
theoretical
computer
science
17:1–12
2016
seamone
1-2-3
conjecture
related
problems
survey
arxiv
1211.5122
skowronek-kazi´ow
graphs
multiplicative
vertex-coloring
2-edge-weightings
combi-
natorial
optimization
33:333–338
2017
thomassen
c.-q
zhang
3-ﬂow
conjecture
factors
modulo
1-2-3-
conjecture
combinatorial
theory
ser
121:308–325
2016
