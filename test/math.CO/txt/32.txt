existence
signed
magic
arrays∗
abdollah
khodkar
department
mathematics
university
west
georgia
carrollton
30118
akhodkar
westga.edu
christian
schulz
department
mathematics
rose
hulman
institute
technology
5500
wabash
ave
terre
haute
47803
schulzcc
rose-hulman.edu
nathan
wagner
department
mathematics
bucknell
university
701
moore
avenue
lewisburg
17837
naw006
bucknell.edu
november
2018
abstract
consider
notion
signed
magic
array
rectangular
array
number
ﬁlled
cells
row
number
ﬁlled
cells
column
ﬁlled
certain
set
numbers
symmetric
number
zero
every
row
column
zero
sum
attempt
make
progress
toward
characterization
exists
array
characterization
complete
case
case
also
characterize
three-fourths
cases
keywords
magic
array
heftter
array
signed
magic
array
∗research
supported
nsf
reu
grant
dms1262838
university
west
georgia
introduction
magic
rectangle
deﬁned
array
whose
entries
precisely
integers
wherein
sum
row
sum
column
magic
square
magic
rectangle
proved
theorem
m×n
magic
rectangle
mod
m+n
integer
heﬀter
array
m×n
array
entries
±ms
row
contains
ﬁlled
cells
column
contains
ﬁlled
cells
elements
every
row
column
sum
every
either
appears
array
notion
integer
heﬀter
array
ﬁrst
deﬁned
archdeacon
integer
heﬀter
arrays
represent
type
magic
square
number
set
used
sign
heﬀter
array
tight
empty
cell
necessarily
theorem
let
integers
least
tight
integer
heﬀter
array
mod
square
integer
heﬀter
array
integer
heﬀter
array
proved
theorem
integer
mod
signed
magic
array
sma
array
entries
odd
±ms/2
even
precisely
cells
every
row
cells
every
column
ﬁlled
every
integer
set
appears
exactly
array
sum
row
column
zero
case
call
array
signed
magic
square
signed
magic
squares
also
represent
type
magic
square
number
set
used
use
notation
sms
signed
magic
square
ﬁlled
cells
row
ﬁlled
cells
column
sms
called
k-diagonal
entries
belong
consecutive
diagonals
includes
broken
diagonals
well
case
abbreviate
simply
diagonal
sma
called
tight
denoted
sma
contains
empty
cells
figure
displays
two
examples
signed
magic
arrays
figure
diagonal
sms
sma
paper
investigate
existence
sma
sms
sma
section
prove
sma
exists
precisely
mod
mod
section
show
exists
sms
precisely
finally
section
prove
exists
sma
mod
mod
following
sections
notation
refers
set
integers
two
partitions
set
orthogonal
intersection
member
precisely
one
element
rectangular
array
shiftable
contains
number
positive
negative
entries
every
column
every
row
see
arrays
called
shiftable
may
shifted
use
diﬀerent
absolute
values
increasing
absolute
value
entry
add
positive
entry
negative
entry
number
entries
row
means
add
row
argument
applies
columns
thus
shifted
array
retains
row
column
sums
tight
signed
magic
arrays
ﬁrst
examine
case
tight
array
cells
ﬁlled
completely
characterize
values
tight
m×n
signed
magic
arrays
exist
use
several
lemmata
proof
following
lemma
trivial
lemma
tight
sma
exists
lemma
sma
exists
mod
exactly
mod
mod
sopn
proof
sma
let
value
column
must
value
sum
zero
thus
row
array
contains
every
absolute
value
odd
note
even
replacing
number
negative
sum
one
change
parity
sum
row
array
contains
every
absolute
value
exactly
sum
equal
i=1
positives
replaced
negatives
sum
always
odd
sum
row
even
number
thus
tight
signed
magic
array
exists
mod
mod
argument
holds
previous
case
i=1
let
mod
induction
prove
sma
exists
array
ﬁrst
row
second
row
obviously
sma
use
array
given
figure
figure
shiftable
sma
let
mod
assume
existence
sma
onto
right
side
array
add
four
columns
leaving
space
cells
ﬁlled
note
array
figure
shiftable
may
merely
shift
absolute
values
use
ﬁll
empty
space
shiftable
array
zero
row
column
sums
sum
row
still
zero
sum
four
new
columns
also
zero
thus
construct
sma
result
follows
strong
induction
remaining
cases
split
based
parity
2.1
tight
signed
magic
arrays
even
lemma
shiftable
sma
exists
even
greater
proof
proceed
strong
induction
ﬁrst
base
case
provide
arrays
figures
note
transpose
signed
magic
array
signed
magic
array
need
provide
separate
array
may
transpose
array
−10
−11
−12
figure
shiftable
sma
shiftable
sma
−12
−13
−18
−14
−11
−16
−15
−17
−10
figure
shiftable
sma
let
even
assume
exists
shiftable
sma
may
extend
array
adding
four
columns
create
array
note
empty
space
even
partitions
rectangles
may
ﬁlled
shifted
copy
figure
using
method
analogous
lemma
appropriate
absolute
values
shifted
copies
row
column
sum
zero
change
row
sums
array
sums
new
columns
zero
well
therefore
shiftable
sma
exists
hence
strong
induction
shiftable
sma
exists
even
let
even
assume
exists
shiftable
sma
may
extend
array
adding
four
rows
create
array
note
empty
space
even
partitions
rectangles
may
ﬁlled
shifted
copy
transpose
figure
using
method
analogous
previous
paragraph
shifted
copies
row
column
sum
zero
change
column
sums
array
sums
new
rows
zero
well
therefore
tight
shiftable
sma
exists
strong
induction
shiftable
sma
always
exists
even
2.2
tight
signed
magic
arrays
odd
recall
magic
rectangle
deﬁned
array
whose
entries
precisely
integers
wherein
sum
row
sum
column
lemma
sma
exists
odd
greater
proof
let
odd
greater
hence
theorem
exists
magic
rectangle
say
let
entry
row
column
construct
array
wherein
mn−1
entries
precisely
integers
follows
entries
precisely
integers
mn−1
required
set
integers
tight
signed
magic
array
remains
shown
rows
columns
summing
zero
mn−1
sum
column
sum
column
subtract
entries
column
particular
note
constant
entire
expression
independent
sum
column
i=1
sum
column
sum
sum
entries
columns
together
zero
sum
column
must
zero
i=−w
+pw
i=−w
p−1
likewise
sum
row
sum
row
subtract
entries
row
particular
note
constant
entire
expression
independent
sum
row
sum
entries
sum
row
sum
must
zero
hence
sma
odd
greater
2.3
tight
signed
magic
arrays
odd
even
case
need
make
use
induction
argument
two
base
cases
base
cases
given
following
lemmata
lemma
sma
exists
even
proof
sma
sma
given
figure
let
deﬁne
array
follows
figure
sma
sma
3pj
cid:16
3pj
cid:16
3pj
cid:17
cid:17
3pj
mod
mod
mod
mod
mod
mod
mod
mod


=

third
row
deﬁne
a3,1
−3k
a3,2k
finally
see
figure
straightforward
see
array
sma
−14
−15
−12
−13
−11
−10
figure
sma
using
method
given
lemma
lemma
sma
exists
even
greater
proof
multiple
ﬁrst
apply
lemma
construct
sma
adjoin
two
rows
bottom
array
creating
space
multiple
ﬁll
space
shifted
copies
figure
sum
column
remains
zero
sums
rows
also
zero
see
figure
−10
figure
sma
using
method
given
lemma
mod
multiple
use
algorithm
lemma
ﬁrst
construct
sma
say
array
use
numbers
absolute
value
note
ﬁrst
two
entries
top
row
array
provided
ﬁrst
two
entries
bottom
row
using
fact
column
sums
zero
gives
ﬁrst
two
entries
middle
row
importance
fact
construct
sma
follows
rows
array
placed
ﬁrst
three
rows
array
exception
swapped
ﬁrst
two
entries
second
row
instead
bottom
two
rows
ignoring
left
two
columns
form
array
multiple
array
tiled
shifted
copies
figure
using
absolute
values
note
includes
consecutive
absolute
values
leaves
four
cells
lower
left
may
ﬁlled
follows
figure
gives
example
construction
prove
resulting
array
sma
first
note
fact
used
every
absolute
value
exactly
positive
negative
value
consider
sum
given
row
row
row
sum
zero
immediately
lemma
row
sum
zero
permuting
values
row
change
sum
row
row
one
may
observe
left
two
columns
cancel
values
rest
row
ﬁlled
shifted
copies
figure
guaranteed
sum
zero
lastly
consider
sums
columns
ﬁrst
two
columns
sum
ﬁrst
three
rows
zero
lemma
fact
last
two
values
cancel
corresponding
copy
figure
ﬁrst
column
sum
computed
calculating
sum
diﬀerences
known
solution
second
column
may
similarly
compute
sum
completes
proof
−10
−11
−12
−13
−14
−15
figure
tight
signed
magic
array
using
method
given
lemma
lemma
exists
sma
odd
even
odd
even
lemma
lemma
lemma
lemma
lemma
lemma
lemma
lemma
odd
lemma
lemma
lemma
lemma
even
lemma
lemma
lemma
lemma
figure
various
cases
tight
smas
corresponding
lemmata
proof
apply
lemma
lemma
respectively
assume
inductively
exists
sma
augment
array
adjoining
four
rows
bottom
leaving
empty
space
place
shifted
sma
lemma
empty
space
bottom
array
column
resulting
array
sums
zero
ﬁrst
entries
column
sum
zero
assumption
last
four
entries
sum
zero
due
shiftable
array
row
also
clearly
sums
zero
therefore
exists
sma
hence
statement
true
strong
induction
ready
state
main
theorem
section
theorem
sma
exists
precisely
mod
mod
proof
note
transpose
signed
magic
array
signed
magic
array
existence
sma
ensures
sma
result
follows
immediately
conjunction
several
lemmata
speciﬁed
figure
signed
magic
squares
turn
attention
signed
magic
square
case
tight
array
split
problem
several
cases
handled
independently
recall
use
notation
sms
signed
magic
square
ﬁlled
cells
row
ﬁlled
cells
column
sms
called
k-diagonal
entries
belong
consecutive
diagonals
case
abbreviate
simply
diagonal
ﬁrst
cover
trivial
case
proof
following
result
straightforward
theorem
exists
sms
apart
trivial
sms
containing
single
zero
split
cases
based
parities
3.1
signed
magic
squares
odd
case
proof
quite
complex
begin
two
lemmata
lemma
let
odd
integers
exists
partition
set
nt−1
every
set
collection
contains
exactly
elements
sums
zero
nt−1
proof
let
arbitrary
odd
integer
greater
equal
induct
base
case
demonstrate
existence
partition
giving
explicit
construction
let
cid:26
cid:18
cid:19
cid:18
cid:19
cid:18
cid:19
cid:27
deﬁned
cid:0
3n−1
construction
sum
elements
set
zero
therefore
suﬃcient
show
partition
first
show
|cc|
suppose
contrary
|cc|
cases
consider
cid:1
mod
showing
case
impossible
equality
implies
2xc
cid:1
n−1
equality
implies
remains
show
∩ck
suppose
way
contradiction
obviously
cid:0
3n−1
cid:1
n−1
case
note
decreases
increments
increases
increments
n−1
n−1
cid:1
cid:0
n−1
cid:1
cid:0
n−1
cid:1
cid:0
3n−1
cid:1
note
cid:0
3n−1
cid:1
cid:0
3n−1
cid:1
case
note
cid:0
3n−1
cid:1
cid:1
showing
case
impossible
cid:1
n+1
cid:0
n−1
cid:1
n−1
cid:1
n−1
cid:1
c−1
cid:0
n+1
cid:1
cid:1
cid:1
cid:1
hold
required
case
cid:0
3n−1
cid:0
n−1
cid:1
cid:0
n−1
case
cid:0
3n−1
cid:0
3n−1
cid:1
cid:0
n−1
case
cid:0
n−1
cid:1
c−1
n−1
note
cid:0
3n−1
cid:0
3n−1
point
straightforward
verify
cid:0
3n−1
cid:1
case
therefore
since
cid:0
3n−1
cid:0
3n−1
follows
equality
2xc
cid:0
3n−1
case
cid:0
3n−1
case
cid:0
3n−1
case
cid:0
3n−1
case
cid:0
n−1
case
cid:0
n−1
case
cid:0
3n−1
implies
j−1
cid:0
3n−1
cid:1
cid:0
3n−1
cid:1
cid:0
n−1
cid:1
cid:0
3n−1
cid:1
cid:0
n−1
cid:1
cid:0
3n−1
cid:1
see
case
argument
cid:1
implies
means
3n−1
mod
implies
mod
since
odd
congruence
holds
mod
impossible
refer
case
previous
cid:1
n−1
cid:0
3n−1
cid:1
k−1
cid:0
3n−1
cid:1
contradiction
cid:1
n−1
cid:1
n−1
cid:1
mod
exist
cases
consider
cid:1
n−1
3n−1
see
case
equality
part
proof
argument
well
since
equivalently
mod
impossible
conclude
partition
particular
base
case
holds
partition
set
3n−1
3n−1
three
blocks
consecutive
integers
n+1
cid:1
cid:0
n+1
cid:1
cid:3
cid:1
cid:0
n−1
case
call
three
blocks
cid:2
cid:0
3n−1
deﬁned
obvious
manner
claim
two
partitions
set
orthogonal
notice
ﬁrst
consecutive
integers
appear
sets
respectively
next
consecutive
integers
respectively
consecutive
integer
appear
sets
n−1
index
increased
n−1
result
taken
modulo
residues
used
see
true
note
mod
cid:0
n−1
quick
computation
reveals
increased
one
cid:0
n−1
cid:1
moreover
index
increased
n−1
one
since
n−1
coprime
sets
partition
exactly
one
representative
element
block
integers
finally
last
consecutive
integers
respectively
consecutive
integer
appear
set
n+1
index
increased
result
taken
modulo
see
true
note
n+1
moreover
increases
one
modulo
decreases
modulo
cid:0
3n−1
case
quantity
cid:0
3n−1
increases
break
occurs
going
still
increases
3n−1
contains
hence
block
consecutive
numbers
set
3n−1
representative
every
set
cid:1
increased
cid:0
3n−1
cid:1
n−1
cid:1
n−1
cid:1
n−1
n−1
n+1
n+1
refer
blocks
shiftable
following
reason
sup-
pose
add
integers
elements
sets
respectively
let
chosen
shifted
blocks
disjoint
shift
naturally
induces
new
disjoint
sets
cid:8
cid:0
3n−1
clear
px∈c
cid:1
cid:0
n−1
constant
independent
cid:1
cid:0
3n−1
cid:1
n−1
cid:9
nt−1
sets
t+2
inductive
step
suppose
exists
partition
set
nt−1
sets
sets
consecutive
integers
form
shiftable
blocks
wish
show
exists
partition
set
t+2
sets
consecutive
integers
form
shiftable
blocks
t+2
begin
shift
blocks
dt−1
subtracting
elements
shift
block
adding
elements
shifts
induce
new
disjoint
sets
elements
construction
sum
wish
complete
partition
elements
adding
two
elements
set
t−4
t−4
/2+1
nt−1
respectively
respectively
note
next
consecutive
integers
patterns
mirror
images
ﬁrst
case
index
increases
n+1
consecutive
integer
second
case
increases
n−1
course
taken
modulo
using
residues
routine
verify
method
ensures
quantity
added
sum
constructed
partition
construction
elements
place
ﬁrst
consecutive
integers
n−1
n+1
n+1
t+2
sets
set
t+2
cardinality
sum
note
method
also
guarantees
end
partition
property
shiftable
blocks
particular
easy
see
general
parti-
tioning
method
involves
placing
ﬁrst
consecutive
integers
order
placing
following
reverse
placing
next
order
n−1
order
pattern
skipping
n−1
continues
alternate
last
consecutive
integers
placed
n+1
consecutive
integer
index
increased
result
taken
modulo
skipping
n+1
n+1
n−1
n+1
lemma
let
odd
integers
let
deﬁned
proof
lemma
exists
another
partition
set
nt−1
nt−1
orthogonal
entries
sums
zero
proof
let
cci
contains
jth
entry
ascending
order
within
thus
far
partitioned
exist
even
n+1
kij
mod
also
n−1
otherwise
lastly
odd
n+1
even
n−1
let
solving
equation
kiji
mod
mod
may
determine
values
coeﬃcient
gives
k−1
constant
congruence
via
modular
algebra
k−1
k−1
−k−1
even
otherwise
n+1
odd
even
=
=
mod
break
positive
c+1
convenience
let
c+n
introduce
deﬁnitions
given
break
value
c+1
note
determined
c+1
negative
signed
magnitude
otherwise
magnitude
break
|ji
c+1
c+1
example
let
values
congruent
modulo
values
−2c
two
breaks
one
goes
one
goes
positive
breaks
next
determine
exactly
breaks
occur
given
signs
magnitudes
mod
follows
sequence
one
negative
break
magnitude
c+1
even
−2c
mod
sequence
two
positive
breaks
magnitude
one
occurs
c+1
occurs
n−1
c+1
n+1
mod
sequence
one
negative
break
magnitude
n−1
c+1
odd
mod
sequence
two
negative
breaks
magnitude
one
occurs
c+1
occurs
n−1
c+1
deﬁne
deﬁne
follows
contains
mod
clarity
single
value
n−1
deﬁne
function
n−1
use
next
deﬁne
analogous
symbol
value
rth
entry
ascending
order
within
note
value
must
also
r+s
convenience
follows
contains
let
r+n
signed
magnitude
break
occurs
otherwise
words
may
deﬁne
breaks
manner
breaks
let
r+1
one
exists
divide
cases
based
otherwise
note
alter
solution
using
modular
congruence
modulo
r+1
even
n−1
solving
obtain
simplifying
using
congruence
modulo
n−1
n−1
equivalent
odd
n−1
equivalent
let
chosen
arbitrarily
let
βz+1
nonzero
opposites
also
matching
covers
i=1
note
also
i=1
let
oﬀset
jth
element
ascending
order
consider
i=1
diﬀerence
two
consecutive
partitions
nonzero
values
therefore
follows
deﬁnition
r+1
−pt
=pt
rr+1
i=1
i=1
i=1
r+1
i=1
i=1
=pt
+pt
sum
rr+1
induction
sum
i=1
i=1
r+1
tn−1
i=−
tn−1
sum
individually
also
zero
sum
sums
theorem
let
odd
integers
exists
sms
proof
let
deﬁned
lemma
lemma
let
single
element
nonempty
intersection
left
blank
every
row
every
column
sums
zero
exactly
entries
rows
columns
thus
desired
array
see
figure
−17
−16
−15
−14
−13
−12
−11
−10
−17
−16
−15
−14
−13
−10
−12
−11
figure
top
array
whose
rows
whose
columns
highlighting
elements
bottom
sms
given
theorem
3.2
signed
magic
squares
odd
even
remaining
square
cases
need
following
two
lemmata
lemma
10.
positive
integers
exists
shiftable
diagonal
sms
proof
let
positive
integer
deﬁne
array
−2n


cells
left
empty
otherwise
figure
provides
example
array
straightforward
verify
contains
entries
set
−2n
entries
appears
exactly
one
time
array
moreover
construction
array
property
four
adjacent
diagonals
ﬁlled
remains
check
rows
columns
sum
rows
n−3
sum
entries
row
i−i+
2n−i
2n−i
desired
sum
sum
finally
sum
entries
last
row
must
sum
entries
array
columns
sum
sum
sum
sum
required
finally
sum
entries
last
column
must
sum
entries
array
completes
proof
−15
−10
−16
−14
−13
−12
−11
figure
shiftable
diagonal
sms
given
lemma
10.
lemma
11.
assume
exists
k-diagonal
sms
either
even
exists
-diagonal
sms
proof
let
k-diagonal
sms
either
even
note
entries
partitioned
diagonals
least
four
consecutive
diagonals
empty
may
choose
four
consecutive
diagonals
adjacent
diagonals
entries
contained
let
shiftable
diagonal
sms
given
lemma
10.
let
copy
entries
shifted
absolute
values
rather
columns
permuted
place
four
diagonals
cells
four
empty
diagonals
t+4
share
ﬁlled
cells
together
entries
occupy
consecutive
diagonals
array
zero
row
column
sums
two
arrays
together
use
number
t+4
exactly
combining
two
arrays
one
achieve
desired
signed
magic
square
t+4
move
actually
considering
case
even
odd
prove
induction
one
whose
base
cases
complex
enough
warrant
another
lemma
lemma
12.
let
odd
exists
shiftable
diagonal
sms
proof
lemma
exists
sms
say
using
entries
3n−1
let
every
column
uses
number
exactly
sum
3n+1
3n−1
deﬁne
array
follows
let
using
mod
bi′
convention
bi′
n+1
bi′,1
cells
left
empty
bi′
′+1
−a′
determine
possible
values
take
bi′
ﬁlled
must
mod
note
equations
imply
2i+j
−2−j
2i−s−2
mod
fact
equivalent
conditions
range
therefore
must
one
values
thus
consists
six
consecutive
diagonals
observe
row
deﬁned
nonempty
cells
partition
naturally
pairs
opposite
entries
row
sums
zero
column
six
entries
six
entries
−a1
′−1
−a2
′−1
−a3
′−1
using
convention
ai,0
one
may
verify
using
congruences
given
six
numbers
indeed
placed
column
sum
column
sum
six
entries
stated
earlier
′−1
′−1
′−1
column
sums
zero
thus
array
desired
properties
see
figure
−20
−19
−13
−11
−18
−12
−14
−15
−21
−17
−10
−16
figure
top
sms
shifted
use
values
bottom
corre-
sponding
sms
given
lemma
12.
give
full
induction
argument
theorem
given
odd
even
exists
shiftable
diagonal
sms
proof
prove
induction
two
base
cases
cases
given
lemma
lemma
respectively
assume
arrays
exist
even
greater
particular
may
apply
lemma
construct
diagonal
sms
hence
statement
true
induction
3.3
signed
magic
squares
even
begin
case
multiple
lemma
13.
let
even
positive
integers
either
divisible
exists
sms
proof
assumption
multiple
four
theorem
implies
exists
tight
integer
heﬀter
array
say
let
denote
row
create
two
orthogonal
partitions
set
note
due
deﬁnition
heﬀter
array
precisely
set
entries
opposites
therefore
let
r2i−1
let
r2i
contain
opposites
apparent
odd
partition
set
entries
even
partition
set
opposites
therefore
partition
addition
sum
entries
given
either
sum
row
zero
deﬁnition
opposite
also
zero
lastly
note
|rr|
cardinality
row
deﬁne
−ai
mod
mod
−ai
let
let
note
exactly
one
contains
entry
given
exactly
one
solving
modular
congruence
contains
opposites
elements
well
follows
partitions
also
note
contains
two
elements
half
columns
|cc|
deﬁnition
contains
contains
sum
zero
lastly
need
prove
orthogonal
partitions
let
arbitrary
r2i−1
assume
two
elements
namely
common
diﬀerent
used
left
right
halves
assume
side
i.e
latter
case
either
case
canceling
mod
former
case
mod
impossible
mod
therefore
r2i−1
one
element
common
contains
opposites
elements
may
similarly
say
r2i
one
element
common
shared
two
elements
would
share
−x′
orthogonal
partitions
deﬁne
array
follows
cell
contains
single
element
nonempty
intersection
left
blank
otherwise
every
row
every
column
sums
zero
exactly
entries
rows
columns
thus
desired
array
see
figure
−12
−12
−11
−10
figure
top
3×4
tight
integer
heﬀter
array
bottom
corresponding
sms
rest
case
proceeds
much
case
even
odd
one
important
diﬀerence
instead
diagonal
sms
even
construct
7-diagonal
sms
show
gives
suﬃcient
results
lemma
14.
let
mod
10.
exists
shiftable
7-diagonal
sms
3m−1
proof
lemma
gave
construction
partitions
interval
3m−1
sets
three
equal
sum
odd
let
carrying
partition
add
3m−1
every
number
partition
giving
partition
sets
three
equal
sum
9n−6
make
three
observations
partition
numbers
n−1
placed
distinct
sets
numbers
2n−2
number
set
partition
number
number
set
partition
number
deﬁne
function
follows
3n−2
3n−2
note
domain
range
three
remaining
numbers
add
9n+2
apply
every
element
previous
partition
partition
elements
sets
three
follows
observation
n−2
call
ﬁrst
class
sum
9n−6
call
second
class
sum
9n−6
9n+2
9n+4
label
every
set
partition
plus
labels
observation
means
second
class
deﬁned
earlier
9n+4
observation
pair
pairs
may
chosen
arbitrarily
following
two
constraints
follows
contains
also
note
contains
two
equal
sums
possible
becausep
remaining
sets
exactly
n−2
ﬁrst
class
n−2
second
class
deﬁned
mod
know
n−2
even
deﬁne
array
follows
let
contains
two
say
pi1
pi2
arrange
elements
order
may
refer
pi,1
pi,2
pi,3
place
easily
satisﬁed
constraints
otherwise
arbitrary
labeling
p1,2
p2,2
pn,1
pn,2
convenience
let
indices
wrap
around
e.g
an+1
n+3
a1,3
ﬁll
following
cells
a2j+2k−3,2j−1
pi1
a2j+2k−3,2j
−pi1
a2j+2k−2,2j−1
−pi2
ka2j+2k−2,2j
pi2
leave
cells
empty
note
array
row
contains
three
numbers
opposites
thus
sums
zero
columns
column
contains
pi1
opposite
pi2
column
contains
pi2
opposite
pi1
follows
every
column
sums
zero
except
ﬁrst
column
sums
top
9n+4
second
column
sums
make
observations
array
related
numbers
cells
a3,1
p2,2
a4,2
p1,2
a3,3
pn,1
a3,4
a5,3
pn,2
a5,4
a4,3
a4,4
9n+2
let
deﬁned
several
exceptions
3,1
a4,2
4,2
a3,1
3,3
a5,3
4,3
a3,3
5,3
a4,3
4,4
a5,4
5,4
a4,4
see
permutation
multi-
set
entries
used
elements
−3n
exactly
every
element
column
exception
3,1
4,2
follows
sum
column
sum
column
rows
changed
rows
a3,3
a5,3
a3,1
a4,2
a4,3
a3,3
a4,4
a5,4
a4,2
a3,1
a5,3
a4,3
a5,4
a4,4
a4,3
a4,4
a4,3
a4,4
thus
every
row
every
column
contains
six
entries
sum
zero
every
number
−3n
used
exactly
note
lastly
ﬁlled
cell
equivalently
diﬀerence
row
column
indices
congruent
element
modulo
set
cardinality
uses
cells
seven
consecutive
diagonals
concludes
proof
array
seek
example
construction
given
figure
p10
pi,1
pi,2
pi,3
−19
−15
−26
−30
−13
−10
−11
−25
−24
−18
−16
−27
−21
−12
−14
−28
−29
−22
−23
−20
−17
figure
top
partition
10.
bottom
corresponding
7-diagonal
sms
elements
diﬀer
bolded
apply
induction
argument
theorem
theorem
given
even
exists
sms
mod
square
-diagonal
proof
multiple
may
apply
lemma
13.
lemma
gives
desired
result
square
tight
otherwise
proceed
induction
base
case
let
exists
7-diagonal
sms
lemma
14.
assume
exists
-diagonal
sms
exists
-diagonal
sms
lemma
11.
therefore
induction
cases
exist
squares
even
3.4
even
odd
complex
case
requiring
several
subcases
may
proceed
induction
argument
previous
cases
base
case
becomes
much
complex
give
ﬁve
cases
lemma
15.
let
even
integer
exists
sms
proof
construct
two
orthogonal
partitions
set
first
construct
sma
say
using
construction
given
proof
lemma
ﬁrst
partition
set
consisting
entries
cth
column
suﬃcient
demonstrate
existence
partition
orthogonal
consists
sets
cardinality
let
−cr
sum
zero
deﬁne
partition
follows
−cr
collection
sets
clearly
partitions
sets
cardinality
sum
remains
show
orthogonal
note
equivalent
proving
opposites
entries
given
column
lie
diﬀerent
columns
fact
zero-sum
property
rows
columns
suﬃcient
show
two
entries
column
negated
lie
diﬀerent
columns
consider
entries
−ai
must
consider
cases
depending
−3n
note
lies
second
value
entries
column
lies
nth
column
cid:16
3pj
cid:17
3pj
next
suppose
mod
entries
column
3pj−1−2
mod
therefore
3pj
lies
column
hand
pj+1
mod
thus
lies
column
suppose
mod
entries
column
note
3pj
cid:17
cid:16
3pj
cid:16
3pj
mod
therefore
cid:16
3pj
cid:17
note
cid:16
3pj
cid:17
cid:17
cid:16
3pj+1−1
cid:17
lies
column
hand
pj−1
mod
thus
lies
column
cid:16
3pj
cid:17
−pj
3pj
next
suppose
mod
entries
column
mod
−pj
note
3pj
3pj−1−1
therefore
3pj
mod
thus
lies
column
lies
column
hand
pj+1
finally
suppose
mod
entries
column
cid:17
cid:16
3pj
cid:16
3pj
mod
therefore
cid:16
3pj
cid:17
note
cid:16
3pj
cid:17
cid:17
cid:16
3pj+1−2
cid:17
lies
column
hand
pj−1
mod
thus
lies
column
unnecessary
check
last
column
last
column
property
two
elements
negated
column
another
column
would
property
let
array
cell
contains
element
common
element
exists
left
blank
otherwise
contains
entries
row
column
sum
zero
required
see
figure
figure
sms
using
method
lemma
15.
lemma
16.
let
exists
diagonal
sms
proof
deﬁne
three
ﬁnite
sequences
together
contain
every
integer
exactly
=

=
i−1
i−1
−12k
−6k
first
must
prove
sequences
together
contain
every
number
speciﬁed
range
let
integer
|x|
integer
−3y
integer
either
former
case
b4k
latter
case
−2k
a4k
−2k
given
previous
cases
note
disjoint
mod
mod
mod
−6k
sets
cardinality
12k
follows
set
contain
every
integer
−6k
exactly
prove
following
additional
property
sequences
letting
an+1
bn+1
cn+1
bi+1
ci+1
ai+1
bi+1
note
need
prove
ﬁrst
expression
zero
ai+1
ci+1
ci+1
let
bi+1
ci+1
let
bi+1
ci+1
let
bi+1
ci+1
let
12k
bi+1
ci+1
−12k
let
bi+1
ci+1
−6k
let
bi+1
ci+1
deﬁne
array
follows
bi+1
ai+1
mod
mod
=
remaining
cells
empty
see
figure
ith
row
contains
bi+1
ai+1
add
jth
column
contains
aj−1
letting
also
add
array
thus
contains
three
consecutive
diagonals
ﬁlled
integers
sum
three
integers
row
column
zero
lemma
17.
let
exists
diagonal
sms
−11
−10
−12
figure
diagonal
sms
using
method
lemma
16.
proof
deﬁne
ﬁve
ﬁnite
sequences
together
contain
every
integer
exactly
−10j
−10j
10k
10j
10k
10j
10k
−5k
15k
−5k
−5k
−5k




−20k
−10k
=
first
must
prove
sequences
together
contain
every
number
speciﬁed
range
let
integer
|x|
10k
integer
−5y
integer
either
former
case
c4k
latter
case
odd
−2k
−2y
a4k−3
odd
a4k
even
negative
−2y
a4k−2
even
positive
per
−2k
−2k
b4k−1
b4k−3
per
note
disjoint
mod
mod
mod
mod
mod
−10k
10k
sets
cardinality
20k
follows
set
contain
every
integer
−10k
10k
exactly
convenience
subscripts
sequences
treated
elements
example
notation
an+7
refer
consider
expression
ai−2
bi−1
compute
value
expression
ai−2
bi−1
ai−2+bi−1+ci+di+ei
10k−8−5k−4+10−5k+11+3−13+1
ai−2
bi−1
−10j
10j
20j
10k
10j
ai−2
bi−1
−10j
20j
10k
10j
ai−2
bi−1
10k
20j
10j
10j
ai−2
bi−1
10k
10j
20j
10j
10j
ai−2
bi−1
10k
20k
20j
15k
10j
10j
ai−2
bi−1
10k
15k
10j
20k
20j
10j
10j
ai−2
bi−1
−10j
10j
20k
20j
15k
10k
10j
ai−2
bi−1
−10j
15k
20k
20j
10k
10j
ai−2
bi−1
10k
20k
20k
ai−2
bi−1
10k
20k
20k
ai−2
bi−1
20k
20k
10k
ai−2
bi−1
10k
10k
consider
di−1
ei−2
deﬁnitions
see
bi−1
ai−2
bi−1
ai−2
deﬁne
square
array
ﬁll
ﬁve
consecutive
diagonals
indices
considered
elements
let
i+2
i+1
ai+1
ai+2
cells
empty
see
figure
clearly
ﬁlls
precisely
ﬁve
adjacent
diagonals
elements
−10k
10k
row
ﬁve
cells
ﬁlled
i+2
i+1
i−1
di−1
i−2
ei−2
sum
ﬁve
cells
column
ﬁve
cells
ﬁlled
ai+2
ai+1
ai−1
bi−1
ai−2
ai−2
sum
ﬁve
cells
therefore
diagonal
sms
mod
lemma
18.
let
exists
diagonal
sms
proof
let
deﬁne
follows
=
mod
mod
=

cid:0
i−1
cid:1
cid:0
i−2
cid:1
cid:0
i−2
cid:1
even
odd
even
5n−26
−17
−12
−16
−13
−19
−14
−11
−15
−10
−18
−20
figure
diagonal
sms
using
method
lemma
mod
ai−1
j+1
mod
ai−2
j+2
convenience
deﬁne
ai+n
j+n
let
cells
blank
diagonal
congruence
class
mod
function
deﬁned
positive
integer
values
hence
function
whole
range
|r|
consequently
suﬃces
show
every
exists
according
function
deﬁned
let
arbitrary
−5ℓ
finally
let
let
mod
either
let
mod
consider
cases
let
x+9+5k
let
let
let
x−5k−1
5n−26
−9k
let
x+5n−5k
x+9+5k
cases
let
mod
5n−26
mod
consider
cases
let
x−2
let
cid:0
x+3
cid:1
routine
verify
choices
yield
integer
values
corresponding
value
according
function
deﬁned
cover
remaining
congruence
classes
could
assume
note
terms
satisfying
mod
translates
elements
array
particular
added
entries
hence
fact
function
covers
values
mod
follows
fact
covers
values
mod
analogous
argument
shows
array
contains
values
mod
conclude
array
contains
every
element
must
show
rows
columns
array
sum
zero
first
consider
exactly
rows
several
cases
consider
cid:1
5n−26
cid:0
1−1
cid:1
5n−26
cid:0
n−2
cid:1
cid:0
2−2
cid:0
2−2
cid:1
odd
cid:0
i−1
cid:1
cid:0
i−3
cid:1
even
cid:0
i−2
cid:1
cid:0
i−2
cid:1
odd
cid:1
cid:0
i−3
cid:0
i−1
cid:1
even
cid:1
cid:0
i−2
cid:0
i−2
cid:1
odd
cid:1
i−3
cid:0
i−1
even
cid:0
i−2
entries
row
must
sum
zero
rows
sum
cid:1
+3+5
i−2
+2+1
2+1−10−9+10+1+3+2
cid:1
−5n−9−5k
cid:0
i−2
zero
sum
entries
array
consider
similar
cases
columns
n−2
5n−26
cid:0
1−1
5n−26
cid:1
cid:0
1−1
cid:1
cid:0
2−2
cid:1
odd
cid:0
j−3
cid:1
cid:0
j−1
cid:1
even
cid:0
j−2
cid:1
cid:0
j−2
cid:1
odd
cid:0
j−3
cid:1
cid:0
j−1
cid:1
even
cid:1
cid:0
j−2
cid:0
j−2
cid:1
odd
thenpi
cid:1
cid:0
j−1
cid:0
j−3
cid:1
even
thenpi
cid:0
j−2
cid:1
cid:0
j−2
cid:1
entries
column
must
sum
zero
columns
sum
zero
sum
entries
array
see
figure
conclude
mod
exists
diagonal
sms
lemma
19.
let
exists
diagonal
sms
proof
deﬁne
seven
ﬁnite
sequences
together
contain
every
integer
required
set
exactly
−19
−16
−14
−13
−11
−12
−17
−20
−18
−23
−22
−15
−10
−24
−21
−25
figure
diagonal
sms
using
method
lemma
−7i
28k
−28k
−7k
21k
−28k
−14k
=

=
first
must
prove
sequences
together
contain
every
number
speciﬁed
range
let
integer
−7y
integer
either
former
case
d4k+2
latter
case
integer
−2k
integer
c4k+2
integer
integer
integer
integer
integer
integer
exists
integer
exists
integer
exists
note
disjoint
mod
mod
mod
mod
mod
mod
mod
sets
cardinality
28k
follows
set
contain
every
integer
exactly
convenience
subscripts
sequences
treated
elements
example
notation
an+7
refer
consider
expression
ai−3
bi−2
ci−1
compute
value
expression
ai−3
bi−2
ci−1
28k
28k
ai−3
bi−2
ci−1
28k
28k
ai−3
bi−2
ci−1
28k
ai−3
bi−2
ci−1
−12−7k
−6+7
+7k
−7j
+1+5+7
−12+3−7
+3+1
ai−3
bi−2
ci−1
2j−1
−12+7k−7j+1+7
2j+1
−7k−7j−6+5+7
2j+1
−12+3−7
2j+1
+3+1
ai−3
bi−2
ci−1
28k
28k
ai−3
bi−2
ci−1
28k
21k
28k
28k
ai−3
bi−2
ci−1
21k
28k
28k
28k
ai−3
bi−2
ci−1
28k
28k
28k
21k
28k
28k
ai−3
bi−2
ci−1
28k
28k
21k
28k
28k
28k
ai−3
bi−2
ci−1
28k
28k
21k
14k
28k
28k
consider
ei−1
fi−2
gi−3
deﬁnitions
ci−1
bi−2
ai−3
see
ci−1
bi−2
ai−3
deﬁne
square
array
ﬁll
seven
consecutive
diagonals
indices
considered
elements
let
i+3
i+2
i+1
ai+1
ai+2
ai+3
cells
empty
clearly
ﬁlls
precisely
seven
adjacent
diagonals
elements
see
figure
row
seven
cells
ﬁlled
i+3
i+2
i+1
i−1
ei−1
i−2
fi−2
i−3
gi−3
sum
seven
cells
column
seven
cells
ﬁlled
ai+3
ai+2
ai+1
ai−1
ci−1
ai−2
bi−2
ai−3
ai−3
sum
seven
cells
therefore
array
diagonal
sms
solve
last
quarter
square
case
theorem
given
even
odd
exists
sms
multiple
square
also
diagonal
−16
−20
−15
−10
−22
−17
−11
−18
−34
−27
−29
−28
−21
−24
−31
−25
−19
−12
−32
−33
−30
−14
−13
−26
−35
−23
figure
diagonal
sms
using
method
lemma
odd
even
yes
trivially
theorem
theorem
theorem
theorem
theorem
theorem
odd
yes
theorem
yes
theorem
even
yes
theorem
yes
theorem
figure
various
cases
signed
magic
squares
corresponding
lemmata
proof
mod
apply
lemma
15.
otherwise
proceed
induction
base
case
let
multiple
mod
mod
cases
apply
lemma
respectively
inductive
case
assume
exists
diagonal
sms
lemma
gives
diagonal
sms
conclude
proof
via
induction
lastly
tie
ﬁve
theorems
square
arrays
together
following
statement
theorem
10.
exists
sms
precisely
proof
determine
whether
sms
exists
given
one
may
consult
table
answer
well
theorem
apply
ﬁnd
signed
magic
rectangles
natural
question
ask
whether
results
proven
signed
magic
squares
extend
signed
magic
rectangles
i.e
arrays
number
elements
row
diﬀers
number
elements
column
particular
case
seems
natural
consider
array
contains
entries
every
column
entries
every
row
theorem
11.
let
suppose
mod
exists
sma
proof
note
theorem
exists
integer
heﬀter
array
entries
ﬁlled
row
column
let
integer
heﬀter
array
−ai
cell
ﬁlled
otherwise
cell
left
blank
let
array
deﬁned
j−m
cell
empty
cells
also
empty
see
figure
easy
see
sma
−11
−12
−10
figure
sma
using
method
theorem
11.
lemma
20.
exists
shiftable
sms
even
proof
suppose
odd
exists
sms
row
column
array
contains
ﬁlled
cells
since
odd
equal
number
positive
negative
entries
row
column
array
shiftable
clearly
exist
sms
suppose
even
first
consider
case
proceed
induction
base
case
note
arrays
used
construction
lemma
shiftable
suppose
exists
shiftable
sms
add
four
columns
array
attaching
series
shiftable
arrays
original
array
resulting
array
shiftable
entries
negative
positive
added
row
integer
paired
opposite
added
columns
next
add
four
rows
array
attaching
series
shiftable
arrays
array
easy
see
resulting
array
shiftable
hence
induction
exists
shiftable
sms
consider
case
let
mod
proceed
induction
lemma
exists
shiftable
diagonal
sms
let
suppose
exists
shiftable
sms
ﬁll
four
additional
adjacent
diagonals
using
original
4-diagonal
array
shifted
appropriately
permuting
columns
necessary
gives
sms
array
shiftable
added
positive
negative
entries
row
column
induction
claim
holds
mod
proof
essentially
identical
structure
cases
mod
even
mod
odd
note
base
cases
given
lemma
lemma
respectively
completes
proof
−20
−12
−22
−28
−41
−25
−33
−19
−13
−18
−11
−14
−15
−21
−17
−40
−30
−29
−32
−35
−10
−34
−24
−26
−23
−36
−16
−39
−42
−37
−27
−38
−31
figure
sma
obtained
using
method
theorem
11.
mod
mod
mod
mod
mod
yes
theorem
yes
theorem
yes
theorem
yes
theorem
mod
yes
theorem
yes
theorem
mod
yes
theorem
yes
theorem
yes
theorem
yes
theorem
mod
yes
theorem
yes
theorem
figure
existence
signed
magic
rectangles
theorem
12.
let
even
exists
sma
array
deﬁned
proof
lemma
exists
shiftable
sms
say
let
cell
left
blank
corresponding
cell
left
blank
note
shiftable
also
zero-sum
property
rows
columns
j−m
cell
empty
cells
left
empty
see
figure
easy
see
desired
array
let
array
two
theorems
actually
cover
many
cases
signed
magic
rectan-
gles
figure
summarizes
results
signed
magic
rectangles
dimensions
references
archdeacon
heﬀter
arrays
biembedding
graphs
surfaces
electron
combin
2015
p1.74
d.s
archdeacon
boothby
j.h
dinitz
tight
heter
arrays
exist
possible
values
combin
des
2017
535
archdeacon
dinitz
donovan
yazici
square
integer
heﬀter
arrays
empty
cells
des
codes
cryptogr.
2015
409–426
dinitz
wanless
existence
square
integer
heﬀter
arrays
ars
math
contemp.
appear
sun
existence
magic
rectangles
nei
mongol
daxue
xuebao
ziran
kexue
1990
10–16
