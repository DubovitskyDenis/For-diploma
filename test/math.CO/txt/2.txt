computing
optimal
strategy
cop
game
cop
v.s
gambler
shen-fu
tsai
parity
gmail.com
october
2018
abstract
present
two
eﬃcient
algorithms
compute
optimal
strategy
cop
game
cop
v.s
gambler
gambler
strategy
optimal
known
cop
ﬁrst
algorithm
analogous
bellmanford
algorithm
single
source
shortest
path
problem
runs
||e
time
second
analogous
dijkstra
algorithm
runs
log
time
compared
suitable
sparse
dense
graphs
re-
spectively
introduction
probabilistic
version
game
graph
pursuit
cop
plays
gambler
graph
game
starts
cop
picks
occupies
vertex
round
game
cop
selects
moves
adjacent
vertex
stays
vertex
gambler
chooses
occupy
vertex
randomly
based
time-independent
distribution
gamble
known
cop
gambler
restricted
adjacent
vertices
whenever
occupy
vertex
time
cop
wins
known
connected
graph
cop
win
less
equal
expected
rounds
cop
win
exactly
expected
rounds
optimal
gamble
gambler
uniform
distribution
however
note
cop
strategy
proposed
guarantees
ex-
pected
chase
time
may
optimal
non-uniform
gamble
employed
example
chain
0.3
0.7
cop
starting
strategy
cop
stay
expect
win
10/3
time
however
moves
stay
expected
time
0.7/0.7
optimal
cop
strategy
describe
two
algorithms
compute
optimal
strategy
cop
starting
every
vertex
given
gamble
probability
gambler
selects
occupy
vertex
algorithms
work
directed
undirected
graphs
always
represent
optimal
strategy
cop
arriving
vertex
next
vertex
move
next
round
set
adjacent
vertices
plus
2.1
||e
algorithm
analogous
bellman-ford
algorithm
single
source
shortest
path
prob-
lem
iterations
update
strategy
chase
time
vertex
based
edge
runs
faster
sparse
graphs
next
algorithm
section
2.2.
1/pv
end
update
alse
ti−1
minu∈n
ti−1
minu∈n
ti−1
arg
minu∈n
tk−1
update
rue
end
end
update
return
end
end
2.1.1
analysis
section
show
correctness
eﬃciency
algorithm
first
deﬁne
optimal
expected
chase
time
cop
enters
vertex
lemma
min
w∈n
moreover
moving
entering
optimal
following
lemma
says
algorithm
never
obtain
smaller
lemma
proof
prove
lemma
showing
every
achievable
true
1/pv
expected
chase
time
cop
stays
vertex
forever
assume
tk−1
achievable
min
u∈n
tk−1
induction
minu∈n
tk−1
right
hand
side
upper
bound
chase
time
cop
moves
vertex
arg
minu∈n
tk−1
capture
gambler
current
round
therefore
achievable
deﬁne
chase
path
path
pvi
vi+1
vi+1
pvk
clearly
chase
path
starting
ending
optimal
path
cop
start
chasing
gambler
ending
implies
optimal
cop
stay
forever
lemma
chase
path
chase
path
starting
shortest
chase
path
shorter
chase
path
starts
say
vertex
shortest
chase
length
shortest
chase
path
starting
length
lemma
shortest
chase
path
lemma
shortest
chase
length
neighbor
shortest
chase
length
follows
shortest
chase
path
proof
let
path
vk−1
shortest
chase
path
lemma
vk−1
shortest
chase
path
length
deﬁnition
therefore
lemma
shortest
chase
length
computed
remains
unchanged
thereafter
satisfying
proof
statement
holds
vertex
shortest
chase
length
max
u∈n
otherwise
moving
neighbor
higher
probability
better
staying
good
vertex
shortest
chase
length
lemma
neighbor
shortest
chase
length
induction
assumption
tk−1
min
w∈n
tk−1
tk−1
last
equality
stems
fact
follows
shortest
chase
path
hand
lemma
obvious
description
algorithm
satisﬁes
moreover
updated
round
tj+1
tk+1
change
beyond
round
lemma
shortest
chase
path
simple
proof
suppose
contrary
shortest
chase
path
passes
vertex
twice
deleting
ﬁrst
occurrence
excluding
second
occurrence
gives
another
chase
path
shorter
theorem
algorithm
section
2.1
correctly
computes
||e
time
proof
lemma
shortest
chase
paths
lengths
less
equal
lemma
round
computed
satisﬁes
tn+1
tn+2
i.e
algorithm
terminates
later
round
round
takes
time
overall
time
com-
plexity
||e
2.2
log
algorithm
present
another
algorithm
computing
optimal
cop
strategy
time
com-
plexity
log
suitable
dense
graphs
analogous
dijkstra
algorithm
single
source
shortest
path
iterations
update
strategy
chase
time
vertices
links
directly
speciﬁc
vertex
1/pv
end
|s|
arg
minv∈s
end
end
end
2.2.1
analysis
section
show
correctness
eﬃciency
algorithm
lemma
follows
chase
path
1/pu
chase
path
always
goes
long
short
expected
chase
time
lemma
follows
chase
path
proof
suppose
otherwise
since
follows
1/pv
contradiction
lemma
10.
every
proof
clearly
holds
|s|
suppose
statement
holds
|s|
assume
|s|
beginning
iteration
loop
let
arg
minu∈s
suﬃces
show
assume
exists
chase
path
disjoint
lemma
since
end
chase
path
1/pum
contradiction
1/pum
vertex
closest
let
follows
lemma
already
updated
lemma
1/pw
done
computed
always
achievable
i.e
theorem
algorithm
correctly
computes
optimal
strategy
log
time
proof
correctness
follows
lemma
immediately
achieve
|e|
log
time
complexity
could
kept
fibonacci
heap
amortized
element
update
time
log
element
removal
time
references
natasha
komarov
peter
winkler
cop
vs.
gambler
discrete
math
339
2016
1677-1681
https
//en.wikipedia.org/wiki/fibonacci
heap
https
//en.wikipedia.org/wiki/bellman
https
//en.wikipedia.org/wiki/dijkstra
