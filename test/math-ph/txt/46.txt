new
transfer-matrix
algorithm
exact
enumerations
self-avoiding
polygons
square
lattice
nathan
clisby
iwan
jensen
arc
centre
excellence
mathematics
statistics
complex
systems
department
mathematics
statistics
university
melbourne
vic
3010
australia
abstract
present
new
eﬃcient
implementation
transfer-matrix
methods
exact
enumerations
lattice
objects
new
method
illustrated
application
enumeration
self-avoiding
polygons
square
lattice
detailed
comparison
previous
best
algorithm
shows
signiﬁcant
improvement
running
time
algorithm
new
algorithm
used
extend
enumeration
polygons
length
130
previous
record
110
introduction
n-step
self-avoiding
polygon
sap
regular
lattice
sequence
distinct
vertices
vertex
nearest
neighbour
predecessor
nearest-neighbours
sap
considered
distinct
translations
starting
point
orientation
sap
problem
regular
lattices
one
important
classic
combinatorial
problems
statistical
mechanics
sap
often
considered
context
lattice
models
ring-polymers
vesicles
fundamental
problem
calculation
number
sap
steps
note
square
lattice
polygons
even
perimeter
odd
interesting
combinatorial
problems
sap
exponential
growth
bµnnα−3
so-called
connective
constant
1/2
known
universal
critical
exponent
critical
amplitude
analysing
data
often
convenient
use
associated
generating
function
pnxn
2−α
series
singularity
critical
point
1/µ
critical
exponent
enumeration
sap
long
glorious
history
suﬃce
say
early
calculations
based
various
direct
counting
algorithms
exponential
complexity
computing
time
growing
asymptotically
2.638
new
transfer-matrix
algorithm
exact
enumerations
figure
example
sap
rectangular
piece
square
lattice
dashed
line
shows
position
boundary
particular
stage
calculation
connective
constant
sap
square
lattice
enting
ﬁrst
produce
major
breakthrough
applying
transfer
matrix
methods
enumeration
sap
ﬁnite
lattices
so-called
ﬁnite
lattice
method
flm
led
signiﬁcant
reduction
complexity
3n/4
4√3
1.316
recently
reﬁned
algorithm
using
method
pruning
reduced
complexity
1.2n
algorithms
based
keeping
track
way
partially
constructed
sap
connected
left
line
bisecting
given
ﬁnite
lattice
rectangles
case
square
lattice
paper
take
new
approach
instead
keep
track
partially
constructed
sap
must
connect
right
boundary
line
major
gain
straightforward
calculate
number
additional
bonds
required
complete
given
partial
sap
turn
results
substantially
faster
algorithm
draw-back
updating
rules
become
much
complicated
basic
idea
best
illustrated
considering
speciﬁc
example
sap
given
figure
cut
sap
vertical
line
dashed
line
see
sap
broken
two
pieces
left
right
cut-line
either
side
line
left
set
partial
loops
means
stage
given
conﬁguration
occupied
edges
along
cut-line
described
two
ways
describe
edges
connected
pairs
forming
loops
left
right
cut-line
moving
left
right
words
keep
track
happened
past
loops
connected
left
prescribe
must
happen
future
edges
connected
right
cut-line
form
valid
sap
new
transfer-matrix
algorithm
exact
enumerations
one
may
think
new
flm
method
taking
initial
seed
sap
must
touch
left
hand
boundary
enclosing
rectangle
known
part
consisting
two
edges
left
boundary
line
right
boundary
line
self-avoiding
walk
known
topology
unknown
shape
length
boundary
line
moved
lattice
overall
topology
sap
must
preserved
topology
conﬁguration
right
hand
side
boundary
line
may
deformed
restriction
extent
topology
deformed
consequence
choice
updates
boundary
line
square
lattice
moves
enclose
one
additional
vertex
two
additional
edges
update
picture
new
flm
method
equally
applicable
enumeration
lattice
object
ﬁxed
topology
self-avoiding
walks
theta
graphs
star
polymers
ﬁnite-lattice
method
algorithms
algorithms
used
enumerate
sap
square
lattice
build
pioneering
work
enting
enumerated
square
lattice
self-avoiding
polygons
using
ﬁnite
lattice
method
ﬁrst
terms
series
polygon
generating
function
calculated
using
transfer
matrix
techniques
count
number
polygons
rectangles
vertices
wide
vertices
long
due
symmetry
square
lattice
one
need
consider
rectangles
polygon
spanning
rectangle
perimeter
length
least
adding
contributions
rectangles
width
wmax
choice
wmax
depends
available
computational
resources
length
2wmax−
contributions
rectangles
counted
twice
number
polygons
per
vertex
inﬁnite
lattice
obtained
correctly
perimeter
4wmax
2.1.
outline
traditional
algorithm
generating
function
rectangle
calculated
using
transfer
matrix
techniques
details
previous
algorithm
found
chapter
outline
aspects
common
algorithms
needed
appreciate
diﬀerences
eﬃcient
implementation
algorithm
generally
involves
bisecting
ﬁnite
lattice
boundary
moving
boundary
way
build
lattice
vertex
vertex
illustrated
figure
draw
sap
cut
line
observe
partial
sap
left
line
consists
number
loops
connecting
two
edges
shall
refer
loop-ends
intersection
end
loop
assigned
one
two
labels
depending
whether
lower
upper
end
loop
conﬁguration
along
boundary
line
thus
new
transfer-matrix
algorithm
exact
enumerations
figure
snapshot
boundary
line
dashed
line
transfer
matrix
calculation
type
conﬁgurations
strip
size
10.
sap
enumerated
successive
moves
kink
boundary
line
exempliﬁed
position
given
dotted
line
one
vertex
two
edges
time
added
strip
left
boundary
line
drawn
example
partially
completed
sap
represented
set
edge
states

empty
edge
lower
loop-end
upper
loop-end
read
bottom
top
conﬁguration
signature
along
intersection
partial
sap
figure
1110200022
since
crossings
permitted
encoding
uniquely
describes
loop-ends
connected
applying
transfer
matrix
technique
enumeration
polygons
regard
sets
edges
ﬁnite
lattice
properties
weight
associated
occupied
edge
vertices
degree
apart
isolated
sites
graph
single
connected
component
graph
must
span
rectangle
left
right
bottom
top
constraint
trivial
satisfy
sum
contributing
graphs
valid
sap
calculated
boundary
moved
lattice
conﬁguration
occupied
empty
edges
along
intersection
maintain
generating
function
partial
polygons
signature
exact
enumeration
studies
truncated
polynomial
conjugate
number
occupied
edges
update
source
signature
boundary
moved
gives
rise
one
two
new
target
signatures
move
boundary
line
new
edges
inserted
leading
update
xkgs
new
transfer-matrix
algorithm
exact
enumerations
constraint
easy
satisfy
kink
edges
empty
leave
new
edges
empty
insert
partial
new
loop
occupying
new
edges
one
kink
edges
occupied
one
new
edges
must
also
occupied
kink
edges
occupied
new
edges
must
empty
easy
see
rules
leads
graphs
satisfying
constraint
figure
three
ways
graphs
separate
components
could
occur
constraint
diﬃcult
satisfy
shown
examples
two-component
graphs
figure
graphs
type
shown
left-most
panel
separate
components
occur
side
side
quite
easy
avoid
never
allowing
insertion
new
loop
totally
empty
conﬁguration
except
initial
seed
state
also
ensures
polygons
touch
left-most
border
rectangle
two
distinct
ways
pair
loops
placed
relative
one
another
side
side
nested
shown
last
two
panels
figure
loop
encoding
given
multiple
components
avoided
allowing
two
connected
loop-ends
join
except
loop-ends
present
case
completed
sap
formed
order
satisfy
constraint
need
add
information
signature
addition
usual
labelling
intersection
boundary
line
also
indicate
whether
partially
completed
polygon
reached
neither
lower
upper
boundaries
rectangle
order
represent
given
partial
polygon
add
information
usual
set
edge
states
add
two
extra
virtual
edge
states
bottom
rectangle
touched
similarly
top
rectangle
touched
2.2.
new
algorithm
basic
properties
considerations
outlined
previous
section
apply
also
new
algorithm
major
diﬀerence
conceptual
namely
stated
section
change
way
keep
track
partial
loops
intersecting
boundary
line
use
exactly
encoding
signature
meaning
lower
upper
loop-end
profoundly
diﬀerent
original
algorithm
terms
referred
partial
loops
connected
left
boundary
new
transfer-matrix
algorithm
exact
enumerations
existing
loops
partially
generated
sap
already
connected
however
new
algorithm
lower
upper
loop-end
refers
occupied
edges
along
boundary
must
connected
via
loop
later
stage
right
boundary
change
turn
results
new
updating
rules
cases
new
loop
inserted
two
loop-ends
join
kink
deal
latter
easier
modiﬁcation
ﬁrst
join
two
loop-ends
boundary
kink
belong
loop
thus
closing
partial
loop
sap
since
loop
encoding
new
algorithm
simply
prescribes
occupied
edges
connected
thus
valid
case
kink-state
kink
states
forbidden
since
would
correspond
connecting
occupied
edges
connected
two
situations
arise
partial
loop
closed
either
occupied
edges
along
boundary
one
proceeds
calculation
edges
empty
closed
sap
formed
added
running
total
sap
generating
function
figure
possible
basic
deformations
topology
boundary
state
boundary
line
shifted
shown
schematically
corresponding
basic
loop
updates
shown
immediately
edge-joining
simpliﬁed
insertion
new
loop
becomes
much
complicated
original
approach
insertion
done
action
required
new
approach
must
connect
two
new
occupied
edges
occupied
edges
boundary
line
restrictions
sap
enumeration
mean
two
new
occupied
edges
must
connect
existing
connected
edges
provided
reachable
later
state
new
occupied
edges
depend
placement
relative
edges
become
connected
state
existing
occupied
edges
may
change
figure
show
two
basic
situations
new
occupied
edges
either
placed
inside
loop
formed
two
existing
connected
edges
placed
outside
ﬁrst
case
shown
left
figure
new
transfer-matrix
algorithm
exact
enumerations
figure
possible
updates
resulting
insertion
new
partial
loop
existing
loop
conﬁguration
bottom
indicate
lower
arc
new
partial
loop
existing
loop
conﬁguration
upper
arcs
accessible
loops
indicated
heavy
lines
three
possible
new
loop
conﬁgurations
shown
top
upper
lower
end
inserted
loop
must
connect
upper
lower
end
existing
loop
terms
edges
involved
states
change
1002
1212
second
case
middle
ﬁgure
upper
lower
end
inserted
loop
must
connect
lower
upper
end
existing
loop
terms
edges
involved
states
change
1200
1122
new
occupied
edges
become
lower
loop-ends
existing
lower
loop-end
changed
upper
loop-end
shown
right
figure
also
symmetric
case
new
loop
placed
existing
loop
leading
state
change
0012
1122
newly
inserted
loop
connect
existing
loop
reached
without
crossing
another
loop
general
situation
illustrated
figure
see
new
loop
connected
three
existing
loops
indicated
thick
lines
second
loop
right
new
loop
nested
inside
existing
loop
therefore
reached
without
crossing
enclosing
loop
likewise
loops
outside
large
loop
enclosing
new
loop
unreachable
case
insertion
single
new
loop
gives
rise
three
new
loop
conﬁgurations
illustrated
top
panels
figure
states
edges
new
loop
conﬁgurations
obtained
applying
appropriate
basic
loop
insertion
stage
seems
nothing
gained
updates
simplify
loop-
insertion
becomes
much
complicated
true
pay-oﬀ
comes
look
pruning
original
approach
pruning
complicated
deeply
nested
conﬁgurations
one
simply
search
possible
ways
connecting
existing
partial
loops
order
ﬁnd
connection
pattern
minimises
number
extra
edges
required
form
valid
sap
new
approach
complication
new
transfer-matrix
algorithm
exact
enumerations
figure
examples
partially
generated
polygons
thick
solid
lines
left
intersection
dashed
line
close
valid
way
thick
wavy
line
upper
left
panel
shows
close
conﬁguration
12112212
upper
middle
right
panels
show
two
possible
closures
conﬁguration
11112222
lower
panels
show
three
possible
closures
conﬁguration
11121222
completely
gone
since
connections
edges
already
prescribed
one
one
way
completing
sap
2.3.
pruning
principle
behind
pruning
quite
simple
brieﬂy
works
follows
firstly
signature
keep
track
current
minimum
number
steps
ncur
already
inserted
left
boundary
line
order
build
particular
conﬁguration
secondly
calculate
minimum
number
additional
steps
nadd
required
produce
valid
polygon
three
contributions
namely
number
steps
required
close
polygon
number
steps
needed
ensure
polygon
touches
lower
upper
border
ﬁnally
number
steps
needed
extend
least
edges
length-wise
direction
remember
need
rectangles
sum
ncur
nadd
4wmax
discard
partial
generating
function
conﬁguration
course
conﬁguration
make
contribution
polygon
count
perimeter
lengths
trying
obtain
instance
polygons
spanning
rectangle
width
close
wmax
almost
convex
convoluted
polygons
possible
thus
conﬁgurations
many
loop-ends
non-zero
entries
make
contribution
perimeter
length
complicated
part
pruning
approach
algorithm
calculate
new
transfer-matrix
algorithm
exact
enumerations
number
steps
required
close
polygon
ﬁrst
stage
connect
separate
pieces
illustrated
figure
separate
pieces
easy
locate
provided
one
last
edge
conﬁguration
top-most
upper
edge
one
piece
connected
lower
edge
nadd
incremented
number
steps
distance
edges
two
edge-states
removed
conﬁguration
processing
second
stage
transform
conﬁgurations
starting
ending
112
122
since
two
lower
upper
edges
safely
connected
two
edge-states
removed
conﬁguration
leading
new
conﬁguration
001
200
processing
two
stages
may
left
conﬁguration
single
lower
edge
single
upper
edge
almost
done
since
two
edges
connected
form
valid
polygon
illustrated
figure
upper
left
panel
shows
close
partial
polygon
intersection
12112212
contain
three
separate
pieces
connecting
pieces
left
conﬁguration
10012002
connect
two
lower
edges
note
ﬁrst
upper
edge
relabeled
lower-edge
become
new
lower
end
loop
thus
get
conﬁguration
00001002
connect
remaining
two
edges
end
valid
completed
polygon
note
last
two
cases
addition
steps
spanning
distance
edges
additional
two
horizontal
steps
added
order
form
valid
loop
around
intervening
edges
transformations
result
closed
polygon
must
conﬁguration
form
111
222
diﬃculty
lies
ﬁnding
way
close
conﬁgurations
smallest
possible
number
additional
steps
suﬃce
say
number
non-zero
entries
small
one
easily
code
possible
valid
ways
closing
polygon
thus
ﬁnd
minimum
number
additional
steps
figure
show
possible
ways
closing
polygons
non-zero
entries
note
shown
generic
cases
actual
cases
could
number
empty
edges
interspersed
conﬁgurations
would
determine
way
closing
sap
would
minimise
nadd
number
distinct
conﬁgurations
given
catalan
numbers
conﬁguration
occupied
edges
occupied
edges
occupied
edges
various
possible
ways
closing
conﬁgurations
hand-coded
general
case
conﬁgurations
non-empty
entries
devised
basic
search
algorithm
simply
tried
possible
ways
closing
loops
practise
initially
two
loop-ends
connected
resulting
new
conﬁguration
passed
two
stages
left
conﬁguration
least
two
fewer
loop-ends
still
open
loops
another
pass
loops
closed
process
repeated
starting
diﬀerent
pair
initial
edges
way
one
search
possible
ways
completing
sap
obviously
one
would
expect
process
ultimately
grow
exponentially
number
non-zero
edges
however
due
simplifying
feature
passing
ﬁrst
two
stages
new
transfer-matrix
algorithm
exact
enumerations
growth
quite
slow
new
approach
almost
complications
pruning
gone
since
connections
edges
already
prescribed
one
one
way
completing
sap
complicating
factor
order
calculate
nadd
need
know
nesting
level
partial
loop
number
edges
takes
connect
two
loop-ends
positions
simply
addition
must
connect
lower
upper
boundaries
ensure
sap
extends
least
edges
length-wise
direction
pruning
procedure
performed
operations
2.4.
comparative
study
algorithms
analysing
complexity
two
algorithms
note
update
step
boundary
moved
may
result
signatures
previous
algorithm
new
one
however
average
case
still
expect
new
algorithm
create
signatures
connections
distant
loop-ends
typically
pruned
away
pruning
believe
complexity
old
algorithm
exponential
see
growth
constant
mercifully
small
sap
whereas
new
algorithm
complexity
table
compare
resources
used
two
algorithms
calculation
number
sap
perimeter
clear
new
approach
eﬃcient
substantial
savings
time
required
number
conﬁgurations
terms
slightly
total
cpu
time
decrease
98.
little
variation
listed
values
higher
values
expect
eventually
see
even
substantial
savings
time
increases
deeply
nested
conﬁgurations
occur
expensive
prune
old
algorithm
see
increasing
time
saving
yet
testament
special
nature
square
lattice
sap
making
pruning
particularly
simple
problem
eﬀort
put
original
implementation
pruning
case
mention
passing
preliminary
implementation
self-avoiding
walks
yielded
substantial
time
savings
square
lattice
large
enough
expect
exponential
complexity
pruning
make
old
algorithm
prohibitively
slow
compared
new
one
however
practice
conceivably
achievable
values
relative
advantage
new
algorithm
old
enumeration
sap
may
best
described
signiﬁcant
rather
dramatic
problems
growth
constant
pruning
large
new
algorithm
would
make
dramatic
diﬀerence
candidate
problems
potentially
dramatic
improvement
mentioned
section
finally
mention
due
simpliﬁed
joining
loops
kink
case
permitted
possible
improve
algorithm
since
edges
equivalent
simplify
kink
states
consider
four
possibilities
new
transfer-matrix
algorithm
exact
enumerations
table
comparison
resources
required
two
algorithms
order
calculate
number
sap
length
old
algorithm
new
algorithm
conﬁgs
3837
15867
61361
293853
1274667
4973585
22041519
94861519
terms
8275
37389
159938
674548
3038260
12976379
56510740
251027714
conﬁgs
time
3826
0.31
15821
2.16
59354
14.60
286441
95.89
1255436
685.41
4921788
4447.89
26770.16
21427764
173408.04
93020737
terms
8039
36660
157367
652805
2948937
12699279
54845786
244009381
time
0.23
1.63
10.75
78.58
571.24
3783.83
22360.05
145454.72
vertical
edge
occupied
part
loop
joining
kink
technically
one
also
view
replacing
two
kink
edges
vertex
four
possible
states
overall
net
beneﬁt
drop
memory
use
improvement
running
time
net
overall
gain
change
also
simpliﬁes
pruning
since
number
special
cases
vertical
kink
edge
occupied
avoided
note
however
change
always
permitted
i..e.
lattices
directed
edges
manhattan
lattices
edges
equivalent
kink-state
simpliﬁcation
valid
extended
sap
enumeration
transfer-matrix
algorithm
eminently
suited
parallel
computations
used
approach
ﬁrst
described
extend
enumeration
sap
perimeter
130
obtain
non-zero
terms
bulk
calculations
paper
performed
cluster
nci
national
facility
anu
nci
peak
facility
sun
constellation
cluster
1492
nodes
sun
x6275
blades
containing
two
quad-core
2.93ghz
intel
nehalem
cpus
nodes
3gb
memory
per
core
24gb
per
node
took
total
25000
cpu
hours
enumerate
sap
perimeter
130.
used
1000
processors
accurately
cores
2.5tb
memory
details
resource
use
given
integer
coeﬃcients
occurring
series
expansion
become
large
calculation
therefore
performed
using
modular
arithmetic
series
calculated
modulo
various
integers
reconstructed
end
using
chinese
remainder
theorem
used
moduli
262
262
262
allowed
represent
correctly
nci
cluster
heavily
used
shared
computing
facility
major
constraint
cpu
time
rather
memory
reason
chose
perform
calculation
new
transfer-matrix
algorithm
exact
enumerations
table
number
embeddings
n-step
self-avoiding
polygons
square
lattice
non-zero
terms
listed
112
114
116
118
120
122
124
126
128
130
646414111975777272517734370762400697757978
4304591798055577073477026735313861700713176
28687064652813390269800415016181829385121162
191320663411431818964849556990106874938907548
1276875276296096391140817393830149918943464494
8527773411790633004325737459634720668141188468
56991966408991589554333823232058663722205631080
381130017241685467740337492217602004487643160168
2550382601811089051031712642200910692143744745034
17076613429289025223970687974244417384681143572320
run
eﬀectively
doubles
memory
requirement
results
increase
running
time
compared
run
using
single
overall
decrease
total
running
time
factor
2.6.
table
lists
new
terms
obtained
work
number
polygons
perimeter
112–130
number
polygons
length
found
length
listed
length
110
full
series
available
www.ms.unimelb.edu.au/~iwan
3.1.
resource
use
one
main
ways
achieving
good
parallel
algorithm
using
data
decomposition
try
ﬁnd
invariant
operation
updating
rules
seek
ﬁnd
property
conﬁgurations
along
boundary
line
alter
single
iteration
algorithm
enumeration
polygons
quite
complicated
since
possible
conﬁgurations
occur
due
pruning
insertion
new
loop
change
state
edge
far
removed
however
still
invariant
since
edge
directly
involved
update
change
empty
occupied
vice
versa
kink
edges
change
occupation
status
invariant
allows
parallelise
algorithm
way
calculation
completely
independently
processor
two
redistributions
data
set
time
extra
column
added
lattice
since
number
processors
use
quite
large
1000
actually
redistribution
per
column
increases
length
invariant
part
thus
gives
better
opportunities
ensure
decent
load
balance
refer
details
regarding
details
parallelised
implementation
table
listed
main
resources
used
parallel
algorithm
order
new
transfer-matrix
algorithm
exact
enumerations
table
resources
used
calculate
number
sap
rectangles
width
listed
left
right
number
processors
total
cpu
time
hours
minimal
maximal
number
conﬁgurations
series
terms
retained
ﬁnally
minimal
maximal
time
seconds
used
redistribution
minimum
maximum
taken
across
processors
procs
time
min
conf
max
conf
min
term
max
term
t-min
t-max
1436
763
1096
1575
2650
2730
2760
2926
1588
11503231
9165975
12287159
16383084
25822571
26581112
32021460
35446404
26124867
73828085
56728718
64909908
70084896
87087766
71874712
63918962
52929622
31132604
9950148
8890870
11962488
15923256
24966483
26089184
31025188
34573073
25632787
87381144
61006162
67080631
72376608
90763851
73445360
66526222
54330414
31768765
160
400
592
800
800
1000
800
400
241
557
1125
2214
3713
5559
4953
2874
450
560
699
964
1345
2321
2272
2379
2690
1482
enumerate
sap
perimeter
130.
width
ﬁrst
list
number
processors
used
total
cpu
time
hours
required
complete
calculation
given
width
one
main
issues
parallel
computing
load
balancing
wish
ensure
greatest
extent
possible
workload
shared
equally
among
processors
aspect
examined
via
numbers
columns
4–9
given
time
calculation
processor
handles
subset
total
number
conﬁgurations
processor
monitor
maximal
number
conﬁgurations
terms
retained
generating
functions
note
number
terms
listed
per
modulo
total
three
times
number
actually
stored
load
balancing
roughly
gauged
looking
largest
max
conf
smallest
min
conf
maximal
number
conﬁgurations
handled
individual
processors
execution
program
columns
listed
largest
max
term
smallest
min
term
maximal
number
terms
retained
generating
functions
associated
subset
conﬁgurations
seen
algorithm
well
balanced
finally
columns
listed
minimal
maximal
total
time
seconds
spent
processor
redistribution
part
algorithm
seen
part
algorithm
takes
total
cpu
time
note
time
spent
preparing
redistribution
processing
data
moved
actual
time
spent
mpi
message
passing
routines
less
total
cpu
time
series
analysis
results
obtain
singularity
structure
generating
functions
used
numerical
method
diﬀerential
approximants
describe
method
refer
interested
reader
details
chapter
overview
new
transfer-matrix
algorithm
exact
enumerations
method
since
odd
terms
series
zero
ﬁrst
non-zero
term
exponent
actually
analysed
series
p2n+4un
function
critical
point
table
list
estimates
critical
point
exponent
estimates
obtained
averaging
values
obtained
second
third
order
diﬀerential
approximants
order
inhomogeneous
polynomial
averaged
approximants
series
used
least
ﬁrst
terms
series
polygons
perimeter
least
110
quoted
error
estimates
reﬂects
spread
basically
one
standard
deviation
among
approximants
note
error
bounds
viewed
measure
true
error
include
possible
systematic
sources
error
based
estimates
conclude
0.143680629269
0.500000015
years
ago
pointed
polynomial
581x4
7x2
polynomial
small
integer
coeﬃcients
relevant
zero
0.1436806292698685
consistent
estimate
clearly
almost
digit
accuracy
conjectured
value
still
stands
emphasised
theoretical
motivation
conjecture
however
agreement
numerical
estimate
impressive
perhaps
surprising
case
polynomial
least
serve
useful
memory
aid
table
estimates
critical
point
exponent
obtained
second
third
order
diﬀerential
approximants
series
square
lattice
polygon
generating
function
order
inhomogeneous
polynomial
second
order
third
order
0.1436806292669
0.1436806292697
0.1436806292684
0.1436806292688
0.1436806292684
0.1436806292686
1.500000027
1.500000021
1.500000023
1.500000019
1.500000018
1.500000019
0.1436806292683
0.1436806292690
0.1436806292694
0.14368062926979
0.1436806292699
0.1436806292695
1.500000023
1.500000021
1.5000000155
1.5000000131
1.500000013
1.5000000154
gauge
whether
estimates
truly
well
converged
results
table
would
suggest
ﬁnd
useful
plot
actual
individual
estimates
last
terms
used
form
given
diﬀerential
approximant
ﬁrst
two
panels
figure
plotted
estimates
functions
point
represents
estimate
third
order
diﬀerential
approximant
approximants
appear
well
converged
given
high
resolution
abscissa
sign
signiﬁcant
systematic
drift
finally
third
panel
plotted
estimated
versus
corresponding
estimates
conjectures
exact
values
correct
estimates
ideally
pass
point
intersection
conjectured
values
clearly
slight
new
transfer-matrix
algorithm
exact
enumerations
0.14368062930
1.5000003
1.50000015
0.14368062928
0.14368062926
0.14368062924
0.14368062922
1.5000002
2-α
1.5000001
1.50000010
2-α
1.50000005
1.5000000
1.50000000
0.14368062920
100
110
120
130
100
1.4999999
120
130
0.14368062924
..5
1.49999995
110
..7
..8
..6
figure
estimates
critical
point
critical
exponent
versus
left
middle
panels
versus
right
panel
square
lattice
polygon
generating
function
straight
lines
correspond
3/2
0.1436806292698685
0.56230145
0.56230140
0.56230135
0.56230130
0.56230125
0.56230138
0.56230136
0.56230134
0.56230132
0.56230130
0.56230128
0.000
0.005
0.010
0.015
0.020
0.025
0.000
0.005
0.010
0.015
0.020
0.025
1/n
1/n
figure
estimates
amplitude
versus
1/n
data
set
obtained
ﬁtting
form
using
correction
terms
plot
right
enlarged
version
plot
left
discrepancy
3/2
biased
estimate
critical
point
0.1436806292672
since
diﬀerence
occurs
12th
signiﬁcant
digit
feel
conﬁdent
numerical
evidence
alone
suﬃcient
settle
matter
ultimately
let
reader
make
judgement
detailed
asymptotic
form
coeﬃcients
polygon
generating
function
studied
detail
previously
argued
sign
non-analytic
corrections-to-scaling
exponents
polygon
generating
function
one
therefore
ﬁnds
ai/ni
even
µnn−5/2x
i≥0
estimates
leading
amplitude
thus
obtained
ﬁtting
form
using
increasing
values
useful
check
behaviour
estimates
plotting
results
leading
amplitude
versus
1/n
see
figure
new
transfer-matrix
algorithm
exact
enumerations
last
term
used
ﬁtting
varied
130
50.
note
correction
terms
added
estimates
exhibits
less
curvature
slope
become
less
steep
strong
evidence
indeed
correct
asymptotic
form
estimate
0.56230129
summary
outlook
implemented
new
algorithm
enumeration
sap
square
lattice
new
method
shows
considerable
promise
future
enumeration
studies
new
algorithm
used
extend
series
number
sap
square
lattice
110
130.
analysis
extended
series
yielded
improved
estimates
critical
parameters
0.143680629269
2.63815853035
0.500000015
0.56230129
expect
new
algorithm
prove
widely
applicable
chose
sap
square
lattice
study
simplest
model
computer
implementation
thus
best
illustrating
basic
principles
involved
diﬀerences
old
new
algorithms
improvement
running
time
signiﬁcant
unspectacular
however
anticipate
gains
realised
new
algorithm
greater
lattices
models
self-avoiding
walks
theta
graphs
star
polymers
especially
useful
situations
many
candidate
completions
must
considered
pruning
certainly
case
three-dimensional
lattices
restrictions
crossing
nested
loops
exist
hopeful
new
algorithm
allow
fast
enumeration
three-dimensional
lattice
objects
via
ﬁnite
lattice
method
future
test
implementing
new
algorithm
sap
saw
simple
cubic
lattice
acknowledgements
work
supported
award
merit
allocation
scheme
nci
national
facility
anu
supported
arc
centre
excellence
mathematics
statistics
complex
systems
mascos
supported
australian
research
council
discovery
projects
funding
scheme
grant
dp0770705
references
madras
slade
1993
self-avoiding
walk
boston
birkh¨auser
hughes
1995
random
walks
random
environments
vol
random
walks
oxford
clarendon
guttmann
2009
polygons
polyominoes
polycubes
vol
775
lecture
notes
physics
springer
leibler
singh
fisher
1987
thermodynamic
behavior
two-dimensional
vesicles
physical
review
letters
1989–1992
new
transfer-matrix
algorithm
exact
enumerations
fisher
1989
fractal
nonfractal
shapes
two-dimensional
vesicles
physica
112–118
fisher
guttmann
whittington
1991
two-dimensional
lattice
vesicles
polygons
journal
physics
3095–3106
nienhuis
1982
exact
critical
point
critical
exponents
models
two
dimensions
physical
review
letters
1062–1065
nienhuis
1984
critical
behavior
two-dimensional
spin
models
charge
asymmetry
coulomb
gas
journal
statistical
physics
731–761
enting
1980
generating
functions
enumerating
self-avoiding
rings
square
lattice
phys
3713–3722
jensen
guttmann
1999
self-avoiding
polygons
square
lattice
phys
4867–4876
guttmann
whittington
1978
two-dimensional
lattice
embeddings
connected
graphs
cyclomatic
index
two
journal
physics
mathematical
general
721–729
jensen
2003
parallel
algorithm
enumeration
self-avoiding
polygons
square
lattice
phys
5731–5745
guttmann
enting
1988
size
number
rings
square
lattice
journal
physics
l165–172
guttmann
1989
asymptotic
analysis
power-series
expansions
phase
transitions
critical
phenomena
eds
domb
lebowitz
new
york
academic
vol
1–234
conway
enting
guttmann
1993
algebraic
techniques
enumerating
self-
avoiding
walks
square
lattice
phys
math
gen.
1519–1534
conway
guttmann
1996
square
lattice
self-avoiding
walks
corrections
scaling
phys
rev
lett
5284–5287
