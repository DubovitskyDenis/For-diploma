weight
hierarchy
family
cyclic
codes
arbitrary
number
nonzeroes
shuxing
lia
adepartment
mathematics
hong
kong
university
science
technology
clear
water
bay
kowloon
hong
kong
abstract
generalized
hamming
weights
ghws
fundamental
parameters
lin-
ear
codes
ghws
great
interest
many
applications
since
convey
detailed
information
linear
codes
paper
continue
work
study
ghws
family
cyclic
codes
arbitrary
number
nonzeroes
weight
hierarchy
determined
employing
number-theoretic
approach
keywords
cyclic
codes
generalized
hamming
weights
weight
hierarchy
2000
msc
11t71
94b05
94b15
introduction
linear
code
ﬁnite
ﬁeld
k-dimensional
subspace
linear
subcode
support
deﬁned
linear
space
supp
cn−1
r-th
generalized
hamming
weight
ghw
given
min
cid:8
|supp
dimfq
cid:9
|supp
denotes
cardinality
set
supp
deﬁnition
minimum
distance
set
called
weight
hierarchy
concept
ghws
ﬁrst
introduced
helleseth
kløve
mykkeltveit
used
computation
weight
distributions
rediscov-
ered
wei
fully
characterize
performance
linear
codes
used
wire-tap
channel
type
t-resilient
function
indeed
ghws
provide
detailed
structural
information
linear
codes
also
used
email
address
lsxlsxlsx1987
gmail.com
shuxing
preprint
submitted
finite
fields
applications
september
2018
compute
state
branch
complexity
proﬁles
linear
codes
determine
erasure
list-decodability
linear
codes
general
determination
weight
hierarchy
diﬃcult
classes
linear
codes
whose
weight
hierarchies
known
see
comprehensive
enumeration
related
references
paper
continues
work
determine
weight
hierarchy
family
cyclic
codes
arbitrary
number
nonzeroes
result
regarded
extension
results
weight
hierarchy
semiprimitive
codes
computed
achieve
generalizing
number-theoretic
approach
introduced
rest
paper
organized
follows
section
introduce
concerned
family
cyclic
codes
state
main
result
section
present
number-theoretic
approach
computation
ghws
section
prove
main
result
section
concludes
paper
main
result
section
introduce
concerned
family
cyclic
codes
describe
main
result
ﬁrst
set
notations
used
throughout
rest
paper
let
prime
positive
integers
let
primitive
element
ﬁnite
ﬁeld
following
three
assumptions
mod
q−1
mod
gcd
mod
iii
deg
hai
hai
haj
denotes
minimal
polynomial
γ−a
let
deﬁne
gcd
gcd
cid:18
cid:19
polynomial
without
loss
generality
choose
deﬁne
cyclic
code
length
whose
parity-check
i=1
hai
speciﬁed
according
three
as-
sumptions
therefore
cyclic
code
nonzeroes
family
cyclic
codes
ﬁrst
introduced
weight
distributions
computed
several
cases
due
ﬂexibility
parameters
family
contains
abundance
cyclic
codes
interesting
cyclic
codes
fact
presented
uniﬁed
approach
computation
weight
distributions
certain
cyclic
codes
included
many
previous
results
special
cases
moreover
results
suggest
family
codes
highly
structured
hopeful
obtain
detailed
information
generalized
hamming
weights
therefore
authors
obtained
weight
hierarchy
following
cases
mod
mod
arithmetic
progression
computation
relies
heavily
generalizing
number-theoretic
idea
proposed
key
point
computation
evaluation
corresponding
gauss
periods
simple
note
next
simplest
case
evaluation
gauss
periods
so-called
semiprimitive
case
let
prime
integer
semiprimitive
case
exists
positive
integer
mod
paper
consider
ghws
semiprimitive
case
speciﬁcally
following
main
result
theorem
let
prime
set
suppose
positive
integers
satisfying
assumptions
let
positive
integers
speciﬁed
satisfying
let
cyclic
code
length
parity-check
polynomial
i=1
hai
suppose
smallest
positive
integer
mod
suppose
odd
even
write
r1m
suppose
r-th
ghw
qm−1
qm−1
qr2
qr2
−1+
−qr2
following
three
remarks
remark
according
lemma
assumption
iii
always
holds
true
hence
theorem
need
choose
integers
satisfying
assumptions
meanwhile
condition
ensures
assumption
iii
also
holds
remark
semiprimitive
case
choosing
resulting
code
simply
semiprimitive
code
ghws
semiprimitive
codes
studied
precisely
code
semiprimitive
code
theorem
reduces
theorem
theorem
4.1
corollary
general
i.e.
code
reducible
cyclic
code
result
theorem
new
remark
conditions
odd
even
crucial
fact
two
conditions
essentially
used
computation
weight
hier-
archy
binary
semiprimitive
codes
without
determination
weight
hierarchy
even
simplest
binary
semiprimitive
codes
remains
challenging
problem
conﬁrm
correctness
theorem
provide
numerical
exam-
ples
obtained
using
magma
example
cyclic
code
weight
hierarchy
code
follows
coincides
result
theorem
example
cyclic
code
weight
hierarchy
code
follows
coincides
result
theorem
number-theoretic
approach
ghws
let
cyclic
code
deﬁned
section
section
introduce
number-theoretic
approach
computation
ghws
firstly
give
brief
introduction
cyclic
codes
group
characters
gauss
periods
secondly
derive
two
general
expressions
closely
related
determination
ghws
used
computation
3.1.
cyclic
codes
let
linear
code
gcd
called
cyclic
code
cn−1
implies
cyclic
shift
cn−1
cn−2
cyclic
code
codeword
cn−1
associated
polynomialpn−1
i=0
cixi
principal
ideal
ring
correspondence
identiﬁed
ideal
hence
unique
monic
polynomial
xn−1
smallest
degree
among
elements
called
generator
polynomial
xn−1
called
parity-check
polynomial
speciﬁed
cyclic
code
uniquely
determined
either
generator
polynomial
parity-check
polynomial
said
nonzeroes
parity-check
polynomial
factorized
product
irreducible
polynomials
thus
cyclic
codes
deﬁned
section
may
arbitrary
number
nonzeroes
cyclic
code
said
irreducible
one
nonzero
otherwise
called
reducible
cyclic
code
3.2.
group
characters
gauss
periods
let
prime
number
canonical
additive
character
given
trq
exp
cid:0
2π√−1/p
cid:1
primitive
p-th
root
unity
trq
trace
function
power
transitivity
trace
functions
trq
multiplicative
subgroup
deﬁne
gauss
period
let
primitive
element
denote
hγni
generated
γihγni
called
i-th
cyclotomy
class
xx∈c
3.3.
first
expression
going
derive
ﬁrst
expression
related
ghws
delsarte
theorem
codewords
represented
uniquely
i=1
runs
set
trq
txj=1
γaj
i
words
map
isomorphism
two
fq-vector
spaces
correspondence
r-dimensional
fq-subspaces
hence
induces
1-1
r-dimensional
set
r-dimensional
fq-subspaces
subcodes
fq-vector
space
denote
byh
deﬁne
deﬁne
max
cid:26
cid:20
cid:21
cid:27
since
isomorphism
deﬁnition
r-th
ghw
expressed
according
section
deﬁne
q−1
following
expression
eδqr
xb∈hr
exh=1
j=1
always
consider
case
case
expression
simpliﬁed
follows
deﬁne
linear
transformation

...

...


=

...
...

···
···
···
...


...

indeed
induces
isomorphism
bjβh
...
...

txj=1



txh=1
tδqr
xb∈hr
txh=1
tδqr
xy∈ψ
cid:21
cid:21
max
ψ−1
cid:20
j=1
note
max
cid:20
sake
convenience
rewrite
tδqr
xy∈hr
txh=1
permutes
r-dimensional
subspaces
therefore
makes
essential
diﬀerence
computation
ghws
ﬁrst
expression
concerning
3.4.
second
expression
subsection
derive
alternative
expression
main
tool
following
bilinear
form
let
non-degenerate
bilinear
form
given
trq
txi=1
xiyi
fq-subspace
deﬁne
following
lemma
lemma
lemma
suppose
cid:0
cid:1
qtm−r
xx∈h⊥
dimfq
lemma
second
expression
concerning
txh=1
tδqr
xy∈hr
txh=1
tδqr
xy∈ft
txh=1
xz∈c
tδqt
xx∈h⊥
txh=1
xz∈c
tδqt
xx∈h⊥
txh=1
xz∈c
xx∈h⊥
z+xh=0
xi=0
i6=h
qtm−r
xx∈h⊥
xy∈ft
xiyi
zyh
trq
txi=1
xiyi
zyh
txi=1
xy1
...
yt∈fq
use
expression
determine
weight
hierarchy
proof
theorem
going
prove
theorem
throughout
section
following
assumptions
even
smallest
positive
integer
mod
odd
···
h+1
···
since
deﬁne
cid:18
···
h−1
h−1
txh=1
xz∈c
z+xh=0
xi=0
i6=h
txh=1
xx∈h⊥
h+1
···
cid:19
×fq
wh|
txh=1
|uh
wh|
note
fq-vector
space
given
dimension
ﬁrst
step
need
consider
maximal
size
intersection
end
following
lemma
determines
maximal
size
intersection
cyclotomy
class
fq-subspace
given
subset
use
denote
set
lemma
let
smallest
positive
integer
mod
let
odd
even
let
l-dimensional
fq-subspace
deﬁne
function
maxn
cid:12
cid:12
cid:12
ql−1
−ql−
cid:12
cid:12
cid:12
dimfq
furthermore
subspace
achieves
maximal
value
chosen
follows
choose
l-dimensional
subspace
γif
choose
l-dimensional
subspace
disjoint
union
ql−
cosets
γif
γif
proof
suppose
exists
l-dimensional
subspace
maximal
γil
l-dimensional
subspace
|γil∩
also
maximal
hence
suﬃces
consider
case
odd
mod
since
mod
|l∩
choosing
subspace
clearly
maximal
deﬁne
γhf
since
dimfq
implies
dimfq
ql−
note
v=0
u=1
v=0
u+vn
u=1
v=0
u+vn
−1xv=0
−1xu=1
u+vn|
ql−
implies
ql−
ql−
next
going
show
choosing
proper
subspace
upper
bound
achieved
let
l-dimensional
subspace
consists
ql−
contains
ql−
suppose
thus
write
∪ql−
u=0
claim
disjoint
cosets
lh|
since
linear
space
thus
claim
true
morevoer
u=1
u=0
∪ql−
∪ql−
−1xu=1
ql−
ql−
comparing
get
ql−
together
=|l
−1xv=1
vn|
ql−
therefore
achieves
upper
bound
deﬁne
dimfq
deﬁnition
tmi=1
implies
i=1
lemma
easy
see
maximal
size
intersection
equals
therefore
tδpt
i=1
make
large
possible
must
havept
i=1
implies
tmi=1
moreover
chosen
|ui
wi|
conse-
quently
max
cid:20
cid:21
max
txi=1
txi=1
viewpoint
subspace
corresponding
maximal
characterized
sequence
i=1
without
loss
generality
assume
wherept
···
since
writept
i=1
r1m
unique
next
going
study
sequence
leads
maximal
preparation
deﬁne
two
operations
sequence
suppose
satisﬁes
deﬁne
operation
sij
sij
ui−1
ui+1
uj−1
uj+1
suppose
form
deﬁne
operation
furthermore
deﬁne
l−2
txi=1
function
deﬁned
lemma
following
lemma
concerning
change
summation
operations
sij
applied
recall
denote
unique
integer
lemma
let
satisfy
following
use
qv+1
sij
sij
sij
proof
proof
elementary
omitted
similarly
deﬁne
lemma
dicates
operations
tion
nondecreasing
operation
sake
convenience
deﬁne
operation
sij
lemma
in-
employed
summa-
employed
situation
involved
precise
deﬁne
inverse
operation
fs2
follows
suppose
satisﬁes
deﬁne
operation
fs2
ui−1
ui+1
uj−1
uj+1
fs2
given
sequence
satisfying
given
sequence
satisfying
ui−1
viewed
inverse
hence
operation
fs2
remark
restates
lemma
remark
10.
let
sequence
following
fs2
fs2
fs2
resp
resp
fs2
therefore
summation
applied
nondecreasing
operation
going
show
sequence
trans-
formed
one
sequences
special
forms
using
operations
moreover
help
lemma
remark
make
sure
operation
used
transformation
keeps
summa-
tion
nondecreasing
hence
sequence
producing
maximal
value
among
sequences
special
forms
next
describe
transformation
process
fs2
given
sequence
entries
greater
resp
repeatedly
less
always
get
sequence
form
apply
operation
resp
repeatedly
one
following
two
cases
applying
operation
case
even
l1+
case
odd
l1+
l2−1
fs2
next
using
operations
sequence
case
case
transformed
one
following
four
cases
cases
derived
case
cases
derived
case
recall
r1m
observe
operation
involved
transformation
keeps
summation
nondecreasing
case
even
case
even
case
odd
l2+1
case
odd
l2+1
=
=
=
=
r1−1
r1−1
r1−1
r1−1
instance
let
see
sequences
case
derived
case
sequence
form
applying
operation
repeatedly
gives
applying
operation
fs2
repeatedly
gives
according
lemma
remark
operation
involved
trans-
formation
keeps
summation
nondecreasing
hence
sequences
case
obtained
similarly
derive
corresponding
sequences
remaining
three
cases
therefore
shown
sequence
transformed
one
four
cases
since
operation
involved
transformation
keeps
summation
nondecreasing
sequence
leading
maximal
value
must
belong
one
four
cases
considering
cases
direct
computation
shows
r1−1
r1−1
thus
sequence
leads
maximal
value
consequently
cid:21
max
cid:20
qr2
considering
cases
direct
computation
shows
thus
sequence
leads
maximal
value
consequently
cid:21
max
cid:20
qr2
qr2−
together
proof
theorem
complete
conclusion
generalized
hamming
weights
fundamental
parameters
linear
codes
convey
structural
information
linear
code
determine
performance
various
applications
however
computation
ghws
linear
codes
diﬃcult
general
paper
sequel
studies
ghws
family
cyclic
codes
introduced
may
arbi-
trary
number
nonzeroes
determine
weight
hierarchy
generalizing
number-theoretic
approach
proposed
worthy
note
main
theorem
regarded
extension
known
results
concerning
weight
hierarchy
semiprimitive
codes
interesting
question
whether
techniques
paper
applied
complicated
cases
recall
two
crucial
conditions
main
theorem
semiprimitive
modulo
ask
weight
hierarchy
also
computed
semiprimitive
mod
modulo
belongs
index
case
namely
generates
index
subgroup
multiplicative
group
units
acknowledgement
author
wishes
express
gratitude
professor
cunsheng
ding
professor
maosheng
xiong
guidance
encouragement
stay
hong
kong
university
science
technology
references
delsarte
subﬁeld
subcodes
modiﬁed
reed-solomon
codes
ieee
trans
inform
theory
:575–576
1975
forney
dimension/length
proﬁles
trellis
complexity
linear
block
codes
ieee
trans
inform
theory
:1741–1752
1994
guruswami
list
decoding
erasures
bounds
code
construc-
tions
ieee
trans
inform
theory
:2826–2833
2003
helleseth
kløve
mykkeltveit
weight
distribution
irreducible
cyclic
codes
block
length
discrete
math.
:179–211
1977
helleseth
vijay
kumar
weight
hierarchy
semiprim-
itive
codes
discrete
math.
152
1-3
:185–190
1996
kasami
takata
fujiwara
lin
optimum
bit
orders
respect
state
complexity
trellis
diagrams
binary
linear
codes
ieee
trans
inform
theory
:242–245
1993
kløve
weight
distribution
linear
codes
gen-
erator
matrix
discrete
math.
:159–168
1978
van
der
vlugt
weight
hierarchy
irreducible
cyclic
codes
combin
theory
ser
:159–167
1995
wei
generalized
hamming
weights
linear
codes
ieee
trans
inform
theory
:1412–1418
1991
xiong
weight
hierarchy
reducible
cyclic
codes
ieee
trans
inform
theory
:4071–4080
2016
yang
xiong
ding
luo
weight
distribution
class
cyclic
codes
arbitrary
number
zeros
ieee
trans
inform
theory
:5985–5993
2013
yang
xiong
xia
weight
distributions
class
cyclic
codes
arbitrary
number
nonzeros
quadratic
case
finite
fields
appl.
36:41–62
2015
yang
feng
lin
generalized
hamming
weights
ieee
trans
inform
theory
:4905–4913
irreducible
cyclic
codes
2015
