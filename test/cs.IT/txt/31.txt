ieee
transactions
communications
generalized
piggybacking
codes
distributed
storage
systems
shuai
yuan1
qin
huang2,1
senior
member
ieee
zulin
wang2
member
ieee
1qian
xuesen
laboratory
space
technology
china
academy
space
technology
beijing
china
100094
2school
electronic
information
engineering
beihang
university
beijing
china
100191
email
yuanshuai
qxslab.cn
qhuang.smash
gmail.com
wzulin
201
163.com
abstract
paper
generalizes
piggybacking
constructions
distributed
storage
systems
considering
various
protected
instances
piggybacked
instances
analysis
demonstrates
proportion
protected
instances
determines
average
repair
bandwidth
systematic
node
optimizing
proportion
protected
instances
repair
ratio
generalized
piggybacking
codes
approaches
zero
instead
number
parity
check
nodes
tends
inﬁnity
furthermore
computational
complexity
repairing
single
systematic
node
cost
generalized
piggybacking
codes
less
existing
piggybacking
designs
part
paper
accepted
ieee
global
communications
conference
ieee
globecom
2016
corresponding
author
huang
october
2018
draft
ieee
transactions
communications
index
terms
piggybacking
distributed
storage
systems
mds
node
repair
introduction
nowadays
distributed
storage
systems
dsss
increasingly
employed
network
applications
data
dsss
deployed
multiple
storage
devices
however
discrete
devices
prone
failure
malfunctions
maintenance
order
ensure
reliability
stored
data
even
occurrence
node
unavailability
dsss
supposed
introduce
redundancy
resist
storage
node
failures
replication
simplest
redundant
fashion
adopted
improve
reliability
many
dsss
google
file
system
hadoop
distributed
file
system
hdfs
rapid
growth
amount
storage
data
erasure
coding
become
better
choice
dsss
compared
replication
able
provide
orders
magnitude
reliability
increasing
storage
resource
consumption
result
several
large-scale
systems
oceanstore
total
recall
windows
azure
storage
google
colossus
gfs2
employed
erasure
coding
techniques
improve
storage
efﬁciency
maximum
distance
separable
mds
codes
one
kind
erasure
codes
introduced
many
dsss
optimal
storage
efﬁciency
mds
property
used
recover
missing
data
dss
consider
n-node
dss
deployed
mds
code
one
node
storage
system
failed
data
stored
nodes
required
reconstruct
missing
data
failure
node
times
amount
stored
data
needed
recover
missing
data
thus
usage
network
disk
signiﬁcantly
high
i.e.
repair
efﬁciency
low
address
repair
issue
many
codes
constructed
reduce
transmission
data
repairing
failure
node
statement
three
types
node
repair
exact
repair
functional
repair
exact
repair
systematic
part
however
exact
repair
considered
practical
october
2018
draft
ieee
transactions
communications
dsss
dimakis
deﬁned
amount
transmission
data
repairing
one
single
failed
node
repair
bandwidth
authors
derived
optimal
tradeoff
storage
repair
bandwidth
theoretic
cut-set
bound
proposed
regenerating
codes
lie
tradeoff
curve
existence
construction
regenerating
codes
studied
however
optimal
tradeoff
provided
regenerating
codes
derived
functional
repair
almost
interior
points
storage-bandwidth
tradeoff
achievable
exact
repair
mds
array
codes
another
important
class
erasure
codes
used
ddss
advantage
simple
encoding
decoding
procedures
easily
implemented
hardware
devices
many
designs
mds
array
codes
evenodd
b-code
x-code
rdp
star
zigzag
codes
presented
storage
communication
applications
however
repair
bandwidth
mds
array
codes
achieve
theoretic
cut-set
bound
2011
rashmi
proposed
new
kind
distributed
storage
codes
called
piggybacking
codes
reduce
data
amount
read
downloaded
node
repair
key
idea
piggybacking
codes
taking
several
instances
existing
base
code
attaching
linear
combinations
symbols
protected
instances
non-protected
instances
hence
missing
symbols
protected
instances
able
recovered
solving
linear
equations
instead
mds
decoding
piggybacking
simple
useful
construction
improve
repair
efﬁciency
missing
nodes
several
designs
piggybacking
codes
presented
designs
able
save
repair
bandwidth
one
failed
node
average
facebook
warehouse
cluster
new
hadoop
distributed
file
system
hdfs
employed
piggybacking
codes
improve
repair
efﬁciency
although
piggybacking
codes
practical
easy
implementation
reduction
repair
bandwidth
proposed
piggybacking
designs
still
gap
theoretic
cut-set
bound
regenerating
codes
rashmi
shah
ramchandran
gave
three
speciﬁc
piggybacking
october
2018
draft
ieee
transactions
communications
constructions
second
one
represent
rsr-ii
efﬁcient
construction
terms
repair
bandwidth
description
shows
rsr-ii
codes
able
save
repair
bandwidth
paper
investigates
mechanism
reduction
repair
bandwidth
using
piggybacking
codes
recovery
methods
systematic
symbols
distinguish
instances
piggybacking
codes
protected
stripes
non-protected
stripes
analysis
lower
bound
repair
bandwidth
rsr-ii
codes
implies
proportion
protected
instances
determines
repair
efﬁciency
piggybacking
constructions
paper
ﬁrstly
presents
generalized
piggybacking
design
various
protected
non-
protected
stripes
order
obtain
various
proportion
protected
stripes
second
lower
bound
upper
bound
repair
bandwidth
generalized
piggybacking
codes
introduced
analysis
two
bounds
indicates
optimizing
proportion
protected
stripes
repair
ratio
deﬁned
average
repair
bandwidth
fraction
amount
original
messages
generalized
piggybacking
code
approaches
zero
instead
number
parity
check
nodes
tends
inﬁnity
closer
minimum
storage
regenerating
msr
codes
theoretical
lower
bound
last
computational
complexity
repair
single
failed
systematic
node
analyzed
results
show
generalized
piggybacking
codes
able
provide
efﬁcient
repair
little
complexity
overhead
remainder
paper
organized
follows
section
brieﬂy
introduces
piggy-
backing
framework
rsr-ii
codes
section
iii
performs
analysis
repair
efﬁciency
rsr-ii
codes
generalized
piggybacking
codes
presented
section
finally
conclusion
given
section
maximum
distance
separable
codes
background
consider
linear
block
code
code
length
dimension
represents
minimum
hamming
distance
code
called
mds
code
minimum
october
2018
draft
ieee
transactions
communications
hamming
distance
meets
singleton
bound
i.e.
mds
codes
important
class
linear
block
codes
given
parameters
minimum
distance
reaches
maximum
possible
value
thus
mds
codes
able
correct
many
erasures
given
mds
codes
extensively
applied
many
dsss
n-node
storage
system
initially
original
message
divided
information
packets
subsequently
packets
encoded
packets
stored
nodes
respectively
mds
property
messages
nodes
could
reconstruct
original
message
thus
system
able
tolerate
failures
storage
nodes
piggybacking
framework
subsection
introduce
piggybacking
framework
basis
construct-
ing
piggybacking
codes
piggybacking
framework
guarantees
dsss
able
employ
piggybacking
codes
without
extra
cost
storage
moreover
decoding
properties
error-correction
codes
adopted
original
dsss
minimum
distance
mds
property
ruined
piggybacking
reconstruction
general
piggybacking
framework
operates
multiple
instances
existing
base
code
adds
several
designed
functions
data
instances
onto
instances
base
code
piggybacking
framework
arbitrary
fact
attractive
feature
practice
piggybacking
framework
dsss
enjoy
repair
bandwidth
reduction
small
modiﬁcation
based
existing
error-correction
codes
consider
linear
block
code
represented
encoding
functions
i=1
suppose
original
message
encoded
symbols
i=1
n-node
system
using
base
code
piggybacking
framework
instances
illustrated
fig.1
october
2018
draft
ieee
transactions
communications
stripe
stripe
stripe
node
node
...
g2,1
g3,1
g2,2
g3,2
...
...
...
node
···
···
···
...
···
stripe
gα,1
···
uα−1
gα,2
···
uα−1
...
···
uα−1
fig
piggybacking
framework
shown
fig.1
rows
correspond
storage
nodes
columns
called
stripes
i=1
independent
original
messages
i=2
j=1
piggyback
functions
important
consideration
piggyback
functions
added
i-th
stripe
linear
combinations
original
messages
stripes
i−1
principle
guarantees
stripes
piggybacking
framework
decodable
recursion
process
stripe
piggyback
functions
added
original
message
directly
recovered
using
decoding
procedure
stripe
j=1
decoded
easy
compute
added
piggyback
functions
subtract
stored
symbols
decodable
similar
way
decoding
procedures
stripes
ﬁnished
ui−1
available
piggyback
functions
ui−1
j=1
base
code
stripe
obtained
subtracting
piggybacking
functions
recovered
statement
symbols
stored
one
node
independent
sometimes
invertible
linear
transformation
performed
simplify
computation
transformation
still
retains
decoding
properties
piggybacking
framework
rsr-ii
codes
piggybacking
framework
described
section.ii-b
rashmi
presented
three
designs
piggybacking
codes
different
considerations
second
design
rsr-ii
october
2018
draft
ieee
transactions
communications
constructed
purpose
pursuing
high
efﬁciency
repair
statement
rsr-ii
codes
save
repair
bandwidth
systematic
node
sake
simple
description
mds
code
systematic
form
chosen
base
code
denote
n−k
number
parity
check
nodes
rsr-ii
codes
consist
2r−3
in-
stances
base
code
represent
2r−3
associated
original
messages
a2r−3
vector
length
ai,1
ai,2
stripes
shown
following
form
node
...
a1,1
...
a2,1
...
node
node
k+1
...
...
...
node
k+r
···
...
···
···
...
···
a2r−3,1
...
a2r−3
a2r−3
...
a2r−3
encoding
vectors
corresponding
parity
check
symbols
base
code
piggyback
functions
rsr-ii
codes
linear
combinations
systematic
symbols
ﬁrst
stripes
added
last
parity
check
symbols
last
stripes
construction
piggyback
functions
taken
three
steps
i=1
evenly
possible
without
loss
generality
suppose
multiple
deﬁne
three
variables
follows
first
systematic
nodes
split
node
sets
r−1
hence
ﬁrst
node
sets
i=1
size
remaining
r−1
i=t+1
size
october
2018
draft
ieee
transactions
communications
···
ar−2
···
ar−2
pr−1
i−1ar−1−
p2r−3
j=r
ar−1+
ar+
j=1
j6=i−1
ˆvi
i,1vi
···
ar+i−3+
ar+i−2+
i−2vi
ivi
node
k+i
piggyback
functions
ar+
i,1vi
···
ar+i−3+
ar+i−2+
i−2vi
ivi
node
k+i
invertible
linear
transform
fig
stored
symbols
piggybacked
node
k+i
second
deﬁne
two
sets
vectors
length
i=2
ˆvi
ar−1
iar−2
i2ar−3
ir−2a1
ˆvi
ar−1
iar−2
i2ar−3
ir−2a1
i=2
···
···
a2r−3+
r−1vi
a2r−3+
r−1vi
introduce
selection
vectors
r−1
i=2
ˆvi
i=2
segments
selection
vectors
deﬁned
follows
i=2
j=1
separate
tuples
vector
mjpi
r−1
corresponding
systematic
nodes
therefore
j=1
diagonal
matrices
size
k×k
diagonal
positions
r−1
xj=1
finally
add
piggyback
functions
i=2
j=1
parity
check
symbols
last
nodes
hence
node
k+i
following
form
shown
fig.2
invertible
linear
transformation
introduced
reduce
complexity
i=2
qi.j
r−1
i=2
ˆvi
node
repair
finally
symbols
node
k+i
illustrated
fig.2
repair
bandwidth
rsr-ii
codes
use
repair
ratio
represent
measure
repair
efﬁciency
distributed
storage
code
repair
ratio
deﬁned
average
amount
transfer
data
needed
repairing
one
october
2018
draft
ieee
transactions
communications
failure
node
fraction
original
messages
subsection
recall
repair
procedure
one
systematic
node
rsr-ii
codes
repair
ratio
rsr-ii
γsys
computed
consider
n-node
dss
deployed
rsr-ii
code
sake
simple
description
represent
ﬁrst
stripes
protected
stripes
whose
systematic
symbols
involved
piggyback
functions
deﬁned
protected
symbols
meanwhile
last
stripes
represented
non-protected
stripes
whose
systematic
symbols
named
non-protected
symbols
l-th
systematic
node
fails
repair
procedure
node
recover
missing
protected
symbols
r−1
2r−3
section.ii-c.
repair
procedure
described
algorithm
i=1
missing
non-protected
symbols
i=r
assume
node
belongs
one
node
sets
described
algorithm
repair
algorithm
rsr-ii
codes
recovering
missing
non-protected
symbols
2r−3
i=r
base
code
rsr-ii
code
systematic
mds
form
according
mds
property
directly
recovered
ai,1
l−1
l+1
getting
piggyback
functions
involved
missing
protected
systems
r−1
i=1
statement
ii-c
r−1
piggyback
functions
containing
piggyback
functions
linear
combinations
protected
symbols
download
parity
check
symbols
containing
piggyback
functions
subtract
items
2r−3
i=1
left
j=r
piggyback
functions
involved
r−1
recovering
missing
protected
symbols
r−1
i=1
including
r−1
i=1
surviving
protected
symbols
sj\l
also
involved
piggyback
functions
obtained
step
download
surviving
symbols
subtract
r−1
piggyback
functions
r−1
i=1
reconstructed
solving
left
linear
combinations
october
2018
draft
ieee
transactions
communications
algorithm
symbols
needed
downloaded
step
symbols
needed
step
step
size
number
downloaded
symbols
otherwise
size
symbols
downloaded
denote
average
repair
bandwidth
one
systematic
node
bsys
number
systematic
nodes
node
sets
size
number
systematic
nodes
node
set
size
thus
bsys
tth
thus
repair
ratio
γsys
γsys
bsys
tth
tt2
iii
efficiency
analysis
rsr-ii
codes
section
analysis
repair
efﬁciency
rsr-ii
performed
introduce
notation
stripe-repair
ratio
measure
repair
efﬁciency
one
stripe
repair
bandwidth
systematic
symbol
amount
original
message
stripe
consider
piggybacking
code
stripes
assume
stripe-repair
ratios
stripes
nodes
piggybacking
code
γsys
following
form
i=1
denote
proportions
stripes
i=1
thus
repair
ratio
systematic
october
2018
γsys
xi=1
piηi
draft
ieee
transactions
communications
recall
rsr-ii
codes
described
section
ii-d.
repair
procedure
deals
missing
protected
non-protected
symbols
two
different
measures
mds
decoding
adopted
recovery
non-protected
symbols
amount
downloading
repairing
one
missing
non-protected
symbol
symbols
regard
missing
protected
symbols
solving
linear
combinations
employed
average
bandwidth
depends
size
node
set
containing
failure
node
denote
ηnp
stripe-repair
ratios
protected
non-protected
stripes
respectively
amount
original
message
one
stripe
equals
symbols
stored
systematic
nodes
hence
ηnp
although
approximate
value
given
equation
obvious
ηnp
i.e.
repair
procedure
protected
stripes
requires
less
downloaded
symbols
compared
non-
protected
stripes
mechanism
reduction
repair
bandwidth
using
piggybacking
codes
remainder
section
explore
critical
factors
inﬂuencing
repair
efﬁciency
analysis
γsys
proportion
non-protected
stripes
rewrite
γsys
represent
proportion
protected
stripes
thus
form
equation
γsys
ηnp
tt2
2r−3
ηnp
tt2
r−1
means
tells
nonnegative
integers
satisfy
following
inequality
inequality
quadratic
arithmetic
r−1−t
xi=1
october
2018
cid:19
cid:18
pi=1
draft
able
ieee
transactions
communications
thus
tt2
tth
equality
i.e.
multiple
case
γsys
reach
lower
bound
min
γsys
min
γsys
according
equation
γsys
approaches
0.5
number
parity
check
nodes
tends
inﬁnite
i.e.
rsr-ii
codes
able
save
repair
bandwidth
dss
whose
parameters
given
order
improve
repair
efﬁciency
structure
piggybacking
design
supposed
modiﬁed
analysis
protected
stripe-repair
ratio
smaller
ηnp
implies
repair
efﬁciency
piggybacking
codes
may
improved
increasing
according
equation
actually
larger
means
protected
symbols
involved
one
piggyback
function
leads
reduction
therefore
possible
improve
repair
efﬁciency
piggybacking
codes
optimizing
proportion
protected
stripes
generalized
piggybacking
codes
section
present
generalized
construction
contains
various
protected
non-protected
stripes
analysis
performed
clarify
relationship
repair
ratio
proportion
protected
stripes
results
show
proposed
generalized
piggybacking
codes
able
provide
efﬁcient
node
repair
optimizing
repair
ratio
γsys
generalized
piggybacking
codes
approaches
zero
number
parity
check
nodes
tends
inﬁnity
october
2018
draft
ieee
transactions
communications
node
...
a1,1
...
···
as,1
...
...
as+1,1
...
···
as+p,1
...
...
node
as+1
node
k+1
···
as+1
···
···
node
k+2
as+1
···
···
as+p
...
...
...
...
···
as+p
as+p
...
...
...
node
k+r
···
as+1
···
as+p
fig
instances
base
code
code
design
similarly
choose
systematic
mds
code
base
code
generalized
piggybacking
code
n−k
parity
check
number
two
parameters
introduced
represent
numbers
protected
piggybacked
stripes
respectively
figure
depicts
instances
according
construction
principle
piggybacking
framework
piggyback
functions
added
i-th
stripe
involve
original
messages
stripes
i−1
sake
simple
analysis
add
piggyback
functions
parity
check
symbols
non-protected
stripes
redeﬁne
non-protected
stripes
piggybacked
stripes
illustrated
fig.3
symbols
stored
stripes
divided
regions
region
contains
systematic
symbols
protected
stripes
region
contains
systematic
symbols
ﬁrst
parity
check
symbol
piggybacked
stripes
region
contains
parity
check
symbols
protected
stripes
region
contains
last
parity
check
symbols
piggybacked
stripes
systematic
node
failure
happens
repair
procedure
supposed
regenerate
october
2018
draft
ieee
transactions
communications
missing
symbols
region
similar
rsr-ii
codes
systematic
symbols
region
self-sustaining
according
mds
property
missing
symbols
one
row
region
could
recovered
surviving
symbols
rows
systematic
symbols
region
piggybacking
functions
constructed
protected
piggyback
functions
supposed
embedded
region
size
region
i.e.
piggyback
functions
designed
noteworthy
fact
failed
protected
symbols
one
row
region
simultaneously
recovered
solving
set
linear
combinations
order
guarantee
enough
piggyback
functions
simultaneously
recover
missing
symbols
region
following
inequality
must
satisﬁed
choose
parameters
remainder
subsection
method
construction
piggyback
functions
illustrated
follows
construct
r−1
empty
piggybacking
array
column
piggybacking
array
corresponds
one
piggyback
function
fill
protected
symbols
region
piggybacking
array
protected
symbols
region
form
array
shown
fig.3
step
takes
symbols
rowwise
array
ﬁlls
piggybacking
array
obviously
divisible
last
row
piggyback
array
would
full
obtain
piggybacking
functions
add
region
protected
symbols
allocated
piggyback
array
sum
symbols
column
thus
piggybacking
functions
obtained
added
region
arbitrary
order
remarkable
piggyback
functions
summations
protected
symbols
october
2018
draft
ieee
transactions
communications
result
recovery
missing
protected
symbols
could
simple
example
presented
illustrate
partition
method
repair
procedure
example
consider
systematic
mds
code
base
code
set
denote
length
input
message
vectors
thus
original
storage
array
protected
symbols
region
fill
piggyback
array
sum
symbols
column
achieve
six
piggyback
functions
finally
generalized
piggybacking
code
constructed
follows
october
2018
draft
ieee
transactions
communications
+a3
+a4
analysis
repair
bandwidth
recall
construction
piggyback
functions
section.iv-a
dividable
systematic
symbols
partitioned
piggyback
functions
uneven
deﬁne
sizes
piggyback
functions
numbers
contained
systematic
symbols
region
without
loss
generality
assume
sizes
denote
r−1
obviously
satisfy
r−1
xi=1
suppose
l-th
systematic
node
fails
remaining
symbols
stored
region
except
node
needed
reconstruct
as+1
as+p
mds
property
amount
transmitted
step
symbols
region
parity
check
symbols
containing
piggyback
functions
required
recover
missing
protected
symbols
moreover
components
along
as+1
as+p
subtracted
downloaded
parity
check
symbols
however
left
piggybacking
functions
still
involved
protected
symbols
besides
hence
symbols
region
needed
assume
sizes
piggybacking
functions
ni1
ni2
nis
download
amount
systematic
symbols
region
step
ni1
ni2
nis
derive
total
bandwidth
repairing
systematic
nodes
symbols
region
october
2018
draft
ieee
transactions
communications
need
downloaded
k2p
times
consider
parity
check
symbol
stored
region
suppose
size
piggybacking
function
embedded
parity
check
symbol
repair
procedures
parity
check
symbol
needs
downloaded
times
meanwhile
involved
systematic
symbols
region
needs
downloaded
times
therefore
total
repair
bandwidth
systematic
nodes
k2p
r−1
i=1
average
repair
ratio
γsys
γsys
k2p
r−1
xi=1
rewrite
equation
γsys
k2p
r−1
xi=1
hk2p
r−1
pi=1
pi6=j
k2s2
pi6=j
without
loss
generality
assume
dividable
hk2p
t′l
t′h
t′l
thus
piggyback
functions
size
t′h
rest
ones
size
t′l
γsys
goes
γsys
hk2p
k2s2
dss
parameters
base
code
given
thus
γsys
varied
different
values
order
explore
relationship
γsys
proportion
protected
october
2018
draft
ieee
transactions
communications
100
r=5
low
r=5
r=10
low
r=10
r=50
low
r=50
r=1000
low
r=1000
0.1
0.2
0.3
0.4
0.6
0.7
0.8
0.9
0.5
fig
lower
upper
bounds
various
instances
derived
follows
s+p
lower
upper
bounds
γsys
k2s2
k2p
γsys
γsys
hk2p
cid:16
4k2
cid:17
k2s2
rewrite
lower
upper
bounds
functions
γlow
γup
γlow
γup
cid:16
4k2
cid:17
example
assume
code
rate
base
code
0.5
i.e.
various
figure
shows
curves
γlow
γup
illustrates
lower
bound
γlow
upper
bound
γup
close
moreover
reach
extreme
points
optimizing
implies
generalized
piggybacking
code
obtain
optimum
γsys
appropriate
parameters
october
2018
draft
ieee
transactions
communications
analyze
optimum
condition
γsys
derivatives
γlow
γup
respect
listed
follows
∂γlow
∂pp
∂γup
∂pp
−rp2
−rp2
2rpp
2rpp
4k2
let
∂γlow
∂pp
∂γup
∂pp
γup
follows
equal
zero
work
minimum
values
γlow
min
γlow
2√r+1
1√r
min
γup
−2+2rr+
r−1
results
indicate
r−1
4k2
rr+
r−1
4k2
min
γlow
determined
number
parity
check
nodes
min
γup
determined
however
high
code
rate
min
γup
dominantly
determined
min
γup
corresponds
closely
min
γlow
words
exists
gener-
alized
piggybacking
code
whose
repair
ratio
close
lower
bound
figure
shows
curves
min
γlow
min
γup
implies
min
γsys
min
γlow
end
subsection
perform
asymptotic
analyses
min
γsys
min
γsys
compare
repair
ratio
minimum
storage
regenerating
msr
codes
sr.
limits
min
γsys
min
γsys
approaches
inﬁnity
lim
r→+∞
lim
r→+∞
min
γsys
min
γsys
lim
r→+∞
lim
r→+∞
0.5
described
msr
codes
correspond
best
storage
efﬁciency
one
two
important
classes
regenerating
codes
repair
bandwidth
one
failure
october
2018
draft
ieee
transactions
communications
min
low
min
min
min
rate:0.4
rate:0.6
rate:0.8
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
100
101
102
103
104
fig
minimum
values
γsys
γsys
node
represents
size
original
messages
denotes
number
accessed
surviving
nodes
dimension
msr
code
sake
simple
comparison
set
code
rate
0.5
msr
code
provides
highest
repair
efﬁciency
thus
curves
min
γsys
min
γsys
shown
fig.6
shows
min
γsys
approaches
zero
instead
number
parity
check
nodes
tends
inﬁnity
result
compared
rsr-ii
codes
generalized
piggybacking
codes
able
provide
efﬁcient
node
repair
less
bandwidth
moreover
min
γsys
closer
theoretical
lower
bound
repair
ratio
table
compares
repair
efﬁciency
rsr-ii
codes
generalized
piggybacking
codes
various
code
parameters
illustrated
increasing
number
parity
check
nodes
generalized
piggybacking
codes
reach
smaller
repair
bandwidth
october
2018
draft
ieee
transactions
communications
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
sys
sys
min
min
γmsr
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
fig
lower
bounds
average
repair
bandwidths
table
efficiency
comparison
different
explicit
codes
rsr-ii
codes
generalized
piggybacking
codes
stripes
γsys
0.5886
0.5341
0.5207
0.5147
0.5114
0.5068
200
100
197
0.5026
stripes
γsys
0.6400
0.4867
0.4133
0.3700
0.3344
0.2740
0.1819
analysis
decoding
complexity
subsection
complexity
node
repair
procedure
generalized
piggybacking
codes
analyzed
ﬁrst
comparison
rsr-ii
codes
performed
shown
computational
complexity
repairing
single
systematic
node
cost
generalized
piggybacking
codes
much
less
rsr-ii
codes
statement
section.iii
iv-b
piggybacking
codes
adopt
two
kinds
calculations
october
2018
draft
ieee
transactions
communications
repair
failed
node
mds
decoding
used
recovery
missing
symbols
non-protected
piggybacked
stripes
solving
linear
combinations
employed
recon-
struct
missing
symbols
protected
stripes
recall
generalized
piggybacking
code
section.iv-a
protected
stripes
piggybacked
stripes
repair
procedure
l-th
systematic
node
described
section.iv-b
order
recover
as+i
missing
symbol
i-th
piggybacked
stripe
symbols
as+i
required
denote
vector
representation
as+i,1
as+i
l−1
as+i
l+1
as+i
pj,1
as+i
worked
equation
as+i
p−1
as+i
as+i,1pj,1
as+i
l−1pj
l−1
as+i
l+1pj
l+1
as+i
kpj
hence
mds
decoding
recovery
one
missing
symbol
piggybacked
stripe
costs
multiplications
additions
consider
recovery
missing
symbol
i-th
protected
stripe
according
description
section.iv-a
denote
piggyback
function
involves
together
protected
symbols
order
reconstruct
region
stored
symbol
containing
needed
surviving
protected
symbols
also
required
hence
ﬁgured
follows
compute
parity
check
symbol
step
costs
multiplications
k−1
additions
subtract
parity
check
symbol
thus
addition
needed
subtract
nx−
surviving
protected
symbols
form
left
thus
nx−
additions
required
actually
represents
size
piggyback
function
i.e.
equals
t′l
t′h
therefore
solving
linear
combinations
one
missing
protected
symbol
costs
multiplications
additions
average
october
2018
r−1
draft
ieee
transactions
communications
table
computational
complexity
node
repair
multiplications
additions
r−1
mds
decoding
solving
linear
combinations
computational
complexity
mds
decoding
solving
linear
combinations
listed
table
according
analysis
section.iii
solving
linear
combinations
introduced
piggyback-
ing
codes
reduce
repair
bandwidth
partial
missing
symbols
rsr-ii
codes
missing
protected
symbols
need
simultaneously
recovered
solving
group
linear
functions
result
perform
gaussian
elimination
however
generalized
piggybacking
codes
piggyback
functions
simple
summations
protected
symbols
compared
calculations
mds
decoding
solving
linear
combinations
cost
r−1
additions
thus
generalized
piggybacking
framework
able
provide
high
repair
efﬁciency
signiﬁcantly
reduce
repair
bandwidth
single
failed
systematic
node
low
computational
complexity
conclusion
discussion
paper
presents
generalized
piggybacking
construction
various
protected
instances
piggybacked
instances
compared
previous
design
proposed
generalized
pig-
gybacking
codes
save
repair
bandwidth
optimizing
proportion
protected
instances
number
parity
check
nodes
tends
inﬁnity
average
repair
bandwidth
fraction
total
messages
approaches
zero
moreover
complexity
analysis
demonstrates
generalized
piggybacking
codes
able
efﬁciently
repair
failed
node
reasonable
october
2018
draft
ieee
transactions
communications
complexity
overhead
fact
look
piggybacking
functions
view
error-correction
codes
piggy-
backing
codes
perfect
encounter
codes
small
minimum
hamming
distance
codes
large
minimum
hamming
distance
repair
systematic
symbols
piggybacked
stripes
relied
base
codes
stripes
base
codes
strong
erasure-correction
capability
due
large
minimum
distance
however
results
strong
correlation
among
symbols
thus
decoding
good
codes
requests
large
amount
data
access
repair
protected
stripes
piggybacking
functions
linear
combinations
protected
systematic
symbols
words
symbols
together
piggyback
functions
considered
linear
codes
small
minimum
distance
since
bad
codes
weak
correlation
among
symbols
decoding
requests
small
amount
data
access
acknowledgment
sincerely
thank
prof.
shu
lin
dr.
zhiying
wang
constructive
suggests
paper
received
funding
nsaf
grant
u1530117
national
natural
science
foundation
china
grant
61471022
also
sponsored
laboratory
independent
innovation
project
qian
xuesen
laboratory
space
technology
references
ghemawat
gobioff
s.-t.
leung
google
ﬁle
system
proc
acm
sigops
operating
systems
review
vol
2003
2943
borthakur
hdfs
architecture
guide
2008
online
available
http
//hadoop.apache.org/common/docs/current/hdfs
design.pdf
weatherspoon
kubiatowicz
erasure
coding
vs.
replication
quantitative
comparison
proc
peer-to-peer
systems
iptps
2002
328337
rhea
eaton
geels
weatherspoon
zhao
kubiatowicz
pond
oceanstore
prototype
proc
2nd
usenix
conf
file
storage
technologies
fast
2003
114
bhagwan
tati
cheng
savage
voelker
total
recall
system
support
automated
availability
management
proc
1st
conf
networked
systems
design
implementation
nsdi
2004
2525.
october
2018
draft
ieee
transactions
communications
calder
wang
ogus
nilakantan
skjolsvold
mckelvie
srivastav
simitci
al.
windows
azure
storage
highly
available
cloud
storage
service
strong
consistency
proc
23rd
acm
symposium
operating
systems
principles
2011
143157
google-gfs2
colossus
2012
online
available
http
//www.quora.com/colossus-google-gfs2
dimakis
ramchandran
suh
survey
network
codes
distributed
storage
proceedings
ieee
vol
476489
2011
dimakis
godfrey
wainwright
ramchandran
network
coding
distributed
storage
systems
ieee
trans
inf
theory
vol
45394551
2010
cullina
dimakis
searching
minimum
storage
regenerating
codes
proc
47th
annu
allerton
conf
commun.
control
comput.
2009
rashmi
shah
kumar
ramchandran
explicit
construction
optimal
exact
regenerating
codes
distributed
storage
proc
47th
annu
allerton
conf
commun.
control
comput.
2009
12431249
suh
ramchandran
exact-repair
mds
codes
distributed
storage
using
interference
alignment
proc
ieee
int
symp
inf
theory
2010
161165
rashmi
shah
kumar
optimal
exact-regenerating
codes
distributed
storage
msr
mbr
points
via
product-matrix
construction
ieee
trans
inf
theory
vol
52275239
2011
tang
parampalli
framework
constructions
minimal
storage
regenerating
codes
optimal
access/update
property
ieee
trans
inf
theory
vol
19201932
2015
shah
rashmi
kumar
kannan
distributed
storage
codes
repair-by-transfer
nonachievability
interior
points
storage-bandwidth
tradeoff
ieee
trans
inf
theory
vol
18371852
2012
blaum
brady
bruck
menon
evenodd
efﬁcient
scheme
tolerating
double
disk
failures
raid
architectures
ieee
trans
computers
vol
192202
1995
bohossian
bruck
wagner
low-density
mds
codes
factors
complete
graphs
ieee
trans
inf
theory
vol
18171826
1999
bruck
x-code
mds
array
codes
optimal
encoding
ieee
trans
inf
theory
vol
272276
1999
corbett
english
goel
grcanac
kleiman
leong
sankar
row-diagonal
parity
double
disk
failure
correction
proc
3rd
usenix
conference
file
storage
technologies
fast
2004
huang
star
efﬁcient
coding
scheme
correcting
triple
storage
node
failures
ieee
trans
computers
vol
889901
2008
tamo
wang
bruck
zigzag
codes
mds
array
codes
optimal
rebuilding
ieee
trans
inf
theory
vol
15971616
2013.
october
2018
draft
ieee
transactions
communications
rashmi
shah
ramchandran
piggybacking
design
framework
read-and
download-efﬁcient
distributed
storage
codes
proc
ieee
int
symp
inf
theory
2013
331335
rashmi
shah
ramchandran
piggybacking
design
framework
read-and
download-efﬁcient
distributed
storage
codes
2013
online
available
http
//arxiv.org/pdf/1302.5872.pdf
rashmi
shah
dikang
hairong
dhruba
kannan
solution
network
challenges
data
recovery
erasure-coded
distributed
storage
systems
study
facebookwarehouse
cluster
presented
part
5th
usenix
workshop
hot
topics
storage
file
system
2013
yang
tang
systematic
piggybacking
design
minimum
storage
regenerating
codes
ieee
trans
inf
theory
vol
57795786
2015.
october
2018
draft
