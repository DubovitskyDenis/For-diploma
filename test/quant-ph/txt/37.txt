leqa
latency
estimation
quantum
algorithm
mapped
quantum
circuit
fabric
department
electrical
engineering
university
southern
california
los
angeles
90089
u.s.a.
mohammad
javad
dousti
massoud
pedram
dousti
pedram
usc.edu
abstract
paper
presents
leqa
fast
latency
estimation
tool
evaluating
performance
quantum
algorithm
mapped
quantum
fabric
actual
quantum
algorithm
latency
computed
performing
detailed
scheduling
placement
routing
quantum
instructions
qubits
quantum
operation
dependency
graph
quantum
circuit
fabric
however
expensive
proposition
requires
large
amounts
processing
time
instead
leqa
based
computing
neighborhood
population
counts
qubits
produce
estimates
circuit
latency
good
accuracy
i.e.
average
less
error
two
orders
magnitude
speedup
mid-size
benchmarks
speedup
expected
increase
superlinearly
function
circuit
size
operation
count
categories
subject
descriptors
b.7.2
integrated
circuits
design
aids
simulation
placement
routing
general
terms
algorithms
performance
design
keywords
quantum
computing
latency
estimation
algorithm
quantum
fabric
cad
tool
introduction
accurately
calculate
latency
total
execution
time
software
program
one
needs
simulate
run
specific
processor
changing
processor
architecture
including
size
cache
memories
internal
buffers
affect
latency
dramatically
number
approaches
proposed
estimate
program
latency
without
performing
time
consuming
simulations
researchers
area
quantum
computing
face
issue
estimating
latency
quantum
algorithm
programmed
high-level
quantum
programming
language
qpl
field
problem
even
harder
size
quantum
programs
real-size
problems
huge
simulation
time
much
time
consuming
classical
programs
devising
new
quantum
algorithm
challenging
task
complex
structure
today
quantum
computers
non-intuitive
principles
i.e
quantum
physics
built
upon
currently
quantum
algorithms
designed
evaluated
asymptotic
runtime
analysis
i.e
big
notation
unfortunately
many
cases
asymptotic
analysis
coarse-grained
practical
use
simulation
mean
tracing
execution
quantum
operations
simulation
quantum
program
calculating
results
performed
efficiently
classical
computers
even
mid-size
problems
algorithm
developers
another
problem
quantum
computers
built
using
current
technology
capable
executing
toy-
size
programs
used
experimentally
determine
latency
quantum
program
hence
devising
fast
yet
accurate
method
estimating
latency
program
necessary
method
would
enable
quantum
algorithm
designers
evaluate
new
algorithms
learn
efficient
ways
coding
quantum
algorithms
quickly
comparing
latency
different
software
coding
techniques
moreover
method
allows
designers
quantum
error
correction
codes
qecc
investigate
effect
different
error
correction
codes
latency
quantum
programs
latency
important
factor
qecc
designers
since
quantum
computers
allow
limited
amount
time
running
quantum
program
without
using
error
correction
qecc
high
impact
latency
time
one
needs
know
latency
quantum
program
know
much
error
correction
needs
complex
inter-dependency
quantum
algorithm
latency
one
hand
qecc
used
hand
paper
present
procedural
method
accurately
quickly
estimate
latency
quantum
program
tool
called
quantum
algorithm
latency
estimator
leqa
developed
based
method
best
knowledge
research
conducted
topic
rest
paper
organized
follows
section
uses
prior
art
describe
somewhat
novel
design
flow
compiling
quantum
algorithm
mapping
primitive
quantum
structures
2-d
plane
section
explains
estimation
method
used
latency
calculation
procedural
method
presented
estimating
average
routing
latency
cnot
gates
section
introduces
new
parameter
called
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
average
routing
latency
qubit
average-size
presence
zone
routing
channels
congested
estimation
parameter
explained
followed
detailed
description
leqa
prototype
software
implementation
proposed
method
section
presents
experimental
results
section
concludes
paper
quantum
design
flow
typical
quantum
circuit
fabric
consists
infinite
2-d
array
identical
primitive
structures
called
quantum
templates
paper
structure
containing
sites
generating/initializing
qubits
measuring
performing
operations
one
two
qubits
channels
information
unfortunately
dealing
primitive
template
array
cumbersome
unwieldy
practice
another
2-d
array
super-
templates
call
tiles
built
tile
comprises
number
primitive
templates
instead
mapping
quantum
circuit
directly
quantum
fabric
quantum
circuit
mapped
tiled
architecture
see
quantum
logic
synthesis
tool
surveyed
reference
generates
reversible
quantum
circuit
every
qubit
output
circuit
moving
qubits
swapping
called
logical
qubit
subsequently
encoded
several
physical
qubits
detect
correct
potential
errors
prevent
propagation
errors
quantum
circuit
reversible
logic
gates
synthesized
circuit
typically
cnot
toffoli
gates
must
converted
fault-
tolerant
quantum
operations
possible
universal
redundant
set
quantum
operations
includes
cnot
hadamard
π/4
rotation
-π/4
rotation
phase
gates
note
gates
one
two-qubit
gates
implementation
quantum
operations
depend
picked
error
correction
method
note
set
cnot
constitutes
universal
basis
quantum
circuit
realization–the
operations
included
enable
logical
simplification
process
converting
logic
synthesis
output
quantum
operation
realization
quantum
fabric
natively
capable
performing
universal
set
one
two-qubit
instructions
also
called
native
quantum
instructions
set
differs
among
various
quantum
fabrics
quantum
operation
implemented
using
composition
native
quantum
instructions
transformation
logical
gates
results
quantum
logic
synthesis
quantum
operations
quantum
operations
native
quantum
instructions
called
quantum
synthesis
quantum
fabric
synthesis
respectively
quantum
quantum
fabric
synthesis
outside
scope
paper
quantum
operations
performs
desired
function
one
two
logical
qubits
input
producing
one
two
logical
qubits
output
input
qubits
encoded
number
physical
qubits
output
qubits
also
coded
moreover
quantum
operations
requires
syndrome
extraction
circuitry
following
quantum
gate
order
detect
correct
errors
certain
limit
may
introduced
quantum
operation
based
adopted
encoding
scheme
implementation
aforementioned
quantum
operations
may
require
hundreds
tens
thousands
native
quantum
instructions
given
quantum
fabric
various
works
e.g
suggested
using
tiled
quantum
architecture
tqa
composed
regular
two-dimensional
array
universal
logic
blocks
ulbs
avoid
dealing
complexity
notice
ulb
tqa
capable
performing
quantum
operations
ulbs
separated
routing
channels
needed
move
logical
qubits
information
qubits
source
ulbs
target
ulb
tqa
pictorial
representation
tqa
shown
figure
quantum
structures
placed
junctions
routing
channels
may
thought
quantum
crossbars
possibly
qubit
purification
capability
routing
channels
quantum
crossbars
also
built
quantum
templates
ulb
ulb
ulb
ulb
ulb
ulb
ulb
ulb
ulb
ulb
ulbulb
figure
3×3
tiled
quantum
architecture
tqa
ulb
analogous
configurable
logic
block
clb
fpga
device
implement
set
target
functions
moreover
ulb
identified
unique
row
column
indices
ulb
array
configured
perform
different
quantum
operations
different
times
needed
analogous
on-the-fly-reconfigurable
clb
appropriate
high-level
transformations
quantum
algorithm
may
represented
quantum
operation
dependency
graph
qodg
nodes
represent
quantum
operations
edges
capture
data
dependencies
one-qubit
operation
represented
node
one
edge
entering
one
edge
leaving
hand
two-qubit
operation
shown
using
node
two
edges
entering
two
edges
leaving
one
edge
called
control
edge
called
target
edge
assumed
order
gates
change
synthesis
step
two
edges
qodg
come
one
node
another
node
edges
combined
order
keep
graph
simple
also
due
no-cloning
theorem
fan-out
circuit
forbidden
start
node
added
connects
first-level
nodes
order
satisfy
initial
dependencies
also
end
node
added
last-level
nodes
connected
two
extra
nodes
simplify
problem
formulation
sample
synthesized
quantum
circuit
qodg
constructed
presented
figure
3-input
toffoli
gate
start
end
circuit
figure
synthesized
ham3
circuit
size
hamming
optimal
coding
note
circuit
contains
gates
qodg
constructed
circuit
shown
numbers
added
relate
node
corresponding
operation
based
target
quantum
fabric
error
threshold
particular
quantum
coding
selected
subsequently
high-level
tool
maps
qodg
tqa
ulb
tile
architecture
implement
operation
fault-tolerant
way
latency
quantum
algorithm
mapped
tqa
calculated
length
longest
path
critical
path
mapped
qodg
length
path
qodg
summation
latencies
operations
located
path
plus
routing
latencies
qubit
operands
note
critical
path
mapped
qodg
may
critical
path
original
qodg
latter
contain
routing
latencies
logical
qubits
latencies
change
scheduling
slacks
hence
may
change
critical
path
entire
graph
mapping
qodg
tqa
comprises
three
intertwined
steps
scheduling
placement
routing
steps
depend
example
result
placement
routing
increase
routing
latency
logical
qubit
hence
qubit
may
fail
meet
timing
requirements
scheduling
result
operation
deferred
one
scheduling
steps
quantum
mapping
problem
similar
corresponding
problem
traditional
vlsi
area
hard
problem
hence
several
heuristics
proposed
near-optimally
unfortunately
heuristics
still
slow
produce
mapping
solution
details
every
qubit
movement
tqa
since
quantum
computers
still
mature
enough
handle
large-scale
problems
detailed
information
quantum
mapper
produces
excessive
useful
hence
introduce
model
quickly
estimate
latency
quantum
algorithm
explained
next
literature
solving
estimating
latency
quantum
algorithm
𝑢𝑢∈𝐶𝐶
latency
quantum
algorithm
may
calculated
follows
operations
differently
two-qubit
operation
cnot
operation
delays
qodg
order
determine
critical
path
𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐�𝑑𝑑𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶+𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
�+�𝑁𝑁𝑢𝑢𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐�𝑑𝑑𝑢𝑢+𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢�
determined
calculating
critical
path
circuit
explained
earlier
considering
critical
path
original
qodg
instead
critical
path
mapped
qodg
introduces
errors
𝐷𝐷=𝑁𝑁𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
set
one-qubit
operations
etc
𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
𝑁𝑁𝑢𝑢𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
number
cnots
operations
𝑁𝑁𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
type
one-qubit
operations
critical
path
𝑑𝑑𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑑𝑑𝑢𝑢
determine
delay
cnot
operation
type
respectively
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢
capture
average
routing
latency
cnot
operation
type
note
equation
treats
one
two-qubit
𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
𝑁𝑁𝑢𝑢𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
different
one-qubit
operations
𝑁𝑁𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢
added
estimation
model
values
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
accurately
𝑑𝑑𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑑𝑑𝑢𝑢
depend
underlying
fabric
given
𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢
estimated
empirically
since
routing
qubit
current
location
also
occupied
another
qubit
value
𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢
set
2×𝑇𝑇𝑚𝑚𝑢𝑢𝑎𝑎𝑚𝑚
𝑇𝑇𝑚𝑚𝑢𝑢𝑎𝑎𝑚𝑚
physical
parameter
captures
challenge
estimate
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
interesting
estimating
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
suggested
knowing
value
estimating
technology
error
correction
control
techniques
used
parameters
output
ulb
fabric
designer
tool
low
runtime
execution
order
minutes
produces
exact
results
used
algorithms
hence
values
parameters
types
operations
assumed
represents
average
traveling
routing
time
two
logical
qubits
source
locations
target
ulb
i.e.
ulb
two
qubits
interact
value
accounts
traffic
congestion
routing
channels
paper
procedural
method
time
logical
qubit
needs
move
ulbs
channels
quantum
crossbars
another
ulb
channel
quantum
crossbar
neighborhood
empirical
result
shows
average
qubit
needs
move
nearest
ulb
one-qubit
operation
main
complex
one-qubit
operation
done
ulb
qubit
currently
resides
nearest
free
ulb
critical
path
one
calculate
latency
quantum
program
using
equation
3.1
estimating
average
routing
latency
cnot
wire
length
estimation
problem
traditional
vlsi
area
approximates
average
total
wire
length
among
connected
standard
logic
cells
performing
time-consuming
cell
placement
routing
steps
problem
similar
aforesaid
fact
complex
mainly
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
also
depends
scheduling
qodg
precisely
mapping
qodg
quantum
fabric
consists
three
steps
scheduling
placement
routing
steps
interrelated
none
optimally
solved
without
solving
others
placement
routing
affect
result
scheduling
turn
affects
timing
slacks
qodg
placement
done
optimally
without
considering
effect
routing
channel
congestions
also
note
placement
problem
one
assign
logical
qubits
logical
operations
ulbs
compared
vlsi
placement
problem
dynamically
moveable
cells
since
qubits
move
execution
program
also
two
operations
may
assigned
ulb
long
scheduled
done
different
time
slots
moreover
size
qodg
real-
size
problems
generally
far
larger
standard
vlsi
gate-level
netlists
estimation
problem
complex
traditional
vlsi
counterpart
logical
qubit
hypothetical
presence
zone
assumed
qubit
performs
interactions
zone
also
shows
area
qubits
interact
qubit
question
located
point
time
zones
located
different
places
tqa
fabric
overlap
overlap
resembles
congestion
since
possible
one
qubit
pass
overlapping
area
time
figure
depicts
illustration
five
presence
zones
placed
randomly
fabric
showing
interaction
among
five
qubits
overlapping
area
among
zones
congested
area
highly
congested
figure
five
presence
zones
placed
randomly
fabric
since
result
placement
known
priori
zones
assumed
placed
randomly
uniformly
independently
fabric
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
estimated
using
equation
𝑐𝑐𝑎𝑎𝑢𝑢
ε�𝑆𝑆𝑞𝑞�×𝑑𝑑𝑞𝑞
𝑄𝑄𝑞𝑞=1∑
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑆𝑆𝑞𝑞
𝑄𝑄𝑞𝑞=1
𝑆𝑆𝑞𝑞
=𝐴𝐴
𝑞𝑞=0
equation
used
area
fabric
equal
total
number
ulbs
starts
instead
since
parts
fabric
may
covered
presence
zones
since
calculating
latency
used
total
number
logical
qubits
𝑆𝑆𝑞𝑞
expected
surface
fabric
covered
exactly
overlapping
presence
zones
𝑑𝑑𝑞𝑞
average
routing
latency
qubit
average-size
presence
zone
routing
channels
occupied
qubits
assuming
ulb
1×1
square
equation
shows
constraint
𝑆𝑆𝑞𝑞
note
summation
index
constraint
unoccupied
surface
meaningless
𝑆𝑆𝑞𝑞
𝑆𝑆𝑞𝑞
𝑄𝑄𝑞𝑞=1
equation
normalized
value
𝑆𝑆𝑞𝑞
calculate
𝑆𝑆𝑞𝑞
𝑆𝑆𝑞𝑞
=�𝑄𝑄𝑞𝑞����𝑃𝑃𝑥𝑥
𝑦𝑦�𝑞𝑞�1−𝑃𝑃𝑥𝑥
𝑦𝑦�𝑄𝑄−𝑞𝑞
𝑃𝑃𝑥𝑥
probability
ulb
position
fabric
fabric
width
length
fabric
remember
fabric
modeled
grid
𝑎𝑎×𝑏𝑏
square-shape
ulbs
𝑎𝑎×𝑏𝑏=
coefficient
number
ways
choose
presence
zones
total
presence
zones
i.e
equals
total
number
ulbs
fabric
covered
exactly
presence
zones
exactly
presence
zones
calculating
equation
times
equation
calculates
𝑃𝑃𝑥𝑥
nominator
two
min
functions
using
equation
time
consuming
hence
first
terms
calculated
practice
simulation
results
show
choice
dramatically
affect
accuracy
estimation
substantially
improves
runtime
leqa
logical
qubits
two
summations
add
probability
overall
equation
calculates
expected
surface
fabric
covered
covered
qubit
presence
zone
randomly
placed
multiplied
note
written
two
lines
𝑦𝑦=1
𝑥𝑥=1
equation
derived
nominator
counts
number
ways
𝑃𝑃𝑥𝑥
𝑦𝑦=�min�𝑥𝑥
a−𝑥𝑥+1
�√𝐵𝐵�
𝑎𝑎−�√𝐵𝐵�+1�×
min
�𝑦𝑦
b−𝑦𝑦+1
�√𝐵𝐵�
𝑏𝑏−�√𝐵𝐵�+1��
�a−�√𝐵𝐵�+1��b−�√𝐵𝐵�+1�
average
area
presence
zones
figure
depicts
placing
presence
zone
size
�√𝐵𝐵�×�√𝐵𝐵�
𝑎𝑎×𝑏𝑏
fabric
covers
ulb
located
position
min
functions
used
number
ways
�√𝐵𝐵�×�√𝐵𝐵�
presence
zone
placed
𝑎𝑎×𝑏𝑏
fabric
account
boundary
situations
denominator
counts
0,0
a-x+1
b-y+1
𝑒𝑒𝑐𝑐𝑖𝑖
figure
calculation
interaction
intensity
graph
iig
built
follows
nodes
number
ulbs
may
necessarily
unique
program
execution
average
size
presence
zones
calculated
using
weighted
average
size
presence
zone
estimate
average
area
presence
zones
new
graph
called
graph
logical
qubits
denoted
𝑛𝑛𝑐𝑐
edge
𝑒𝑒𝑐𝑐𝑖𝑖
added
nodes
𝑛𝑛𝑐𝑐
𝑛𝑛𝑖𝑖
two
qubits
interact
weight
edge
denoted
𝑒𝑒𝑐𝑐𝑖𝑖
equal
number
two-qubit
operations
𝑛𝑛𝑐𝑐
𝑛𝑛𝑖𝑖
note
edges
directed
𝑒𝑒𝑐𝑐𝑖𝑖
𝑒𝑒𝑖𝑖𝑐𝑐
refer
edge
clearly
iig
self-loops
since
edges
added
one-qubit
operations
𝑀𝑀𝑐𝑐
defined
number
neighbors
node
𝑛𝑛𝑐𝑐
iig
equal
deg
𝑛𝑛𝑐𝑐
degree
node
𝑛𝑛𝑐𝑐
iig
model
area
presence
zone
associated
𝑛𝑛𝑐𝑐
denoted
𝐵𝐵𝑐𝑐
follows
𝐵𝐵𝑐𝑐=�𝑀𝑀𝑐𝑐+1×�𝑀𝑀𝑐𝑐+1
addition
one
term
𝑀𝑀𝑐𝑐
accounts
qubit
𝑛𝑛𝑐𝑐
𝑀𝑀𝑐𝑐+1
qubits
presence
zone
qubit
𝑛𝑛𝑐𝑐
travels
inside
zone
interacts
𝑀𝑀𝑐𝑐
qubits
visits
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
logical
qubits
𝐵𝐵=∑
�×𝐵𝐵𝑐𝑐
𝑒𝑒𝑐𝑐𝑖𝑖
𝑄𝑄𝑐𝑐=1∑
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
𝑒𝑒𝑐𝑐𝑖𝑖
𝑄𝑄𝑐𝑐=1
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
𝑒𝑒𝑐𝑐𝑖𝑖
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
node
𝑛𝑛𝑐𝑐
iig
increases
weight
term
𝐵𝐵𝑐𝑐
qubit
𝑛𝑛𝑐𝑐
involved
two-qubit
operations
calculate
𝑑𝑑𝑞𝑞
used
equation
following
𝑑𝑑𝑞𝑞=�
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑞𝑞≤𝑁𝑁𝑢𝑢
1+𝑞𝑞
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑜𝑜𝑜𝑜ℎ𝑒𝑒𝑒𝑒𝑤𝑤𝑒𝑒𝑒𝑒𝑒𝑒
𝑁𝑁𝑢𝑢
𝑁𝑁𝑢𝑢
capacity
routing
channels
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
qubits
inhibiting
channel
less
equal
𝑁𝑁𝑢𝑢
case
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
greater
𝑁𝑁𝑢𝑢
channel
called
congested
average
routing
latency
qubit
interacting
another
qubits
average-size
presence
zone
routing
channels
uncongested
channel
considered
uncongested
number
qubits
form
pipeline
passing
hence
delayed
depending
position
pipeline
capture
increase
routing
latency
modeling
routing
channels
qubits
pass
channel
minimum
delay
i.e
sums
weights
adjacent
edges
equation
used
q-nc
queue
shown
equation
figure
m/m/1/∞
queue
model
routing
channels
queue
calculated
equation
exploiting
m/m/1/∞
queue
figure
shows
pictorial
view
model
green
blocks
show
logical
qubits
currently
using
channel
red
blocks
show
qubits
waiting
get
access
channel
assume
since
inter-arrival
time
qubits
independent
memory-less
hence
poisson
distribution
model
well
service
rate
assumption
made
simplify
calculations
experimental
results
show
simple
model
performs
well
practice
knowing
average
routing
latency
qubit
arrival
rate
qubits
poisson
distribution
parameter
assumed
exponential
distribution
parameter
service
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
calculated
𝑁𝑁𝑢𝑢/𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
moreover
average
length
queue
𝑙𝑙𝑞𝑞𝑢𝑢𝑚𝑚𝑢𝑢𝑚𝑚
𝑐𝑐𝑎𝑎𝑢𝑢
number
qubits
based
queuing
theory
𝑙𝑙𝑞𝑞𝑢𝑢𝑚𝑚𝑢𝑢𝑚𝑚
𝑐𝑐𝑎𝑎𝑢𝑢
i.e.
average
length
equation
knowing
value
𝑙𝑙𝑞𝑞𝑢𝑢𝑚𝑚𝑢𝑢𝑚𝑚
𝑐𝑐𝑎𝑎𝑢𝑢
calculated
𝑐𝑐𝑎𝑎𝑢𝑢
𝜆𝜆𝜇𝜇−𝜆𝜆=
𝜆𝜆𝑁𝑁𝑢𝑢
𝑙𝑙𝑞𝑞𝑢𝑢𝑚𝑚𝑢𝑢𝑚𝑚
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢−𝜆𝜆
𝑞𝑞𝑁𝑁𝑢𝑢
𝜆𝜆𝑁𝑁𝑢𝑢
𝑞𝑞=
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢−𝜆𝜆→𝜆𝜆=
1+𝑞𝑞
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
values
arrival
rate
average
queue
length
𝑙𝑙𝑞𝑞𝑢𝑢𝑚𝑚𝑢𝑢𝑚𝑚
𝑐𝑐𝑎𝑎𝑢𝑢
known
values
little
formula
gives
average
waiting
service
time
queue
𝑊𝑊𝑐𝑐𝑎𝑎𝑢𝑢
1+𝑞𝑞
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢×𝑊𝑊𝑐𝑐𝑎𝑎𝑢𝑢→𝑊𝑊𝑐𝑐𝑎𝑎𝑢𝑢=
1+𝑞𝑞
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑞𝑞𝑁𝑁𝑢𝑢
𝑞𝑞=
𝑁𝑁𝑢𝑢
expression
used
equation
estimation
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
3.2
estimating
𝒅𝒅𝒖𝒖𝒖𝒖𝒖𝒖𝒖𝒖𝒖𝒖𝒖𝒖
estimate
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
new
parameter
called
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
defined
variable
represents
average
routing
latency
qubit
𝑛𝑛𝑐𝑐
congested
weighted
average
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
values
similar
equation
gives
estimation
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢=∑
𝑒𝑒𝑐𝑐𝑖𝑖
�×𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑄𝑄𝑐𝑐=1
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
𝑒𝑒𝑐𝑐𝑖𝑖
𝑄𝑄𝑐𝑐=1
∀𝑢𝑢𝑗𝑗∈adj
𝑢𝑢𝑖𝑖
one
way
estimate
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
randomly
place
𝑀𝑀𝑐𝑐+1
qubits
presence
zone
qubit
𝑛𝑛𝑐𝑐
calculate
expected
length
shortest
hamiltonian
path
𝑙𝑙ℎ𝑐𝑐𝑚𝑚
goes
𝑀𝑀𝑐𝑐
locations
necessarily
unique
interact
𝑀𝑀𝑐𝑐
unique
𝑙𝑙ℎ𝑐𝑐𝑚𝑚
infeasible
quick
estimation
method
upper
bound
problem
tsp
presented
reference
assumes
𝑀𝑀𝑐𝑐+
points
randomly
distributed
1×1
square
equation
qubits
qubits
placed
anywhere
presence
zone
even
placed
location
captures
fact
two
qubit
travel
ulb
interaction
reason
selecting
hamiltonian
path
according
assumption
presence
zone
one
qubit
interacts
others
travel
qubits
interactions
among
qubits
considered
presence
zone
calculation
shortcoming
aforementioned
approach
problem
calculating
expected
shortest
hamiltonian
path
np-hard
hence
exact
calculation
lower
bound
expected
path
length
traveling
salesman
average-size
presence
zone
routing
channels
trivial
task
explained
next
section
presents
lower
bound
equation
shows
upper
bound
expected
path
length
tsp
lower
bound
0.708�𝑀𝑀𝑐𝑐+1+0.551
upper
bound
0.718�𝑀𝑀𝑐𝑐+1+0.731
follows
one
edge
less
tour
equation
shows
taking
average
upper
bound
lower
bound
gives
good
estimation
expected
path
length
tsp
problem
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
𝑐𝑐=𝐸𝐸�𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑐𝑐�
𝑣𝑣×𝑀𝑀𝑐𝑐
square
length
�𝐵𝐵𝑐𝑐
times
greater
result
multiplied
�𝐵𝐵𝑐𝑐
moreover
since
tsp
solution
tour
result
also
multiplied
𝑀𝑀𝑐𝑐−1
/𝑀𝑀𝑐𝑐
give
hamiltonian
path
length
resultant
estimation
𝐸𝐸�𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑐𝑐�
𝐸𝐸�𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑐𝑐�≈�𝐵𝐵𝑐𝑐×�0.713�𝑀𝑀𝑐𝑐+1+0.641�×𝑀𝑀𝑐𝑐−1𝑀𝑀𝑐𝑐
knowing
value
𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
calculated
parameter
depending
physical
characteristics
different
quantum
mappers
𝑀𝑀𝑐𝑐
presented
denominator
fabric
technology
mostly
speed
moving
logical
qubit
channels
parameter
also
used
tuning
leqa
give
average
routing
latency
operation
3.3
leqa
algorithm
performance
algorithm
shows
implementation
leqa
based
presented
procedural
method
note
qodg
input
algorithm
one
easily
construct
synthesized
quantum
circuit
shown
figure
size
fabric
another
input
value
changed
find
optimal
size
fabric
results
minimum
delay
inputs
physical
parameters
runtime
complexity
algorithm
may
summarized
follows
𝒪𝒪��𝑉𝑉qodg�+�𝐸𝐸qodg�+𝑄𝑄.𝐴𝐴.log𝑄𝑄�
details
analytical
analysis
derive
time
complexity
presented
supplemental
material
section
experimental
results
4.1
simulation
setup
leqa
implemented
java
baseline
quantum
scheduling
placement
routing
tool
called
qspr
used
qspr
minimally
modified
work
tile-based
architecture
figure
table
lists
physical
parameters
tqa
used
simulations
qspr
also
used
calculate
delay
performing
operations
ion-trap
circuit
fabric
left
table
7,1,3
steane
code
used
encoding
error
correction
scheme
hence
delays
gates
𝑑𝑑𝐶𝐶
𝑑𝑑𝐶𝐶†
non-transversal
coding
higher
others
numbers
adjusted
based
underlying
technologies
limit
functionality
leqa
specific
quantum
realization
technique
right
table
specifications
tqa
presented
table
list
physical
parameters
tqa
value
parameter
parameter
𝑑𝑑𝐻𝐻
𝑑𝑑𝐶𝐶
𝑑𝑑𝐶𝐶†
𝑑𝑑𝑋𝑋
𝑑𝑑𝑦𝑦
𝑑𝑑𝑧𝑧
𝑑𝑑𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
value
5440µs
10940µs
5240µs
4930µs
𝑁𝑁𝑢𝑢
a=𝑎𝑎×𝑏𝑏
tmove
0.001
3600=60×60
100µs
benchmarks
taken
reference
synthesized
using
fault-tolerant
gate
library
simple
method
presented
reference
used
decompose
n-input
toffoli
n-input
fredking
gates
several
3-input
toffoli
fredking
gates
note
method
adds
ancillary
qubits
circuit
also
ancillary
sharing
performed
among
decomposed
gates
resultant
3-input
fredkin
gates
replaced
three
3-input
toffoli
gates
finally
3-input
end
end
operations
types
algorithm
leqa
end
end
inputs
qodg
quantum
operation
dependency
graph
width
length
fabric
𝑑𝑑𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑑𝑑𝑢𝑢
delays
logical
gates
𝑁𝑁𝑢𝑢
capacity
routing
channels
speed
logical
qubit
routing
channels
number
logical
qubits
outputs
estimated
latency
input
program
make
iig
given
qodg
let
𝑀𝑀𝑐𝑐=deg
𝑛𝑛𝑐𝑐
every
𝑛𝑛𝑐𝑐
calculate
𝐵𝐵𝑐𝑐
calculate
𝑒𝑒=1
calculate
𝐸𝐸�𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑐𝑐�
using
calculate
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
using
calculate
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
x=1
y=1
calculate
𝑃𝑃𝑥𝑥
using
𝑞𝑞=1
calculate
𝑑𝑑𝑞𝑞
calculate
𝑆𝑆𝑞𝑞
calculate
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑐𝑐𝑎𝑎𝑢𝑢
approximation
given
update
𝑄𝑄𝑂𝑂𝐷𝐷𝑄𝑄
based
value
𝐿𝐿𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
value
𝐿𝐿𝑢𝑢𝑐𝑐𝑎𝑎𝑢𝑢
calculate
𝑁𝑁𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
calculate
using
estimation
given
𝑐𝑐𝑎𝑎𝑢𝑢
empirical
𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
𝑁𝑁𝑢𝑢𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
return
toffoli
gates
decomposed
set
fault-tolerant
gates
using
method
presented
reference
shown
figure
leqa
qspr
share
parsers
parsing
inputs
tqa
specification
physical
parameters
intel
pentium
dual-core
e5500
cpu
clocked
2.80ghz
4gb
ram
running
windows
java
development
kit
jdk
used
simulations
4.2
simulation
results
table
shows
comparison
actual
delay
computed
qspr
estimated
delay
calculated
leqa
seen
average
estimation
error
equal
2.11
maximum
error
table
lists
information
benchmarks
well
i.e
qubit
count
operation
count
benchmarks
sorted
based
operation
count
also
table
compares
runtime
leqa
qspr
evidently
operation
count
grows
leqa
performs
better
largest
benchmark
netlist
file
size
12mb
leqa
performs
two
orders
magnitude
faster
qspr
trend
shows
size
netlist
grows
leqa
beats
qspr
terms
speed
still
gives
accurate
results
interesting
case
consider
last
two
benchmarks
i.e
gf2^128mult
gf2^256mult
operation
count
latter
benchmark
almost
times
former
one
comparing
runtime
leqa
qspr
two
benchmarks
seen
runtime
leqa
increased
factor
runtime
qspr
increased
factor
4.5.
depicts
scalability
leqa
compared
qspr
leqa
achieves
114x
speedup
qspr
largest
benchmark
i.e
gf2^256mult
factor
larger
benchmarks
precisely
qspr
runtime
scales
super
linearly
operation
count
circuit
degree
1.5
whereas
leqa
runtime
depends
linearly
count
see
equation
reference
reports
integer
1.35×1015
physical
shor
algorithm
1024-bit
operations
using
two-level
7,1,3
steane
code
logical
operation
results
105
physical
operations
algorithm
increases
almost
1.35×1010
logical
operations
using
extrapolation
qspr
would
compute
latency
years
whereas
leqa
needs
16.5
hours
moreover
multiple
qspr
runs
needed
select
minimum
overhead
qecc
design
table
comparison
actual
latency
computed
actual
delay
qspr
estimated
latency
calculated
leqa
benchmark
absolute
error
3.10
1.45
2.76
2.76
0.46
0.25
0.11
0.51
2.66
3.10
1.44
3.38
1.64
0.72
0.57
8.29
1.24
3.55
table
information
benchmark
circuits
comparison
8bitadder
gf2^16mult
hwb15ps
hwb16ps
gf2^18mult
gf2^19mult
gf2^20mult
ham15
hwb20ps
hwb50ps
gf2^50mult
mod1048576adder
gf2^64mult
hwb100ps
gf2^100mult
hwb200ps
gf2^128mult
gf2^256mult
estimated
delay
sec
1.667e+00
4.524e+00
1.993e+01
1.903e+01
5.109e+00
5.407e+00
5.660e+00
2.530e+01
3.106e+01
1.274e+02
1.495e+01
1.958e+02
1.935e+01
3.402e+02
2.998e+01
8.839e+02
3.838e+01
7.654e+01
sec
1.617e+00
4.460e+00
1.940e+01
1.852e+01
5.085e+00
5.393e+00
5.654e+00
2.518e+01
3.026e+01
1.236e+02
1.474e+01
2.027e+02
1.904e+01
3.427e+02
3.015e+01
9.638e+02
3.886e+01
7.936e+01
sec
sec
count
speedup
operation
qspr
runtime
runtime
qspr
leqa
leqa
runtime
8.2
10.3
10.7
11.5
12.6
14.2
17.1
16.6
13.9
26.3
42.5
52.8
63.8
46.4
76.0
72.9
78.3
114.7
0.9
3.0
2.7
2.9
3.5
3.7
5.1
4.3
3.8
11.8
16.9
20.2
29.4
26.7
65.2
66.7
106.0
524.8
0.115
0.289
0.256
0.250
0.276
0.259
0.301
0.257
0.272
0.450
0.398
0.382
0.461
0.575
0.859
0.915
1.381
4.576
822
3,885
3,885
3,811
4,911
5,469
6,019
5,308
6,395
25,370
37,647
37,070
61,629
67,735
150,297
175,490
246,141
983,805
benchmark
qubit
count
8bitadder
gf2^16mult
hwb15ps
hwb16ps
gf2^18mult
gf2^19mult
gf2^20mult
146
ham15
hwb20ps
370
hwb50ps
150
gf2^50mult
mod1048576adder
1,180
192
gf2^64mult
1,106
hwb100ps
300
gf2^100mult
hwb200ps
3,145
384
gf2^128mult
gf2^256mult
768
conclusion
paper
presented
leqa—a
fast
latency
estimation
tool
evaluating
latency
quantum
algorithm
mapped
tiled
quantum
architecture
uses
procedural
method
calculate
latency
algorithm
based
computing
neighborhood
population
counts
qubits
simulation
results
showed
mid-size
circuits
leqa
two
orders
magnitude
faster
modern
quantum
mapper
performs
detailed
scheduling
placement
routing
quantum
instructions
qubits
quantum
operation
dependency
graph
quantum
fabric
speedup
expected
increase
superlinearly
function
circuit
size
operation
count
moreover
leqa
could
produce
quick
estimates
circuit
latency
sufficient
accuracy
i.e.
average
2.11
error
acknowledgement
research
supported
intelligence
advanced
research
projects
activity
iarpa
via
department
interior
national
business
center
contract
number
d11pc20165
u.s.
government
authorized
reproduce
distribute
reprints
governmental
purposes
notwithstanding
copyright
annotation
thereon
views
conclusions
contained
herein
authors
interpreted
necessarily
representing
official
policies
endorsements
either
expressed
implied
iarpa
doi/nbc
u.s.
government
references
cascaval
padua
estimating
cache
misses
locality
using
stack
distances
proceedings
17th
international
conference
supercomputing
new
york
usa
2003
150–159
bammi
harcourt
kruitzer
lavagno
lazarescu
software
performance
estimation
strategies
system-level
design
international
workshop
tool
hardware/software
codesign
2000
–86
proceedings
thaker
metodi
chong
realizable
distributed
ion-trap
quantum
computer
proceedings
13th
international
conference
high
performance
computing
bangalore
india
2006
vol
4297
111–122
nielsen
chuang
quantum
computation
quantum
8th
information
cambridge
university
press
2010
svore
aho
cross
chuang
markov
layered
software
architecture
quantum
computing
design
tools
computer
vol
74–83
2006
jones
van
meter
fowler
mcmahon
kim
quantum
ladd
yamamoto
layered
architecture
computing
phys
rev
vol
031007
jul
2012
saeedi
markov
synthesis
optimization
reversible
circuits
survey
arxiv:1110.2574
oct.
2011
shende
prasad
markov
hayes
synthesis
reversible
logic
circuits
ieee
transactions
computer-aided
design
integrated
circuits
systems
vol
710
722
jun
2003
metodi
thaker
cross
quantum
logic
array
microarchitecture
scalable
quantum
data
movement
computation
proceedings
38th
international
symposium
microarchitecture
washington
usa
2005
305–318
whitney
isailovic
patel
kubiatowicz
fault
tolerant
area
efficient
architecture
shor
factoring
algorithm
proceedings
36th
international
symposium
computer
architecture
new
york
usa
2009
383–394
cirac
ekert
macchiavello
optimal
purification
single
qubits
phys
rev
lett.
vol
4344–4347
may
1999
reversible
benchmarks.
online
available
http
//webhome.cs.uvic.ca/~dmaslov/
accessed
26-nov-2012
thaker
metodi
cross
chuang
chong
quantum
memory
hierarchies
efficient
designs
match
available
33rd
parallelism
international
symposium
computer
architecture
vol
378–390
may
2006.
quantum
computing
proceedings
kreger-stickles
oskin
microcoded
architectures
ion-tap
35th
international
quantum
computers
symposium
computer
architecture
washington
usa
2008
165–176
proceedings
ladd
jelezko
laflamme
nakamura
monroe
brien
quantum
computers
nature
vol
464
7285
45–53
mar
2010
stroobandt
priori
wire
length
estimates
digital
design
1st
springer
2001
2009
ross
introduction
probability
models
10th
academic
press
johnson
mcgeoch
rothberg
asymptotic
experimental
analysis
held-karp
traveling
salesman
bound
proceedings
7th
acm-siam
symposium
discrete
algorithms
philadelphia
usa
1996
341–350
travelling
salesman
problem
wikipedia
free
encyclopedia
25-
nov-2012
dousti
pedram
minimizing
latency
quantum
circuits
mapping
ion-trap
circuit
fabric
proceedings
design
automation
test
europe
2012
840–843
shende
markov
cnot-cost
toffoli
gates
quantum
information
computation
vol
461–486
may
2009.
line
calculating
weights
need
sum
edges
line
set
lines
algorithm
calculated
follows
line
making
graph
iig
needs
traversal
qodg
supplemental
material
performance
analysis
leqa
number
nodes
qodg
equal
number
operations
designated
�𝑉𝑉qodg�
number
edges
graph
also
circuit
plus
two
dummy
start
end
nodes
shown
�𝐸𝐸qodg�
knowing
parameters
runtime
complexity
takes
�𝑉𝑉qodg�+�𝐸𝐸qodg�
line
calculation
𝑀𝑀𝑐𝑐
𝐵𝐵𝑐𝑐
done
iig
�𝑉𝑉qodg�
edges
calculating
summation
weighted
𝐵𝐵𝑐𝑐s
takes
overall
line
takes
�𝑉𝑉qodg�+𝑄𝑄
done
lines
4-7
calculation
𝐸𝐸�𝑙𝑙ℎ𝑐𝑐𝑚𝑚
𝑐𝑐�
𝑑𝑑𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢𝑢
done
constant
time
hence
for-loop
takes
complete
line
line
takes
�𝑉𝑉qodg�+𝑄𝑄
one
reuse
calculated
weights
line
reduce
calculation
time
lines
9-13
nested
for-loops
iterate
=𝑎𝑎×𝑏𝑏
times
total
iteration
value
𝑃𝑃𝑐𝑐𝑏𝑏
calculated
constant
time
takes
time
complete
lines
14-17
for-loop
iterates
times
iteration
line
takes
whereas
line
takes
𝐴𝐴.log𝑄𝑄
result
double
summation
area
log𝑄𝑄
time
needed
𝑞𝑞≤𝑄𝑄
calculated
constant
time
using
following
recursive
formula
calculate
�𝑃𝑃𝑥𝑥
𝑦𝑦�𝑞𝑞
�1−𝑃𝑃𝑥𝑥
𝑦𝑦�𝑄𝑄−𝑞𝑞
value
�𝑄𝑄𝑞𝑞�
𝑄𝑄,0
=𝑓𝑓
𝑞𝑞−1
×𝑄𝑄−𝑞𝑞+1
overall
lines
take
𝑄𝑄.𝐴𝐴.log𝑄𝑄
completion
explained
paper
first
values
𝑆𝑆𝑞𝑞
calculated
practice
i.e
𝑞𝑞=1
20.
hence
action
leqa
performs
much
faster
𝑄𝑄.𝐴𝐴.log𝑄𝑄
line
calculation
takes
line
updating
delay
instructions
takes
�𝑉𝑉qodg�
�𝑉𝑉qodg�+�𝐸𝐸qodg�
chapter
reference
explains
algorithm
time
complexity
deriving
values
𝑁𝑁𝑢𝑢𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
𝑁𝑁𝐶𝐶𝐶𝐶𝐶𝐶𝐶𝐶
𝑢𝑢𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑐𝑢𝑢𝑐𝑐𝑐𝑐
done
traversing
critical
path
length
�𝑉𝑉qodg�
worst
case
line
calculation
done
constant
time
𝒪𝒪��𝑉𝑉qodg�+�𝐸𝐸qodg�+𝑄𝑄.𝐴𝐴.log𝑄𝑄�
overall
runtime
algorithm
may
summarized
follows
calculation
critical
path
directed
acyclic
graph
dag
takes
reference
cormen
leiserson
rivest
stein
introduction
algorithms
3rd
mit
press
2009
