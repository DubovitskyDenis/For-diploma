generalized
parity
proofs
kochen-specker
theorem
petr
lisonˇek1
robert
raussendorf2
vijaykumar
singh1,2
1department
mathematics
simon
fraser
university
burnaby
2department
physics
astronomy
university
british
columbia
vancouver
v6t
1z1
canada
v5a
1s6
canada
e-mail
plisonek
sfu.ca
raussen
phas.ubc.ca
vijay.k.1
gmail.com
june
2018
abstract
discuss
two
approaches
producing
generalized
parity
proofs
kochen-specker
theorem
proofs
use
contexts
observ-
ables
whose
product
call
constraints
ﬁrst
approach
one
starts
ﬁxed
set
constraints
methods
linear
algebra
used
produce
subsets
generalized
parity
proofs
coding
theory
methods
used
enumeration
proofs
size
second
approach
one
starts
combinatorial
structure
set
constraints
one
looks
ways
suitably
populate
structure
observables
well
able
show
many
combinatorial
structures
produce
parity
proofs
introduction
1935
einstein
podolsky
rosen
asked
question
whether
quan-
tum
mechanics
considered
complete
theory
physical
phenomena
ended
hinting
possibility
classical
descriptions
quan-
tum
mechanics
randomness
quantum
measurement
mod-
elled
hidden
probabilistic
parameter
hidden
variable
models
hvms
turned
viable
demonstrated
bohmian
mechanics
however
seemingly
innocuous
additional
assumptions
made
hvms
longer
reproduce
predictions
quantum
mechan-
ics
hidden
variable
model
stark
contrast
quantum
mechanics
measurement
outcomes
exist
prior
measurement
merely
revealed
additional
assumption
locality
bell
inequalities
sepa-
rate
quantum
mechanics
hvm
descriptions
additional
as-
sumption
non-contextuality
achieved
kochen-specker
theorem
abbreviated
theorem
henceforth
non-contextuality
means
following
let
observable
measured
jointly
one
compatible
observables
incompatible
quantum
mechanics
two
operators
said
compatible
commute
hvm
non-contextual
pre-existing
measurement
outcome
independent
whether
measured
jointly
seems
reasonable
requirement
since
may
measured
even
decision
made
whether
measure
jointly
words
assigned
measurement
outcomes
nevertheless
assumption
consequence
theorem
1.1
kochen
specker
hilbert
spaces
dimension
quantum
mechanics
described
non-contextual
hidden-
variable
model
quantum
mechanics
contextuality
i.e.
absence
non-
contextuality
feature
distinguishes
classical
physics
quantum
information
theory
contextuality
also
resource
exam-
ple
consider
quantum
computer
made
odd-dimensional
qudits
setting
fault-tolerant
quantum
computation
distillation
so-called
magic
states
requires
contextuality
order
universal
furthermore
proofs
theorem
translated
cryp-
tographic
protocols
measurement-based
quantum
computations
make
use
correspondences
desirable
generate
classify
enumerate
large
numbers
proofs
millions
proofs
identiﬁed
example
symmetric
structures
living
low-dimensional
hilbert
spaces
600-cell
quantum
mechanics
observables
represented
hermitian
oper-
ators
throughout
paper
consider
binary
observables
observables
eigenvalues
context
set
pairwise
com-
muting
observables
constraint
mean
set
pairwise
commuting
observables
whose
product
paper
parity
proof
kochen-specker
theorem
abbreviated
parity
proof
simply
proof
mean
set
constraints
observable
occurs
even
number
constraints
number
constraints
whose
product
odd
explore
internal
structure
proofs
two
dif-
ferent
viewpoints
observable-based
parity
proofs
occurring
literature
use
pauli
observables
e.g.
methods
discussed
paper
subject
restriction
section
show
given
set
constraints
set
parity
proofs
constructed
constraints
one-to-one
correspon-
dence
coset
certain
binary
linear
code
particular
always
proofs
discuss
detail
case
constraints
derived
set
intersecting
orthogonal
bases
case
proofs
generalize
previous
parity
proofs
see
e.g.
many
references
since
method
de-
riving
constraints
one
orthogonal
basis
general
observe
give
illustration
example
enumeration
parity
proofs
size
possible
indirectly
application
duality
vector
spaces
known
coding
theory
present
method
ﬁnding
parity
proofs
small
cardinality
i.e.
parity
proofs
consisting
small
number
constraints
section
consider
parity
proofs
obtained
given
incidence
structure
incidence
structure
let
points
vertices
correspond
observables
blocks
constraints
incidence
structure
describes
intersection
pattern
putative
con-
straints
proof
ask
whether
exists
assignment
observables
points
structure
turns
proof
describe
algorithm
helps
answering
question
given
incidence
structure
consider
class
simplest
possible
incidence
structures
proofs
arise
namely
structures
point
belongs
exactly
two
blocks
block
contains
exactly
three
points
decide
existence
non-existence
proofs
containing
observables
constraints
non-
existence
results
apply
observables
dimension
necessarily
pauli
observables
1.1
notations
work
inner
product
i=1
xiyi
denotes
complex
conjugate
elements
considered
row
vectors
transpose
matrix
denoted
conjugate
transpose
matrix
denoted
symbols
denote
zero
vector
all-one
vector
appropriate
dimension
let
set
subset
characteristic
vector
denoted
deﬁned
otherwise
ﬁnite
set
let
|s|
denote
number
elements
graph
pair
set
vertices
set
edges
unordered
pairs
vertices
say
endpoints
edge
called
adjacent
degree
vertex
number
edges
belongs
number
vertices
adjacent
clique
set
two
distinct
vertices
adjacent
two
graphs
isomorphic
exists
bijection
adjacent
adjacent
graph
connected
exists
sequence
vertices
wi+1
adjacent
positive
integer
complete
graph
deﬁned
graph
vertices
two
distinct
vertices
adjacent
let
ﬁeld
matrix
-vector
space
axt
called
kernel
denoted
ker
number
non-zero
coordinates
called
ham-
ming
weight
denoted
parity
proofs
given
set
constraints
proofs
kochen-specker
theorem
considerably
simpli-
ﬁed
since
ﬁrst
appeared
come
various
kinds
colouring
proofs
based
interconnected
orthogonal
bases
proofs
concern
paper
based
intercon-
nected
contexts
proofs
ﬁrst
given
mermin
proofs
phrased
framework
category
theory
also
exist
introduce
notion
parity
proof
kochen-specker
theorem
ﬁrst
review
example
give
general
deﬁnition
mermin
proof
invokes
pauli
observables
contexts
cid:18
cid:19
cid:18
cid:19
cid:18
cid:19
cid:18
cid:19
contexts
represented
three
rows
three
columns
note
observables
rows
columns
except
third
column
multiply
identity
whereas
observables
third
column
multiply
example
impossible
assign
pre-existing
values
observables
seen
follows
assume
assignment
ex-
ists
first
pre-assigned
measurement
outcomes
must
eigenvalues
observables
question
quantum
mechanics
observables
an+1
belonging
con-
text
satisfy
a1a2
an+1
measurement
outcomes
satisfy
an+1
see
section
hence
six
constraints
among
observables
translate
corre-
sponding
constraints
pre-assigned
values
example
implies
let
work
product
values
observables
given
context
contexts
constraining
relations
give
products
within
six
contexts
ﬁve
times
product
con-
texts
thus
however
may
work
product
diﬀerently
observe
every
value
appears
exactly
two
contexts
since
observables
product
contexts
must
therefore
contradiction
assignment
values
observables
exists
2.1
structure
parity
proofs
recall
section
context
set
pairwise
commuting
ob-
servables
context
denote
qo∈c
product
observables
recall
constraint
deﬁned
context
following
deﬁnition
generalizes
mermin
approach
proving
theorem
outlined
example
given
ap-
proach
subsequently
applied
also
papers
e.g.
deﬁnition
2.1.
parity
proof
kochen-specker
theorem
parity
proof
set
constraints
observable
occurs
even
number
constraints
number
constraints
odd
size
parity
proof
deﬁned
cardinality
set
number
constraints
authors
use
term
parity
proof
narrow
sense
return
issue
section
2.3
see
parity
proof
introduced
deﬁnition
2.1
actu-
ally
proves
theorem
one
generalizes
idea
mermin
original
argument
reviewed
know
constraint
sign
occurs
equalities
let
compute
product
measurement
outcomes
satisfyqo∈c
whereqo∈c
=qcqo∈c
constraints
occurring
parity
proof
two
diﬀerent
ways
done
mermin
example
one
calculations
shows
whereas
one
yields
thus
proving
kochen-specker
theorem
noticed
repeatedly
number
certain
parity
proofs
associated
given
set
orthogonal
bases
power
apparently
never
explained
see
example
section
4.1
next
theorem
advance
observation
general
setting
prove
theorem
2.2.
let
arbitrary
ﬁnite
set
constraints
number
parity
proofs
kochen-specker
theorem
subsets
non-negative
integer
proof
let
let
set
observables
occur
least
two
constraints
let
matrix
deﬁned
follows
set
deﬁne
vector
letting
let
matrix
obtained
appending
last
row
subset
associate
parity
proof
kochen-
characteristic
vector
χc′
specker
theorem
′χt
set
vectors
χc′
either
empty
coset
ker
latter
case
cardinality
coset
equals
cardinality
ker
dimension
ker
remark
2.3.
basis
ker
determined
eﬃcient
exhaustive
listing
parity
proofs
possible
example
gray
code
ordering
also
uniform
sampling
proofs
becomes
easy
2.2
parity
proofs
associated
set
orthogonal
bases
application
theorem
2.2
need
set
constraints
one
possible
way
constructing
set
constraints
follows
one
starts
set
orthogonal
bases
let
assume
moment
set
orthonormal
bases
although
see
shortly
restriction
removed
easily
basis
say
one
constructs
observable
xi=1
subsection
analyze
observables
combined
produce
constraints
subsequently
analyze
parity
proofs
constructed
constraints
note
suﬃcient
start
set
orthogonal
bases
compute
observables
xi=1
hbi
bii
exact
computations
computer
algebra
systems
maple
magma
formula
superior
avoids
unnecessary
practice
introduction
square
roots
needed
normalize
one
precompute
matrices
hbi
bii
found
signed
sums
note
hence
commute
also
eigenvalues
accordance
deﬁnition
observable
−ob
consider
subset
qλ∈t
pλ∈t
hence
qλ∈t
pλ∈t
qλ∈t
pλ∈t
thus
ﬁxed
set
constraint
pλ∈t
purpose
constructing
constraints
one
restrict
attention
set
vectors
restrict
subsets
pλ∈t
justiﬁed
follows
constraint
form
unrestricted
vectors
transformed
constraint
form
vectors
restricted
set
adding
ﬂips
sign
corresponding
observables
hence
transformation
applied
constraint
produces
constraint
deﬁnition
2.1
parity
proof
observable
occurs
even
number
times
thus
odd
number
constraints
product
sign
ﬂip
odd
number
constraints
product
sign
ﬂip
deﬁnition
2.1
observable
occurring
parity
proof
must
occur
least
two
constraints
thus
restrict
attention
observables
whose
vectors
belong
set
∃b′
∃λ′
±ob′
let
|lb|
without
loss
generality
assume
means
point
delete
computation
also
delete
constraints
associated
precisely
form
pλ∈t
thus
deﬁne
xλ∈t
set
vector
space
seen
rep-
resenting
element
characteristic
vector
ordering
labeling
set
λnb
representation
subspace
znb
computer
implementation
algorithm
one
identiﬁes
equal
sign
across
bases
class
observables
henceforth
treated
one
single
observable
one
construct
parity
proofs
taking
b∈b
theorem
2.2.
proof
theorem
2.2
remark
2.3
allow
exhaustively
list
and/or
uniformly
sample
set
parity
proofs
associated
due
fact
experimental
realizations
proofs
presently
limited
proofs
small
size
interesting
speciﬁcally
address
ﬁnding
parity
proofs
constraints
upon
rereading
proof
theorem
2.2
equivalent
ﬁnding
vectors
small
hamming
weight
satisfying
′xt
vectors
found
using
meet-in-the-middle
idea
one
looks
vectors
hamming
weight
suﬃcient
compute
vectors
hamming
weight
⌈w/2⌉
pairs
′yt
store
table
table
in-
dexed
second
components
pairs
upon
setting
y1+y2
weight
⌈w/2⌉
condition
′xt
becomes
equivalent
vector
hamming
weight
⌈w/2⌉
one
stores
pair
′yt
ta-
ble
time
one
queries
table
existence
pair
pairs
form
′yt
pair
is/are
found
table
deﬁnes
parity
proof
cardinality
one
interested
ﬁnding
small
parity
proofs
rather
one
seeks
access
parity
proofs
derived
set
or-
thogonal
bases
method
outlined
section
modiﬁed
following
way
let
ﬁxed
instead
creating
one
constraint
thus
one
column
matrix
non-empty
element
columns
created
correspond
basis
often
makes
matrix
much
smaller
however
hamming
weight
solution
′xt
longer
corresponds
size
proof
represents
2.3
parity
proofs
based
rays
let
set
orthogonal
bases
let
v†v
note
certain
vector
weight
way
associate
vector
weight
1-dimensional
subspace
spanned
called
ray
papers
concept
parity
proof
used
special
type
proof
rays
primary
objects
connect
deﬁnition
2.1
introduce
constraint
note
qo∈cb
making
connection
see
special
type
parity
proof
call
ray
parity
proof
paper
obtained
set
orthogonal
bases
satisﬁes
following
two
conditions
cardinality
odd
ray
belongs
even
number
bases
immediate
corollary
theorem
2.2
see
number
ray
parity
proofs
arising
non-negative
integer
common
way
constructing
ray
parity
proofs
follows
one
starts
set
rays
say
precisely
set
vectors
spanning
rays
one
ﬁnds
set
orthogonal
bases
subsets
let
call
set
computationally
done
follows
form
orthogonality
graph
whose
vertices
elements
two
vertices
adjacent
corresponding
rays
orthogonal
orthogonal
basis
subset
corresponds
clique
size
reduces
problem
constructing
set
ﬁnding
cliques
size
handled
example
eﬃcient
clique
ﬁnder
available
magma
set
obtained
ray
parity
proofs
constructed
using
theorem
2.2
observables
take
possible
contexts
take
deﬁned
remark
2.4.
since
product
constraint
deﬁned
equals
ﬁnding
ray
parity
proofs
one
simplify
proof
theorem
2.2
considering
matrix
considering
odd
weight
vectors
ker
2.4
duality
weight
distributions
let
xyt
denote
usual
inner
product
let
denote
dual
deﬁned
subspace
subspace
dimension
dim
s⊥⊥
subspace
let
denote
number
vectors
weight
contained
let
denote
number
vectors
weight
contained
sequences
called
weight
distributions
respectively
famous
macwilliams
theorem
coding
theory
see
example
chapter
theorem
gives
compact
easy
evaluate
formula
computing
sequence
sequence
known
vice
versa
course
moreover
generalized
version
macwilliams
theorem
allows
one
compute
weight
distribution
coset
terms
weight
distributions
codes
hai⊥
vector
hai
subspace
spanned
use
result
letting
ker
thus
possible
count
parity
proofs
size
without
constructing
way
may
much
faster
exhaustively
listing
ker
running
meet-in-the-middle
computation
described
section
2.2.
approach
attractive
cases
dimension
ker
smaller
dimension
ker
2.5
examples
illustrate
results
sections
2.1
2.4
two
examples
use
computer
algebra
system
magma
computations
timings
given
obtained
using
magma
2.19
running
intel
core
cpu
2.67
ghz
example
2.5.
parity
proofs
600-cell
notation
section
2.3
let
set
rays
deﬁned
vertices
600-cell
known
orthogonal
bases
subsets
use
magma
ﬁnd
orthogonal
bases
theorem
2.2
remark
2.4
ﬁnd
precisely
233
ray
parity
proofs
kochen-specker
theorem
found
600-cell
another
computation
found
parity
proof
arising
600-cell
methods
section
2.2
ray
parity
proof
using
yield
additional
parity
proofs
beyond
listed
two
computations
take
seconds
example
2.6.
parity
proofs
60–105
system
rays
system
introduced
joint
eigenvectors
sets
commuting
pauli
observables
two
qubits
rays
form
105
orthogonal
bases
simplicity
denote
ker
previous
example
takes
fraction
second
ﬁnd
105
bases
ﬁnd
dimension
example
see
vectors
odd
weight
basis
conclude
precisely
264
ray
parity
proofs
kochen-specker
theorem
found
60–105
system
example
allows
illustrate
application
material
sec-
tion
2.4.
listing
264
ray
parity
proofs
would
perhaps
take
hundreds
years
cpu
time
still
compute
distribution
according
number
bases
i.e.
according
number
constraints
involve
hours
follows
example
dim
105
listing
vectors
feasible
takes
hours
allows
compute
weight
dis-
tribution
compute
weight
distribution
using
macwilliams
theorem
method
fact
built
weightdistribution
function
magma
show
output
appendix
conclude
60–105
system
contains
160
ray
parity
proofs
involving
bases
constraints
18240
ray
parity
proofs
involving
bases
constraints
computation
takes
less
hours
cpu
time
magma
another
calculation
determine
2439
parity
proofs
obtained
methods
section
2.2
60–105
system
order
ﬁnd
distribution
proofs
size
number
constraints
one
could
apply
generalized
macwilliams
theorem
second
part
section
2.4
would
amount
computing
weight
distribution
subspace
z495
dimension
495
439
56.
computation
beyond
resources
however
similar
calculation
would
feasible
somewhat
smaller
cases
example
taking
suitable
subset
60–105
system
example
2.7.
ray
parity
proofs
root
system
example
take
120
rays
determined
120
pairs
roots
lattice
0.3
second
ﬁnd
2025
orthogonal
bases
another
0.3
second
linear
algebra
step
ﬁnd
dimension
1941.
odd
weight
vectors
basis
conclude
21940
ray
parity
proofs
root
system
parity
proofs
incidence
structure
recall
work
observables
eigenvalues
thus
observable
class
observables
contains
tensor
products
pauli
operators
want
emphasize
results
section
limited
pauli
operators
give
completely
diﬀerent
strategy
producing
parity
proofs
section
2.1
started
given
set
constraints
consisting
ﬁxed
observables
ﬁnding
subsets
parity
proofs
revert
process
start
combinatorial
structure
set
constraints
asking
structure
subsequently
populated
observables
produce
parity
proofs
3.1
incidence
structures
deﬁnition
3.1.
let
ﬁnite
set
whose
elements
call
points
incidence
structure
pair
set
subsets
called
blocks
point
occurs
even
number
blocks
also
block
contains
least
three
points
points
model
observables
note
observable
may
assigned
distinct
points
blocks
model
constraints
requirements
incidence
structure
directly
linked
deﬁnition
parity
proof
requirement
block
size
follows
fact
constraint
must
contain
least
three
observables
one
class
incidence
structures
produced
cubic
graphs
cubic
graph
graph
vertex
degree
clearly
number
vertices
cubic
graph
must
even
exhaustive
lists
connected
cubic
graphs
vertices
isomorphism
along
drawings
found
126–144
magma
incorporates
b.d
mckay
sys-
tem
nauty
contains
eﬃcient
procedure
generating
graphs
isomorphism
used
computations
gener-
ation
restricted
vertex
degree
number
edges
connectedness
many
graph
parameters
given
connected
cubic
graph
produce
incidence
structure
points
edges
vertex
exactly
one
corresponding
block
block
contains
precisely
points
represent
edges
whose
one
endpoint
since
connected
decomposed
union
smaller
graphs
disjoint
vertex
sets
follows
incidence
structure
constructed
decompose
disjoint
union
smaller
incidence
structures
note
incidence
structures
constructed
way
connected
cubic
graphs
smallest
simplest
incidence
structures
relevant
paper
sense
point
belongs
exactly
two
blocks
block
size
exactly
three
however
many
incidence
structures
constructed
well
example
starting
graphs
vertex
degree
least
three
generally
starting
hypergraphs
example
3.2.
consider
complete
graph
vertex
set
label
edges
procedure
given
produces
incidence
structure
whose
set
points
set
blocks
incidence
structure
well
known
pasch
conﬁguration
given
incidence
structure
ask
assignment
observ-
ables
points
blocks
become
constraints
incidence
structure
becomes
parity
proof
question
answered
using
following
lemma
lemma
3.3.
let
incidence
structure
let
assign
point
observable
suppose
assignment
block
becomes
constraint
assignment
becomes
parity
proof
yb∈byp∈b
proof
according
deﬁnition
2.1
need
check
number
constraints
whose
product
odd
happens
product
products
constraints
example
3.4.
show
pasch
conﬁguration
introduced
example
3.2
produce
parity
proofs
suppose
assigned
observables
points
pasch
conﬁguration
recall
a−1
observable
without
loss
generality
assignment
observables
pasch
conﬁguration
following
form
s1o1o2
s2o1o3
s3o2o3
s1o1o2
s2o1o3
s3o2o3
observables
see
figure
s3o2o3
s2o1o3
s1o1o2
figure
pasch
conﬁguration
left-hand
side
product
equals
o1o2s1o1o2
o1o3s2o1o3
o2o3s3o2o3
s1o1o2s2o1o3s3o2o3
2o6
1o6
3o6
1s2
2s2
used
also
used
two
commute
two
occur
together
block
conﬁguration
note
lemma
3.3
following
consequence
left-hand
side
product
equals
every
permissible
assignment
observables
points
parity
proof
constructed
thus
particular
conclude
assignment
observables
points
pasch
conﬁguration
produces
parity
proof
3.2
finitely
presented
groups
hand
calculations
done
example
3.4
quickly
become
complicated
size
incidence
structure
increases
therefore
one
desires
automated
process
implemented
computer
ﬁnding
suitable
assignments
operators
points
incidence
structure
parity
proof
produced
proving
assignment
exists
indeed
possible
show
next
free
group
written
multiplicatively
generators
group
elements
possible
associative
products
gis
inverses
products
assumed
distinct
ﬁnitely
presented
group
free
group
modulo
set
relations
form
equality
two
elements
free
group
i.e.
equality
two
products
powers
word
problem
ﬁnitely
presented
group
question
whether
two
elements
written
products
powers
equal
modulo
set
relations
used
deﬁne
fix
incidence
structure
deﬁnition
3.1
introduce
assign-
ment
operators
points
block
becomes
constraint
done
example
3.4
involves
introducing
scalars
observables
let
denote
observable
assigned
point
generally
non-commuting
product
assignment
done
follows
step
take
point
assigned
yet
exists
block
containing
points
except
observables
assigned
already
assignment
forced
accounted
introduction
scalar
otherwise
let
new
generator
ultimately
interested
left-hand
side
product
since
equals
appears
even
exponent
left-hand
side
contribution
left-hand
side
hence
discard
computations
compute
think
ﬁnitely
presented
group
generators
modulo
set
relations
following
two
types
note
identity
matrix
identity
element
block
introduce
relations
auav
avau
point
introduce
relation
since
through-
paper
deal
observables
eigenvalues
note
construction
depends
assignments
done
considerable
freedom
choosing
assign-
ments
3.3
knuth-bendix
algorithm
left-hand
side
product
constraints
always
equals
lemma
3.3
discussion
section
3.2
left-hand
side
shown
equal
group
produce
parity
proof
let
free
group
ﬁnitely
presented
group
created
described
section
3.2.
knuth-bendix
algorithm
used
solve
word
problem
introductory
exposition
knuth-bendix
algorithm
found
example
chapter
used
implementation
knuth-bendix
algorithm
found
magma
knuth-bendix
algorithm
solves
word
problem
creating
rewriting
system
element
reduced
unique
canonical
form
let
denote
repeated
application
rewriting
system
crucial
property
rewriting
system
two
ways
use
knuth-bendix
algorithm
firstly
ask
whether
left-hand
side
equal
case
stop
conclusion
parity
proofs
produced
otherwise
augment
relations
used
deﬁne
listed
near
end
section
3.2
new
relations
form
two
observables
assigned
points
thus
obtain
new
group
left-hand
side
equal
becomes
equal
know
must
commute
assignment
observables
points
produces
parity
proof
information
used
prune
search
assignments
observables
points
example
3.5.
isomorphism
exactly
two
connected
cubic
graphs
six
vertices
see
page
127
depicted
graphs
graph
leads
general
construction
gave
incidence
structure
depicted
grid
figure
assume
assignments
done
shown
figure
let
set
six
blocks
ﬁgure
using
knuth-bendix
algorithm
magma
canonical
form
qb∈bqp∈b
o1o4
since
group
s1o1o2
s2o3o4
s3o1o3
s4o2o4
s5o1o2o3o4
figure
conﬁguration
element
o1o4
equal
rule
existence
parity
proofs
since
parity
proofs
may
exist
want
search
let
labels
figure
mean
observables
cd×d
ﬁxed
see
o1o4
necessary
condition
assignment
produces
parity
proof
fact
assignment
used
mermin
give
well
known
proof
kochen-specker
theorem
whence
parity
proofs
exist
conﬁguration
example
3.6.
graph
leads
incidence
structure
de-
picted
figure
assume
assignments
done
shown
figure
let
set
six
blocks
ﬁgure
knuth-bendix
algorithm
ﬁnds
canonical
form
qb∈bqp∈b
hence
left-hand
side
equals
admissible
assignment
observables
points
conﬁguration
lemma
3.3
conﬁguration
produce
parity
proof
using
methods
outlined
section
investigated
incidence
structures
constructed
connected
cubic
graphs
isomorphism
vertices
results
summarized
following
statement
proposition
3.7.
numbers
incidence
structures
connected
cubic
graphs
according
producing
parity
proofs
given
following
table
s1o1o2
s2o3o4
s3o2o4
s4o1o3
s5o1o4
figure
conﬁguration
number
vertices
connected
cubic
graph
producing
parity
proofs
producing
parity
proofs
incidence
structures
incidence
structures
proof
incidence
structures
counted
second
column
found
assignment
observables
points
incidence
structure
produces
parity
proof
incidence
structures
counted
third
column
proved
using
implementation
knuth-bendix
algo-
rithm
magma
produce
parity
proof
acknowledgment
research
reported
paper
supported
natural
sciences
engineering
research
council
canada
nserc
collaborative
research
group
mathematics
quantum
information
paciﬁc
institute
mathematical
sciences
pims
intelligence
advanced
research
projects
activity
iarpa
canadian
institute
advanced
research
cifar
references
anders
d.e
browne
computational
power
correlations
phys
rev
lett
102
050502
2009
e.f.
assmus
jr.
h.f.
mattson
jr.
weight-distribution
coset
linear
code
ieee
trans
inform
theory
1978
497
j.s
bell
problem
hidden
variables
quantum
mechanics
rev
mod
phys
1966
447
bohm
suggested
interpretation
quantum
theory
terms
hidden
variables
phys
rev
1952
bosma
cannon
playoust
magma
algebra
system
user
language
symbolic
comput
1997
235–265
bravyi
kitaev
universal
quantum
computation
ideal
cliﬀord
gates
noisy
ancillas
phys
rev
022316
2005
cabello
ambrosio
nagali
sciarrino
hybrid
ququart-encoded
quantum
cryptography
protected
kochen-specker
contextuality
phys
rev
030302
2011
d¨oring
kochen-specker
theorem
von
neumann
algebras
int
theor
phys
139-160
2005
einstein
podolsky
rosen
quantum-mechanical
de-
scription
physical
reality
considered
complete
phys
rev
777
1935
d.f
holt
eick
e.a
brien
handbook
computational
group
the-
ory
discrete
mathematics
applications
boca
raton
chap-
man
hall/crc
boca
raton
2005
kochen
e.p
specker
problem
hidden
variables
quantum
mechanics
math
mech
1967
f.j.
macwilliams
n.j.a
sloane
theory
error-correcting
codes
north-holland
1977
b.d
mckay
isomorph-free
exhaustive
generation
algorithms
1998
306–324
n.d.
mermin
hidden
variables
two
theorems
john
bell
rev
modern
phys
1993
part
803–815
peres
two
simple
proofs
kochen-specker
theorem
phys
math
gen.
l175-l178
1991
r.c
read
r.j.
wilson
atlas
graphs
oxford
science
publica-
tions
clarendon
press
oxford
university
press
new
york
1998
j.j.
sakurai
napolitano
modern
quantum
mechanics
addison-
wesley
boston
2011
second
edition
savage
survey
combinatorial
gray
codes
siam
rev
1997
605–629
veitch
ferrie
gross
emerson
negative
quasi-probability
resource
quantum
computation
new
phys
113011
2012
waegell
p.k
aravind
proofs
kochen-specker
theorem
based
system
three
qubits
phys
2012
405301
waegell
p.k
aravind
parity
proofs
kochen-specker
theorem
based
complex
rays
four
dimensions
phys
2011
505303
waegell
p.k
aravind
n.d.
megill
paviˇci´c
parity
proofs
bell-kochen-specker
theorem
based
600-cell
found
phys
2011
883–904
waegell
p.k
aravind
proofs
kochen-specker
theorem
based
n-qubit
pauli
group
phys
rev
012102
2013
weight
distribution
60–105
system
weightdistribution
135
810
12195
160
113892
18240
1077285
441600
9540450
7997824
80906400
118015200
688524520
1448184000
5961320616
15557419520
52002701520
147756103680
441117024580
1254610425984
3490721135520
9499625852160
24887073592740
63507095523840
155912963026760
369822648368640
844216996941390
1852875901104000
3909633540468480
7917739173148416
15397200649882050
28734130298150400
51467429865611820
88506321096591360
146135139624541674
231792714654302400
353282882649352920
517597039127587200
729263310135826470
988340133342723072
1288880337830696700
1617684355058453760
1954471451418300220
2273535202515416640
2546437247980289616
2746415207269776000
2852411008940091540
2852701144397253120
2747311965539513880
2547589610965831680
2274564123322337820
1955193785568922240
1617851718574207440
1288608587407530240
987792741688578932
728611838041505280
517088519080163880
352965614397949440
231697797145211865
146214633571559808
88658838120722880
51642900930835200
28871970516908175
15484467282700800
7960297421809338
3916267265034240
1843608398637195
827932478585760
354477153134820
144445514705216
55639662848925
20412542826240
6977966689330
2267783587200
689017459452
187607370720
55431880200
10352153280
4111118060
293784576
291511560
1812480
15413640
423920
total
time
27706.459
seconds
total
memory
usage
11.03mb
