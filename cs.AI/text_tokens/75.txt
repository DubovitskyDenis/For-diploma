extend
reason
sriq
andrew
bate
bori
motik
bernardo
cuenca
grau
frantiˇsek
ian
horrock
depart
comput
scienc
univers
oxford
oxford
unit
kingdom
abstract
calculu
famili
reason
rithm
descript
logic
dl
combin
tableau
resolut
way
often
achiev
excel
perform
practic
howev
pose
either
horn
dl
support
tion
dl
without
count
quantiﬁ
paper
present
novel
calculu
rich
support
featur
extens
trivial
sinc
intermedi
consequ
need
deriv
reason
captur
use
dl
self
result
preliminari
perform
evalu
suggest
feasibl
approach
practic
introduct
descript
logic
dl
baader
famili
knowledg
represent
formal
numer
cation
practic
applic
model
domain
interest
mean
ontolog
key
notion
domain
describ
use
concept
unari
cate
relationship
concept
describ
use
role
binari
predic
subsumpt
lem
determin
whether
instanc
concept
also
instanc
concept
model
ontolog
fundament
reason
problem
applic
dl
express
dl
problem
high
complex
rang
exptim
despit
discourag
complex
bound
highli
timis
reason
tsarkov
horrock
pellet
sirin
hermit
glimm
konclud
steigmil
liebig
glimm
prove
success
practic
system
typic
base
hyper
tableau
calculu
construct
ﬁnite
resent
canon
model
ontolog
disprov
postul
subsumpt
calculu
handl
mani
ontolog
case
construct
larg
model
represent
sourc
perform
problem
exacerb
larg
number
subsumpt
test
often
requir
classifi
ontolog
recent
breakthrough
reason
came
form
calculu
reason
algorithm
baader
brandt
lutz
lightweight
logic
seen
ﬁrst
calculu
later
extend
express
dl
kazakov
ortiz
rudolph
simku
support
count
quantiﬁ
disjunct
tween
concept
calculu
also
ope
alch
kazakov
horrock
alci
motik
horrock
support
concept
disjunct
count
quantiﬁ
calculu
seen
combin
resolut
pertableau
see
section
detail
resolut
describ
ontolog
model
systemat
deriv
vant
consequ
hyper
tableau
direct
avoid
draw
unnecessari
consequ
dition
refut
complet
also
di
prove
relev
subsumpt
singl
run
greatli
reduc
overal
comput
work
final
unlik
implement
hyper
tableau
er
optim
logic
support
steigmil
glimm
liebig
present
way
combin
calculu
tradit
prover
combin
seem
perform
well
practic
satur
rule
known
complet
ontolog
overal
approach
optim
sriq
exist
algorithm
handl
dl
alchiq
provid
disjunct
count
quantiﬁ
argu
section
extend
algorithm
handl
dl
challeng
ing
quantiﬁ
requir
equal
reason
togeth
disjunct
impos
complex
constraint
ogi
model
unlik
exist
calculu
constraint
captur
use
dl
make
reason
process
much
involv
section
present
calculu
alchiq
use
encod
role
chain
kazakov
calculu
also
handl
sriq
cover
owl
except
nomin
reﬂex
role
datatyp
borrow
idea
resolut
theorem
ing
encod
calculu
consequ
claus
speciﬁc
form
handl
equal
use
variant
order
paramodul
nieuwenhui
bio
state
art
calculu
equat
theorem
prove
use
modern
theorem
prover
schulz
vampir
riazanov
voronkov
care
constrain
infer
rule
calculu
mimic
exist
calculu
elh
gy
ensur
robust
perform
calculu
ontolog
implement
prototyp
system
compar
perform
reason
result
section
suggest
system
signiﬁcantli
outperform
pellet
hermit
often
exhibit
compar
perform
konclud
preliminari
logic
usual
equat
theorem
ing
encod
atom
formula
term
use
sort
signatur
prevent
consid
form
term
thu
partit
signatur
set
predic
symbol
set
function
symbol
assum
special
constant
term
construct
usual
use
variabl
signatur
bol
restrict
predic
symbol
allow
occur
outermost
level
latter
term
call
term
ple
predic
function
symbol
malform
term
term
equal
formula
form
either
equal
form
call
atom
written
ever
clear
context
express
denot
formula
inequ
negat
equal
written
assum
implicitli
ident
liter
equal
inequ
claus
formula
form
conjunct
atom
call
bodi
disjunct
liter
call
head
contain
variabl
cur
claus
quantiﬁ
usual
omit
understood
implicitli
often
treat
conjunct
junction
set
unord
without
tition
use
standard
set
oper
write
empti
conjunct
disjunct
term
liter
claus
set
thereof
say
ground
contain
variabl
result
appli
substitut
often
write
substitut
use
standard
notion
subterm
posit
subterm
posit
sition
proper
term
term
obtain
replac
subterm
posit
herbrand
equal
interpret
set
ground
equal
satisfi
usual
congruenc
properti
faction
ground
conjunct
ground
disjunct
necessarili
ground
claus
interpret
ten
well
entail
claus
set
claus
written
deﬁn
usual
note
ground
disjunct
liter
may
contain
equal
necessarili
impli
unless
otherwis
state
possibl
index
letter
denot
variabl
denot
term
denot
atom
depend
context
denot
liter
denot
function
symbol
denot
unari
predic
symbol
denot
binari
predic
symbol
order
strict
order
univers
ive
asymmetr
transit
relat
order
induc
order
total
given
element
subset
tation
abbrevi
multiset
tension
mul
compar
multiset
mul
exist
multiset
differ
oper
term
order
strict
order
set
term
extend
liter
identifi
multiset
multiset
compar
result
use
multiset
extens
reus
symbol
induc
liter
order
sinc
intend
mean
clear
context
calculu
take
input
set
claus
restrict
follow
form
let
countabl
set
unari
binari
predic
symbol
let
countabl
set
unari
function
bol
written
use
central
variabl
variabl
form
form
form
form
contain
form
bodi
head
variabl
occur
head
also
occur
bodi
ontolog
ﬁnite
set
queri
claus
liter
form
given
ontolog
queri
claus
calculu
decid
whether
hold
sriq
ontolog
written
use
syntax
transform
without
affect
queri
claus
entail
first
normalis
axiom
form
shown
side
tabl
transform
away
role
chain
replac
complex
concept
fresh
atom
one
process
well
understood
kov
motik
horrock
omit
detail
second
use
spondenc
dl
logic
baader
translat
normalis
axiom
shown
side
tabl
standard
lation
requir
atom
claus
bodi
allow
set
address
issu
introduc
fresh
role
axiomatis
turn
allow
clausifi
origin
axiom
elh
ontolog
contain
type
motiv
motiv
work
section
discu
drawback
exist
reason
calculu
tion
discu
exist
calculu
tabl
translat
normalis
alchiq
ontolog
fresh
ontolog
succ
succ
vbn
initialis
hyper
hyper
pred
succ
succ
hyper
hyper
pred
hyper
succ
succ
hyper
hyper
figur
exampl
motiv
calculu
address
problem
separ
claus
context
way
consider
reduc
number
infer
next
section
discu
main
contribut
paper
lie
extend
framework
disjunct
number
tion
handl
latter
requir
equal
reason
requir
involv
calculu
complet
proof
calculu
consid
ontolog
figur
one
ili
check
hold
prove
use
hyper
tableau
lu
start
appli
chain
manner
sinc
contain
construct
model
depth
fanout
two
node
depth
label
forward
chain
ensur
reason
howev
node
label
type
share
properti
reveal
ness
hyper
tableau
calculu
construct
model
larg
exponenti
exampl
highli
redund
apart
caus
problem
practic
often
prevent
hyper
tableau
calculu
optim
niqu
cach
nguyen
block
motik
shearer
horrock
constrain
model
construct
effect
often
depend
order
rule
applic
thu
model
size
key
limit
factor
hyper
reason
motik
shearer
horrock
contrast
resolut
describ
model
use
salli
quantiﬁ
claus
summaris
model
elimin
redund
ensur
optim
mani
resolut
decis
procedur
mani
resolut
ant
propos
bachmair
ganzing
restrict
infer
speciﬁc
way
howev
ensur
termin
decis
procedur
dl
awar
perform
infer
deepest
ere
claus
atom
resolv
obtain
claus
form
claus
relev
prove
goal
extend
addit
claus
contain
claus
particip
infer
give
rise
irrelev
claus
problem
particularli
pronounc
abl
sinc
must
produc
consequ
basic
notion
calculu
combin
summaris
olut
search
hyper
tableau
calculu
motik
horrock
present
work
alci
captur
key
element
relat
calculu
baader
brandt
lutz
kazakov
ortiz
rudolph
simku
kazakov
horrock
extend
framework
alchiq
section
next
inform
recapitul
basic
notion
howev
make
paper
easier
follow
use
notat
terminolog
section
calculu
construct
direct
graph
core
call
context
structur
vertex
call
context
let
herbrand
model
henc
domain
contain
ground
term
instead
repres
ground
term
separ
per
tableau
calculu
repres
properti
eral
term
singl
context
context
sociat
possibl
empti
conjunct
corev
core
atom
must
hold
ground
term
repres
thu
corev
determin
kind
context
moreov
associ
set
claus
captur
straint
term
must
satisfi
partit
claus
set
allow
restrict
infer
claus
set
thu
elimin
certain
irrelev
infer
claus
rel
corev
corev
includ
corev
claus
bodi
sinc
corev
hold
implicitli
function
vide
context
concept
order
strict
resolut
infer
presenc
disjunct
context
connect
direct
edg
label
function
symbol
connect
via
edg
ground
term
repres
repres
convers
nect
ground
term
repres
ground
term
repres
infer
ever
need
calculu
complet
tation
deriv
requir
consequ
figur
demonstr
core
claus
shown
respect
text
claus
number
correspond
deriv
der
prove
introduc
context
core
add
claus
latter
say
hold
analog
initialis
per
tableau
calculu
calculu
appli
rule
tabl
deriv
new
claus
extend
hyper
standard
hyperresolut
rule
restrict
singl
context
time
thu
deriv
hyperresolut
resolv
bodi
atom
make
resolv
relev
context
prevent
deriv
irrelev
claus
context
contain
atom
function
symbol
succ
rule
must
ensur
ground
term
repres
adequ
repres
control
context
troduct
via
paramet
call
expans
function
determin
whether
reus
exist
text
introduc
fresh
one
latter
case
also
mine
initialis
context
core
discu
ble
strategi
section
rest
exampl
use
cautiou
strategi
succ
rule
troduc
context
initialis
note
repres
two
claus
isfi
separ
applic
succ
rule
use
construct
context
vbn
analog
deriv
hyperresolv
rive
hyperresolv
claus
impos
constraint
predecessor
context
propag
use
pred
rule
deriv
sinc
claus
rel
core
claus
repres
queri
claus
requir
extend
framework
alchiq
calculu
present
thu
far
straint
ground
term
repres
context
must
satisfi
repres
use
standard
iom
exampl
alci
motik
rock
repres
relev
consequ
use
axiom
follow
form
alchiq
provid
count
quantiﬁ
junction
interplay
may
impos
constraint
repres
alchiq
let
figur
see
hold
construct
herbrand
interpret
deriv
deriv
due
rive
final
deriv
follow
claus
disjunct
satisﬁ
due
regardless
whether
choos
satisfi
deriv
calculu
must
abl
captur
constraint
consequ
standard
axiom
itli
refer
speciﬁc
successor
predecessor
instead
captur
consequ
use
context
term
variabl
repres
ground
term
context
stand
repres
successor
repres
predecessor
thu
identifi
predecessor
successor
name
allow
captur
constraint
base
idea
adapt
rule
motik
horrock
handl
context
claus
correctli
ad
rule
captur
consequ
equal
result
set
rule
shown
tabl
figur
show
verifi
ing
calculu
maxim
liter
claus
shown
right
next
discu
infer
detail
ontolog
succ
succ
initialis
hyper
hyper
pred
hyper
hyper
succ
succ
succ
succ
hyper
succ
succ
succ
succ
hyper
hyper
hyper
hyper
hyper
pred
figur
challeng
extend
framework
alchiq
ﬁrst
creat
context
initialis
ensur
interpret
repres
text
structur
contain
ground
term
hold
next
deriv
use
hyperresolut
point
could
hyperresolv
obtain
howev
could
easili
lead
nontermin
calculu
due
increas
term
ing
therefor
requir
hyperresolut
map
variabl
variabl
context
claus
thu
hyperresolut
deriv
context
consequ
prevent
redund
deriv
succ
rule
next
handl
function
symbol
claus
determin
inform
gate
successor
deﬁnit
section
introduc
set
successor
trigger
exampl
contain
atom
bodi
map
predecessor
successor
thu
context
hyperresolut
appli
interest
inform
predecessor
reﬂect
ad
ple
use
eager
strategi
see
section
succ
rule
introduc
context
set
core
initialis
context
next
introduc
use
hyperresolut
point
sufﬁcient
inform
appli
resolut
deriv
pleas
note
enc
crucial
infer
use
paramodul
deal
equal
claus
common
theorem
prove
order
liter
claus
appli
infer
maxim
liter
thu
deriv
claus
contain
function
symbol
succ
rule
introduc
context
due
claus
hold
ground
term
repres
thu
add
contrast
atom
occur
claus
disjunct
mean
may
hold
henc
add
bodi
claus
latter
claus
allow
deriv
use
hyperresolut
claus
essenti
say
hold
predecessor
pred
rule
propag
claus
one
understand
infer
olut
observ
term
context
repres
variabl
context
two
paramodul
step
deriv
claus
essenti
say
predecessor
must
satisfi
set
predecessor
trigger
init
identiﬁ
relev
contain
bodi
resent
henc
contain
allow
pred
rule
deriv
two
step
ﬁnalli
deriv
target
claus
could
maxim
thu
requir
atom
head
goal
claus
smallest
similar
observ
appli
maxim
would
deriv
gate
thu
atom
must
smallest
formalis
algorithm
section
ﬁrst
present
rithm
alchiq
formal
present
line
complet
proof
full
proof
given
appendix
deﬁnit
calculu
manipul
context
claus
struct
context
term
context
liter
describ
deﬁnit
unlik
gener
resolut
restrict
text
claus
contain
variabl
special
mean
set
variabl
repres
ground
term
herbrand
model
repres
decessor
name
convent
import
rule
calculu
contrast
ontolog
contain
variabl
refer
either
predecessor
successor
deﬁnit
context
term
form
context
term
form
context
term
context
liter
liter
form
call
context
atom
context
context
claus
claus
context
atom
bodi
context
liter
head
deﬁnit
introduc
set
tifi
inform
must
exchang
cent
context
intuit
contain
atom
interest
context
successor
guid
succ
rule
wherea
contain
atom
interest
text
predecessor
guid
pred
rule
deﬁnit
set
successor
trigger
tolog
smallest
set
atom
claus
impli
impli
impli
set
predecessor
trigger
deﬁn
occur
resolut
restrict
infer
use
term
order
deﬁnit
speciﬁ
condit
der
must
satisfi
condit
ensur
compar
uniformli
across
context
howev
compar
differ
way
differ
context
dition
ensur
ground
order
map
term
predecessor
obtain
simpliﬁc
order
baader
nipkow
kind
term
order
commonli
use
equat
theorem
prove
final
condit
ensur
atom
might
propag
context
predecessor
via
pred
rule
smallest
import
complet
deﬁnit
let
total
order
tion
symbol
context
term
order
order
context
term
satisfi
follow
condit
term
posit
term
proper
posit
atom
context
term
term
order
extend
liter
order
also
written
describ
section
lexicograph
path
order
lpo
baader
nipkow
context
context
treat
constant
satisﬁ
condit
furthermor
contain
atom
form
alway
make
smallest
order
thu
condit
contradict
condit
henc
lpo
relax
condit
satisﬁ
deﬁnit
thu
given
least
one
context
term
order
exist
apart
order
effect
redund
elimin
niqu
critic
efﬁcienc
resolut
calculu
tion
deﬁn
notion
compat
set
deﬁnit
set
claus
contain
claus
redund
written
term
claus
intuit
contain
redund
ad
modifi
constraint
repres
either
tautolog
tain
stronger
claus
note
tautolog
form
redund
set
use
initialis
context
howev
whenev
calculu
deriv
claus
set
claus
tialis
make
former
claus
dant
condit
deﬁnit
moreov
claus
head
subject
usual
tautolog
elimin
rule
thu
claus
elimin
proposit
show
remov
claus
contain
danci
elim
us
support
claus
subsumpt
proposit
set
claus
claus
ﬁnalli
readi
formalis
notion
context
structur
well
notion
context
structur
sound
latter
captur
fact
context
claus
set
contain
corev
bodi
shall
later
show
infer
rule
preserv
context
structur
ness
essenti
prof
claus
deriv
calculu
inde
conclus
ontolog
question
deﬁnit
context
structur
ontolog
ple
core
ﬁnite
set
text
ﬁnite
set
edg
label
function
symbol
function
core
assign
text
conjunct
corev
atom
function
assign
context
ﬁnite
set
context
claus
function
assign
context
context
term
order
context
structur
sound
follow
condit
hold
context
claus
edg
corev
coreu
corev
deﬁnit
introduc
expans
eter
calculu
determin
reus
context
order
satisfi
existenti
restrict
deﬁnit
expans
strategi
function
strategi
take
function
symbol
set
atom
context
structur
core
result
strategi
comput
polynomi
time
tripl
core
core
subset
either
fresh
context
exist
context
corev
core
context
term
order
motik
horrock
present
two
sic
strategi
adapt
set
follow
eager
strategi
return
context
core
kind
ground
term
sent
speciﬁc
set
like
smaller
number
context
exponenti
cautiou
strategi
examin
function
symbol
occur
exactli
one
atom
form
result
context
core
otherwis
result
trivial
text
empti
core
context
le
constrain
number
context
linear
motik
horrock
discu
extens
differ
rel
merit
two
strategi
although
discuss
deal
alci
conclus
appli
sriq
well
readi
show
sound
complet
theorem
sound
expans
strategi
pli
infer
rule
tabl
ontolog
context
structur
sound
produc
context
structur
sound
theorem
complet
let
ontolog
let
core
context
structur
infer
rule
tabl
applic
hold
queri
claus
context
satisfi
condit
atom
context
term
condit
satisﬁ
appropri
initialis
correspond
context
henc
theorem
show
follow
algorithm
sound
plete
decid
creat
empti
context
structur
select
pansion
strategi
tabl
rule
calculu
core
rule
corev
add
substitut
add
aiσ
aiσ
hyper
rule
rule
add
ineq
rule
add
factor
rule
add
elim
rule
remov
pred
rule
aiσ
aiσ
add
aiσ
aiσ
succ
rule
contain
corev
edg
exist
let
core
strategi
let
otherwis
let
add
edg
add
corev
corev
core
introduc
context
set
coreq
add
satisfi
condit
initialis
way
satisﬁ
condit
appli
infer
rule
tabl
hold
proposit
show
calculu
optim
alchiq
elh
proposit
expans
strategi
introduc
exponenti
mani
context
algorithm
run
exponenti
time
proposit
elh
ontolog
queri
form
algorithm
run
polynomi
time
either
cautiou
eager
strategi
cautiou
strategi
hyper
rule
appli
eagerli
infer
step
correspond
directli
infer
elh
calculu
baader
brandt
lutz
outlin
complet
proof
prove
theorem
ontolog
context
ture
queri
claus
context
properti
theorem
satisﬁ
hold
construct
herbrand
pretat
satisﬁ
refut
reus
techniqu
equat
theorem
prove
nieuwenhui
rubio
repres
interpret
rewrit
system
ﬁnite
set
rule
form
intuit
rule
say
two
term
form
equal
prove
equal
one
step
rewrit
replac
rewrit
system
duce
herbrand
equal
interpret
contain
equal
veriﬁ
use
ﬁnite
number
rewrit
step
vers
consist
construct
use
symbol
special
constant
nienc
let
set
univers
obtain
unfold
context
structur
start
context
map
context
use
claus
sxt
construct
model
fragment
part
satisﬁ
map
key
issu
ensur
patibl
adjac
model
fragment
move
predecessor
term
successor
term
must
ensur
ad
affect
truth
term
word
model
fragment
construct
must
respect
choic
made
repres
choic
ground
claus
conjunct
contain
atom
inherit
must
hold
disjunct
contain
atom
must
hold
reli
absenc
model
fragment
construct
take
paramet
term
context
claus
let
set
ground
claus
obtain
map
predecessor
exist
whose
bodi
contain
moreov
let
sut
prt
obtain
map
predecessor
one
exist
thu
sut
contain
ground
atom
interest
successor
prt
contain
ground
atom
interest
predecessor
model
fragment
construct
properti
hold
prt
construct
produc
rewrit
system
none
hold
model
fragment
compat
inherit
constraint
construct
rewrit
system
adapt
techniqu
theorem
prove
first
der
claus
sequenc
compat
context
order
particular
way
next
initialis
examin
claus
sequenc
hold
model
construct
thu
far
make
claus
true
ad
prove
condit
assum
sake
contradict
claus
smallest
show
applic
exist
ineq
factor
rule
necessarili
produc
condit
claus
allow
satisfi
condit
due
tion
condit
deﬁnit
order
claus
sequenc
claus
capabl
produc
atom
come
claus
sequenc
use
condit
show
claus
actual
exist
moreov
condit
ensur
atom
actual
produc
obtain
induct
unfold
step
appli
model
fragment
construct
appropri
paramet
base
case
map
constant
context
deﬁn
dition
hold
deﬁnit
condit
hold
properti
theorem
induct
step
sume
alreadi
map
term
context
consid
term
occur
atom
let
thu
make
equal
term
thu
interpret
exactli
way
stop
unfold
contain
rule
equal
interpret
exactli
henc
stop
unfold
case
succ
rule
ensur
tain
edg
satisﬁ
dition
rule
deﬁn
moreov
sut
set
atom
hold
let
relev
let
prt
set
atom
hold
relev
ﬁnalli
show
satisfi
condit
otherwis
pred
rule
deriv
claus
true
process
relev
term
let
union
construct
show
isﬁ
consid
stitut
make
claus
ground
hermit
pellet
konclud
sequoia
figur
classiﬁc
time
ontolog
easi
categori
medium
categori
hard
categori
proﬁl
horn
equal
equal
figur
percentag
easi
medium
hard
ontolog
per
ontolog
group
hermit
pellet
konclud
sequoia
assum
irreduc
tain
term
rewritten
use
rule
sinc
model
fragment
satisﬁ
condit
ate
instead
moreov
show
hold
case
hyper
rule
deriv
claus
violat
tion
final
show
hold
queri
claus
complet
proof
evalu
implement
calculu
prototyp
system
call
sequoia
calculu
implement
exactli
present
paper
optimis
suitabl
index
scheme
claus
system
written
scala
use
via
command
line
owl
api
current
handl
sriq
subset
owl
support
datatyp
nomin
ive
role
support
ontolog
classiﬁc
concept
satisﬁ
standard
servic
abox
realis
current
support
evalu
system
use
methodolog
steigmil
liebig
glimm
compar
quoia
hermit
pellet
konclud
use
reason
mode
order
compar
underli
calculu
moreov
sequoia
conﬁgur
use
cautiou
strategi
tem
ontolog
test
result
avail
use
oxford
ontolog
exclud
ontolog
irregular
rbox
sinc
sequoia
support
datatyp
nomin
calli
replac
datatyp
nomin
fresh
class
data
properti
object
properti
remov
abox
assert
thu
obtain
corpu
gy
test
reason
run
experi
dell
workstat
two
intel
xeon
ghz
processor
core
per
processor
ram
run
window
server
use
java
updat
heap
memori
alloc
java
reason
maximum
privat
work
set
size
reason
nativ
code
test
measur
classiﬁc
time
exclud
pars
time
reason
base
owl
api
hermit
pellet
sequoia
test
given
timeout
minut
report
averag
time
three
run
unless
except
timeout
occur
one
three
run
case
report
failur
figur
show
overview
classiﬁc
time
entir
corpu
show
classiﬁc
time
logarithm
scale
timeout
shown
inﬁniti
number
repres
easiest
ontolog
reason
ontolog
sort
reason
ascend
order
classiﬁc
time
exampl
point
reason
curv
mean
easiest
ontolog
reason
took
classifi
sequoia
could
process
ontolog
consist
reason
system
fairli
robust
fail
ontolog
contrast
hermit
fail
pellet
konclud
ontolog
moreov
sequoia
ceed
ontolog
hermit
pellet
fail
final
one
ontolog
quoia
succeed
reason
fail
hard
version
fma
us
disjunct
number
restrict
figur
show
overview
reason
form
type
ontolog
partit
gy
follow
four
group
within
proﬁl
owl
captur
owl
horn
proﬁl
disjunct
without
number
restrict
disjunct
number
restrict
use
owl
api
determin
proﬁl
membership
identiﬁ
remain
three
group
structur
transform
addit
reason
categoris
ontolog
either
easi
medium
hard
timeout
except
ﬁgure
depict
bar
soner
group
bar
divid
block
resent
percentag
ontolog
mention
categori
difﬁculti
sequoia
proﬁl
ontolog
horn
tolog
easi
remaind
medium
ﬁculti
sequoia
time
larg
ontolog
contain
disjunct
equal
even
case
konclud
time
fewer
case
summari
although
earli
prototyp
sequoia
competit
reason
comfort
outperform
mit
pellet
exhibit
nice
behaviour
furthermor
problemat
ontolog
seem
mostli
contain
complex
rbox
larg
number
cardin
restrict
suggest
promis
tion
futur
optimis
conclus
futur
work
present
ﬁrst
consequ
base
calculu
includ
disjunct
count
quantiﬁ
calculu
combin
idea
state
art
resolut
hyper
tableau
calculu
includ
use
order
paramodul
equal
reason
despit
increas
complex
calculu
mimic
exist
culi
elh
ontolog
although
earli
prototyp
plenti
room
optimis
system
sequoia
competit
reason
exhibit
nice
behaviour
practic
futur
work
conﬁdent
extend
calculu
support
role
reﬂex
datatyp
thu
handl
owl
except
nomin
contrast
handl
nomin
seem
much
involv
fact
ad
nomin
alchiq
rais
complex
reason
nexptim
optim
lu
must
nondeterminist
quit
differ
calculu
awar
moreov
challeng
modifi
calculu
effect
deal
larg
number
number
restrict
refer
baader
nipkow
term
rewrit
cambridg
univers
press
baader
calvanes
mcguin
nardi
ed
descript
logic
handbook
theori
implement
applic
bridg
univers
press
baader
brandt
lutz
push
envelop
kaelbl
safﬁotti
proc
int
joint
confer
artiﬁci
intellig
ijcai
edinburgh
morgan
kaufmann
publish
bachmair
ganzing
resolut
theorem
robinson
voronkov
prove
book
autom
reason
volum
elsevi
scienc
chapter
glimm
horrock
motik
stoilo
wang
hermit
owl
reason
journal
mate
reason
nguyen
exptim
tableau
global
cach
descript
logic
tive
role
invers
role
role
hierarchi
olivetti
proc
int
conf
autom
ing
tableau
relat
method
tableau
volum
lnc
aix
provenc
franc
springer
kazakov
riq
sroiq
harder
shoiq
brewka
lang
proc
int
joint
conf
principl
knowledg
tation
reason
sydney
nsw
australia
aaai
press
kazakov
reason
horn
shiq
ontolog
boutili
proc
int
joint
conf
artiﬁci
intellig
ijcai
motik
shearer
horrock
hypertableau
reason
descript
logic
journal
artiﬁci
tellig
research
nieuwenhui
rubio
theorem
prove
order
equal
constrain
claus
journal
symbol
comput
ortiz
rudolph
simku
optim
reason
fragment
owl
lin
sattler
truszczynski
proc
int
conf
knowledg
represent
reason
toronto
canada
aaai
press
riazanov
voronkov
design
mentat
vampir
commun
schulz
brainiac
theorem
prover
munic
kazakov
horrock
reason
beyond
horn
ontolog
walsh
proc
int
joint
conf
cial
intellig
ijcai
motik
horrock
tractabl
reason
descript
logic
artiﬁci
intellig
sirin
parsia
cuenca
grau
kalyanpur
katz
pellet
practic
reason
nal
web
semant
steigmil
glimm
liebig
coupl
tableau
algorithm
express
descript
logic
satur
procedur
demri
pur
weidenbach
proc
int
joint
conf
autom
reason
ijcar
volum
lnc
vienna
austria
springer
steigmil
liebig
glimm
konclud
system
descript
journal
web
semant
tsarkov
horrock
descript
logic
reason
system
descript
proc
int
joint
conf
autom
reason
ijcar
volum
lnai
seattl
usa
springer
proof
theorem
chapter
show
calculu
sound
state
theorem
proof
analog
sound
proof
order
superposit
nieuwenhui
rubio
theorem
sound
expans
strategi
appli
infer
rule
tabl
ontolog
context
structur
sound
produc
context
structur
sound
proof
let
ontolog
let
core
context
structur
sound
consid
applic
infer
rule
tabl
show
claus
produc
rule
context
claus
satisﬁ
condit
deﬁnit
condit
hold
obvious
rule
differ
hyper
pred
condit
reli
sound
hyperresolut
arbitrari
formula
corev
prove
claim
consid
rule
tabl
assum
rule
appli
claus
context
edg
shown
tabl
show
claus
produc
rule
satisﬁ
condit
deﬁnit
moreov
succ
rule
show
addit
edg
introduc
rule
satisﬁ
condit
core
corev
clearli
corev
hyper
sinc
sound
corev
aiσ
moreov
substitut
satisﬁ
premis
context
claus
contain
thu
infer
rule
match
atom
ontolog
claus
atom
context
claus
either
thu
result
context
claus
sinc
sound
properti
hold
moreov
claus
logic
consequ
claus
properti
hold
requir
corev
corev
corev
final
term
alway
form
term
form
term
form
thu
context
term
result
context
claus
ineq
sinc
sound
corev
clearli
corev
requir
factor
sinc
sound
properti
hold
moreov
claus
logic
consequ
claus
properti
hold
requir
corev
corev
elim
result
context
structur
contain
subset
claus
clearli
sound
pred
let
sinc
sound
properti
hold
claus
instanc
claus
properti
hold
properti
impli
properti
final
properti
impli
properti
requir
coreu
aiσ
coreu
corevσ
corev
aiσ
corevσ
corevσ
corev
coreu
form
deﬁnit
ensur
aiσ
context
atom
requir
ajσ
ajσ
ajσ
succ
let
claus
ad
clearli
corev
requir
condit
deﬁnit
moreov
assum
infer
rule
add
edg
sinc
sound
deﬁnit
corev
coreu
coreu
corevσ
properti
hold
requir
condit
deﬁnit
preliminari
rewrit
system
proof
theorem
construct
model
ontolog
common
equat
theorem
prove
repres
use
ground
rewrit
system
next
recapitul
deﬁnit
rewrit
system
follow
present
baader
nipkow
let
set
ground
term
construct
use
distinguish
constant
sort
function
symbol
predic
symbol
ground
rewrit
system
binari
relat
pair
call
rewrit
rule
commonli
written
rewrit
relat
smallest
binari
relat
term
necessarili
proper
posit
moreov
closur
term
irreduc
closur
term
exist
liter
claus
substitut
irreduc
term
occur
irreduc
consid
follow
irreduc
moreov
term
normal
form
properti
rewrit
system
termin
inﬁnit
sequenc
term
exist
term
irreduc
term
termin
baader
nipkow
theorem
exercis
hold
herbrand
interpret
induc
term
uniqu
normal
form
system
set
term
order
use
prove
termin
rewrit
system
term
order
simpliﬁc
order
follow
term
exist
condit
hold
term
posit
substitut
impli
term
proper
posit
given
rewrit
system
simpliﬁc
order
exist
impli
termin
baader
nipkow
theorem
impli
proof
theorem
theorem
complet
let
ontolog
let
core
context
structur
infer
rule
tabl
applic
hold
queri
claus
context
satisfi
condit
atom
context
term
section
ontolog
context
structur
core
context
queri
claus
condit
theorem
satisﬁ
show
contraposit
condit
end
construct
rewrit
system
induc
herbrand
model
satisﬁ
claus
construct
model
use
distinguish
constant
unari
function
symbol
unari
binari
predic
symbol
respect
let
term
form
predecessor
successor
deﬁnit
stant
predecessor
set
contain
predecessor
one
exist
contain
predecessor
also
let
substitut
predecessor
final
term
deﬁn
set
atom
prt
sut
follow
sut
aσt
aσt
ground
prt
aσt
aσt
ground
construct
model
fragment
section
show
given
term
gener
part
model
cover
neighbourhood
rest
appendix
follow
paramet
model
fragment
gener
process
ground
context
conjunct
atom
disjunct
atom
let
set
ground
claus
obtain
follow
γσt
γσt
ground
γσt
assum
follow
condit
hold
prt
hold
throughout
appendix
treat
next
construct
rewrit
system
term
constant
thu
even
though
rewrit
system
contain
term
consid
term
nest
ground
context
order
construct
need
order
term
neighbourhood
compat
end
let
total
strict
simpliﬁc
order
set
ground
term
construct
use
predic
symbol
satisﬁ
follow
condit
context
term
ground
predecessor
exist
impli
impli
condit
theorem
condit
deﬁnit
ensur
order
nonground
context
term
ground
way
compat
condit
moreov
sinc
section
treat
constant
make
form
smaller
need
worri
deﬁn
order
predecessor
ancestor
thu
least
one
order
exist
rest
section
arbitrari
order
extend
ground
liter
also
written
identifi
multiset
multiset
compar
result
use
multiset
extens
term
order
deﬁn
section
final
extend
disjunct
ground
liter
also
written
multiset
compar
result
use
multiset
extens
identifi
disjunct
liter
order
construct
rewrit
system
arrang
claus
sequenc
sinc
bodi
subset
contain
head
would
contradict
condit
thu
assum
form
liter
form
rest
appendix
reserv
refer
part
claus
sequenc
final
assum
deﬁn
rewrit
system
set
form
tive
follow
next
deﬁn
sequenc
irreduc
case
final
let
ﬁrst
condit
construct
call
gener
claus
said
gener
rule
call
model
fragment
claus
satisﬁ
properti
model
fragment
lemma
rewrit
system
proof
see
termin
simpli
note
rule
condit
ensur
simpliﬁc
order
see
consid
arbitrari
rule
ad
step
claus
sequenc
condit
irreduc
consid
arbitrari
rule
ad
step
construct
deﬁnit
claus
order
impli
sinc
condit
deﬁnit
liter
order
sinc
condit
ensur
consequ
subterm
thu
irreduc
lemma
proof
consid
arbitrari
claus
arbitrari
inequ
requir
assum
impli
let
consid
arbitrari
gener
normal
form
respect
deﬁnit
liter
order
impli
sinc
simpliﬁc
order
subterm
neither
thu
normal
form
respect
lemma
gener
claus
proof
consid
gener
claus
liter
condit
ensur
next
show
assum
form
sinc
lemma
assum
form
show
induct
requir
requir
gener
thu
assum
end
assum
gener
consid
follow
two
case
follow
two
subcas
condit
ensur
let
normal
form
respect
moreov
hold
sinc
simpliﬁc
order
subterm
neither
therefor
normal
form
respect
therefor
final
sinc
irreduc
impli
furthermor
contradict
condit
term
normal
form
gener
let
normal
form
respect
hold
sinc
simpliﬁc
order
subterm
neither
thu
normal
form
respect
henc
hold
exist
lemma
let
claus
index
claus
proof
assum
hold
satisﬁ
condit
deﬁnit
clearli
assum
satisﬁ
condit
deﬁnit
due
claus
hold
latter
clearli
impli
let
integ
satisfi
lemma
assumpt
clearli
otherwis
impli
also
lemma
assumpt
lemma
claus
γσt
hold
γσt
proof
assum
hold
satisﬁ
condit
deﬁnit
term
exist
sσt
sσt
sσt
γσt
hold
furthermor
satisﬁ
condit
deﬁnit
claus
exist
due
γσt
hold
γσt
hold
well
lemma
impli
requir
proof
sake
contract
choos
claus
sequenc
claus
appendix
pleas
recal
due
smallest
choic
condit
lemma
hold
deﬁnit
claus
exist
γσt
lσt
next
prove
claim
lemma
consid
possibl
form
contradict
assumpt
assum
assum
liter
form
lσt
rσt
deﬁnit
ﬁrst
show
hold
toward
goal
note
equal
inequ
lemma
properti
impli
claus
gener
thu
either
condit
condit
satisﬁ
next
consid
possibl
condit
reduc
thu
claus
satisﬁ
condit
howev
sinc
deﬁnit
reduc
posit
claus
gener
rule
exist
due
togeth
lemma
ensur
deﬁnit
ensur
claus
exist
impli
assumpt
theorem
rule
applic
let
clearli
γσt
lemma
ensur
hold
set
congruenc
hold
final
simpliﬁc
order
ensur
togeth
lemma
contradict
impli
condit
hold
term
exist
furthermor
form
hold
therefor
due
rσt
lσt
clearli
assumpt
theorem
factor
rule
applic
let
γσt
lemma
moreov
impli
sure
hold
previou
observ
thu
hold
lemma
impli
assum
liter
form
lσt
rσt
impli
assumpt
theorem
ineq
rule
applic
claus
sinc
γσt
lemma
clearli
lemma
impli
contradict
contradict
henc
reduc
assum
lemma
ensur
init
reduc
posit
gener
claus
exist
due
lemma
ensur
deﬁnit
ensur
claus
exist
satisfi
ﬁrst
case
assumpt
theorem
rule
ble
claus
hold
let
clearli
γσt
lemma
sinc
hold
final
simpliﬁc
order
togeth
therefor
lemma
impli
lemma
claus
proof
appli
lemma
lemma
lemma
gener
claus
disjunct
contain
liter
form
proof
sake
contradict
let
assum
claus
gener
hold
term
deﬁnit
claus
exist
contradict
congruenc
lemma
contradict
moreov
condit
sinc
argument
note
condit
ensur
lemma
ensur
assum
sake
contradict
atom
exist
assumpt
theorem
ineq
rule
applic
claus
thu
hold
howev
lemma
lemma
impli
let
index
claus
sequenc
claus
appendix
due
impli
lemma
atom
proof
gener
claus
posit
exist
let
sinc
simpliﬁc
order
sinc
next
consid
arbitrari
liter
observ
made
thu
far
hold
condit
one
follow
hold
moreov
sinc
obtain
ground
context
liter
form
togeth
claus
gener
due
condit
henc
remain
possibl
form
claus
gener
lemma
consequ
either
case
get
contradict
thu
second
point
hold
arbitrari
therefor
impli
hold
contradict
condit
combin
rewrit
system
construct
appendix
singl
rewrit
system
show
satisﬁ
interpret
ontolog
unfold
context
structur
construct
partial
induct
term
deﬁn
sever
partial
function
function
map
term
context
function
assign
term
conjunct
disjunct
respect
atom
function
map
term
model
fragment
base
case
consid
constant
γqσc
model
fragment
induct
step
assum
alreadi
deﬁn
consid
arbitrari
function
symbol
irreduc
let
two
possibl
term
occur
term
gener
ground
claus
occur
deﬁnit
claus
exist
contain
moreov
impli
succ
core
rule
applic
choos
context
succ
rule
deﬁn
follow
sut
prt
model
fragment
term
occur
let
deﬁn
function
final
let
rewrit
system
deﬁn
lemma
model
fragment
construct
line
satisfi
condit
pendix
proof
proof
induct
structur
term
dom
condit
hold
directli
condit
theorem
next
assum
lemma
hold
term
dom
consid
arbitrari
term
form
let
condit
hold
prt
due
henc
prt
proceed
note
term
irreduc
due
condit
sinc
hold
atom
gener
claus
satisfi
subscript
necessarili
indic
posit
claus
sequenc
claus
appendix
deﬁnit
exist
claus
satisfi
condit
consid
arbitrari
atom
let
claus
gener
let
substitut
succ
rule
speciﬁ
succ
rule
condit
chose
succ
rule
satisﬁ
prove
condit
hold
well
assum
sake
contradict
hold
prt
correspond
nonground
claus
sinc
sut
atom
therefor
requir
condit
sinc
form
iσt
iσt
iσt
due
therefor
due
condit
deﬁnit
set
contain
claus
prt
deﬁnit
set
contain
claus
iσt
gener
ground
claus
latter
obtain
correspond
nonground
claus
pred
rule
applic
hold
togeth
lemma
ensur
lemma
contradict
lemma
ensur
howev
termin
conﬂuenc
compat
lemma
rewrit
system
proof
show
termin
thu
proof
former
use
total
simpliﬁc
order
ground
deﬁn
follow
extend
preced
deﬁnit
arbitrari
way
ensur
constant
smallest
order
let
lexicograph
path
order
baader
nipkow
well
known
simpliﬁc
order
satisﬁ
follow
properti
predecessor
one
exist
function
symbol
impli
thu
condit
deﬁnit
manner
context
order
ground
appendix
clearli
ensur
dom
term
next
show
termin
argu
rule
embed
end
consid
arbitrari
rule
clearli
term
dom
exist
rule
obtain
head
claus
condit
deﬁnit
ensur
moreov
obtain
ground
context
liter
follow
possibl
form
term
impli
sinc
smallest
next
show
sake
contradict
assum
rule
exist
reduc
let
deepest
posit
rule
reduc
rule
reduc
posit
let
rule
reduc
posit
thu
deﬁnit
follow
term
handl
condit
gener
equal
head
gener
claus
term
handl
condit
moreov
contain
construct
contradict
form
thu
reduc
contradict
condit
construct
assumpt
assum
assum
sake
contradict
lemma
term
atom
sut
prf
irreduc
proof
let
term
let
function
symbol
let
sut
prf
atom
irreduc
latter
ensur
next
consid
possibl
form
assum
sut
deﬁnit
sut
fact
contain
atom
form
atom
form
predecessor
one
exist
form
due
sut
deﬁnit
gener
claus
clearli
lemma
ensur
assum
prf
deﬁnit
prf
fact
contain
atom
form
atom
form
form
gener
claus
clearli
due
prf
deﬁnit
due
lemma
contradict
lemma
let
let
substitut
irreduc
ground
deﬁn
proof
let
state
let
let
predecessor
one
exist
sinc
irreduc
rewrit
system
deﬁn
appendix
next
consid
possibl
form
assum
assum
let
normal
form
respect
due
shape
form
therefor
form
term
irreduc
thu
irreduc
well
furthermor
due
shape
context
term
rewrit
system
could
occur
side
rewrit
rule
consequ
irreduc
well
normal
form
respect
thu
thu
hold
requir
therefor
impli
requir
complet
claim
lemma
proof
consid
arbitrari
follow
form
let
arbitrari
substitut
ground
let
substitut
obtain
ing
ground
term
normal
form
sinc
congruenc
next
assum
show
hold
well
consid
arbitrari
atom
deﬁnit
form
tion
irreduc
aiτ
irreduc
aiτ
clearli
impli
aiτ
rule
obtain
gener
claus
aiτ
form
predecessor
exist
next
prove
aiτ
sut
prf
hold
consid
possibl
form
aiτ
impli
sut
hold
aiτ
form
impli
sut
hold
moreov
impli
prf
hold
aiτ
form
impli
sut
hold
moreov
impli
prf
hold
lemma
impli
aiτ
contain
gener
claus
form
let
deﬁnit
set
contain
claus
form
hyper
rule
applic
therefor
hold
substitut
obtain
replac
occurr
possibl
nest
anoth
term
final
lemma
ensur
hold
well
iσt
iσt
iσt
lemma
impli
lemma
impli
lemma
ensur
requir
lemma
proof
claim
clearli
follow
note
lemma
ensur
former
observ
lemma
ensur
hold
moreov
atom
nition
ensur
thu
prf
contraposit
lemma
ensur
thu
hold
requir
therefor
thu
final
proof
proposit
proposit
expans
strategi
introduc
exponenti
mani
context
algorithm
run
exponenti
time
proof
number
context
claus
gener
use
symbol
exponenti
size
number
claus
particip
infer
linear
size
henc
context
number
infer
bound
exponenti
size
number
infer
exponenti
well
thu
exponenti
mani
context
introduc
algorithm
run
exponenti
time
proof
proposit
proposit
elh
ontolog
queri
form
algorithm
run
polynomi
time
either
cautiou
eager
strategi
cautiou
strategi
hyper
rule
appli
eagerli
infer
step
correspond
directli
infer
elh
calculu
baader
brandt
lutz
proof
consid
elh
ontolog
transform
set
speciﬁ
section
consid
queri
form
due
form
queri
core
initialis
ﬁrst
consid
appli
algorithm
cautiou
strategi
eager
applic
hyper
rule
induct
applic
rule
tabl
next
show
context
claus
deriv
rule
form
core
context
form
particular
step
perform
follow
infer
speciﬁ
correspond
complet
rule
baader
brandt
lutz
core
context
form
core
rule
introduc
claus
form
form
correspond
hyper
rule
appli
type
claus
particip
infer
form
way
baader
brandt
lutz
initialis
map
result
form
infer
correspond
complet
rule
hyper
rule
appli
type
claus
particip
infer
form
result
form
moreov
function
symbol
occur
exactli
one
pair
claus
hyper
rule
appli
eagerli
thu
whenev
occur
context
claus
form
also
occur
claus
form
succ
rule
appli
function
symbol
case
cautiou
strategi
thu
return
context
whose
core
form
infer
correspond
complet
rule
hyper
rule
appli
type
two
claus
particip
infer
form
result
form
pred
rule
appli
latter
claus
produc
claus
form
pair
infer
correspond
complet
rule
hyper
rule
appli
type
claus
particip
infer
form
result
form
well
pred
rule
appli
latter
claus
produc
claus
form
pair
infer
correspond
complet
rule
one
show
analog
way
infer
calculu
baader
brandt
lutz
correspond
one
infer
calculu
furthermor
clear
algorithm
run
polynomi
time
next
consid
appli
algorithm
eager
strategi
one
show
core
context
form
context
contain
claus
form
proof
analog
case
caution
strategi
without
correspond
complet
rule
omit
detail
sake
breviti
minor
differ
applic
pred
context
introduc
claus
form
succ
rule
becom
applic
sinc
precondit
succ
rule
still
satisﬁ
thu
succ
rule
never
introduc
context
whose
core
contain
conjunct
binari
atom
thu
contain
unari
binari
predic
number
context
bound
context
contain
claus
rule
appli
polynomi
time
algorithm
run
polynomi
time
