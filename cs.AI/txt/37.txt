noname
manuscript
inserted
editor
multi-objective
reasoning
constrained
goal
models
chi
mai
nguyen
roberto
sebastiani
paolo
giorgini
john
mylopoulos
received
date
accepted
date
abstract
goal
models
widely
used
computer
science
represent
soft-
ware
requirements
business
objectives
design
qualities
existing
goal
modelling
techniques
however
shown
limitations
expressiveness
and/or
tractability
coping
complex
real-world
problems
work
exploit
advances
auto-
mated
reasoning
technologies
notably
satisﬁability
optimization
modulo
theo-
ries
smt/omt
propose
formalize
extended
modelling
language
goals
namely
constrained
goal
model
cgm
makes
explicit
no-
tion
goal
reﬁnement
domain
assumption
allows
expressing
preferences
goals
reﬁnements
allows
associating
numerical
attributes
goals
reﬁnements
deﬁning
constraints
optimization
goals
multi-
ple
objective
functions
reﬁnements
numerical
attributes
novel
set
automated
reasoning
functionalities
cgms
allowing
automatically
gen-
erating
suitable
reﬁnements
input
cgms
user-speciﬁed
assumptions
constraints
also
maximize
preferences
optimize
given
objective
functions
implemented
modelling
reasoning
functionalities
tool
named
cgm-tool
using
omt
solver
optimathsat
automated
reasoning
backend
moreover
conducted
experimental
evaluation
large
cgms
support
claim
proposal
scales
well
goal
models
thousands
elements
keywords
requirements
engineering
goal
models
sat/smt/omt
research
partially
supported
erc
advanced
grant
267856
lucretius
foundations
software
evolution
chi
mai
nguyen
e-mail
chimai.nguyen
unitn.it
roberto
sebastiani
e-mail
roberto.sebastiani
unitn.it
paolo
giorgini
e-mail
paolo.giorgini
disi.unitn.it
john
mylopoulos
e-mail
cs.toronto.edu
introduction
chi
mai
nguyen
concept
goal
long
used
useful
abstraction
many
areas
com-
puter
science
example
artiﬁcial
intelligence
planning
agent-based
systems
knowledge
management
recently
software
engineering
also
using
goals
model
requirements
software
systems
business
objectives
en-
terprises
design
qualities
2,3,11,42,18
goal-oriented
requirements
engineering
approaches
gained
popularity
number
signiﬁcant
beneﬁts
conceptualizing
analyzing
requirements
goal
models
provide
broader
system
engineering
perspective
compared
tradi-
tional
requirements
engineering
methods
precise
criterion
completeness
requirements
analysis
process
rationale
requirements
speciﬁcation
well
automated
support
early
requirements
analysis
moreover
goal
models
useful
explaining
requirements
stakeholders
goal
reﬁnements
offer
accessible
level
abstraction
validating
choices
among
alternative
designs
current
goal
modelling
reasoning
techniques
however
limitations
respect
expressiveness
and/or
scalability
among
leading
approaches
goal
mod-
elling
kaos
offers
expressive
modelling
language
reasoning
scal-
able
fact
undecidable
hand
missing
constructs
preferences
priorities
optimization
goals
although
recent
proposals
techne
22,26
offer
expressive
extensions
goal
models
still
lack
features
proposal
notably
optimization
goals
also
lack
scalable
reasoning
facilities
result
deﬁciencies
goal
modelling
framework
express
goals
select
new
requirements
implement
next
release
optimize
customer
value
maintaining
costs
threshold
able
reason
generate
speciﬁcation/solution
another
example
consider
situation
goal
model
changes
new
speciﬁcation/solution
needs
generated
new
goal
model
case
new
speciﬁcation
may
required
fulﬁll
evolution
goal
minimize
implementation
effort
maximize
user
familiarity
changing
little
possible
new
functionality
system
relative
old
one
latter
case
see
also
cases
dealing
requirements
beyond
state-of-the-art
goal
modelling
reasoning
discuss
proposal
accommodate
requirements
respect
modelling
scalable
reasoning
interested
advancing
state-of-the-art
goal
models
reasoning
proposing
expressive
modelling
languages
encompasses
many
modelling
constructs
proposed
literature
time
offers
sound
complete
tractable
reasoning
facilities
aiming
goal
modelling
lan-
guage
spirit
sebastiani
rather
social
dependencies
mod-
elling
language
accomplish
exploit
advances
automated
reasoning
technologies
notably
satisﬁability
modulo
theories
smt
opti-
mization
modulo
theories
omt
propose
formalize
extended
notion
goal
model
namely
constrained
goal
model
cgm
cgms
treat
and/or
reﬁnements
ﬁrst
class
citizens
allowing
associated
con-
straints
boolean
formulas
smt/omt
formulas
instance
mod-
multi-objective
reasoning
constrained
goal
models
elling
meeting
scheduling
system
may
want
express
fact
fulﬁll
nice-to-have
requirement
keeping
scheduling
fast
enough
e.g.
strictly
less
hours
afford
time-consuming
tasks
performing
schedule
manually
hours
calling
participant
one-by-one
phone
hours
cgms
provide
user-friendly
constructs
encode
constraints
like
either
adding
boolean
formulas
propositions
label
requirement
tasks
associating
propositions
numerical
variables
adding
smt
formulas
encoding
mixed
boolean-arithmetical
constraints
variables
propositions
see
best
knowledge
possible
previous
goal
modelling
techniques
including
time
cgm
tool
developed
cope
goal
models
order
magnitude
beyond
reported
literature
cases
cases
involving
optimization
goals
e.g.
minimize
development
costs
next
release
software
product
cgm
tool
performs
modestly
still
handle
models
size
hundreds
elements
main
contributions
work
include
integration
within
one
modelling
framework
constructs
proposed
literature
piecemeal
fashion
speciﬁcally
allow
explicit
labelling
goal
reﬁnements
boolean
propositions
interactively/automatically
reasoned
upon
provide
explicit
representation
domain
assumptions
represent
pre-
iii
allow
boolean
constraints
goals
domain
assumptions
reﬁne-
conditions
goals
ments
provide
representation
preferences
goals
reﬁnements
distinguishing
mandatory
nice-to-have
requirements
assigning
preference
weights
i.e.
penalties/rewards
goals
do-
main
assumptions
alternatively
preferences
expressed
explicitly
setting
binary
preference
relations
pairs
goals
pairs
reﬁnements
assign
numerical
attributes
e.g.
resources
like
cost
worktime
room
goals
and/or
reﬁnements
deﬁne
constraints
multiple
objective
functions
goals
reﬁnements
numerical
attributes
deﬁne
optimization
goals
numerical
attributes
cost
cus-
tomer
value
fully
support
automated
reasoning
cgms
sound
complete
i.e.
returns
solutions
consistent
cgm
semantics
solutions
iii
establish
reasoning
cgm
models
scalable
models
including
thousands
elements
taking
advantage
cgms
formal
semantics
expressiveness
efﬁciency
current
smt
omt
solvers
also
provide
set
automated
reasoning
functionalities
cgms
speciﬁcally
given
cgm
approach
allows
automatic
check
cgm
realizability
i.e.
check
goal
model
solution
chi
mai
nguyen
interactive/automatic
search
realizations
automatic
search
best
realization
terms
penalties/rewards
and/or
automatic
search
realization
optimize
given
objective
func-
user-deﬁned
preferences
tions
approach
implemented
tool
cgm-tool
standalone
java
application
based
eclipse
rcp
engine
tool
offers
functionalities
create
cgm
mod-
els
graphical
diagrams
explore
alternatives
scenarios
running
automated
reasoning
techniques
cgm-tool
uses
smt/omt
solver
optimathsat
38,40
built
top
smt
solver
mathsat5
automated
reasoning
backend
structure
paper
follows
provides
succinct
account
nec-
essary
background
goal
modelling
smt/omt
introduces
notion
cgm
example
introduces
syntax
semantics
cgms
presents
set
automated
reasoning
functionalities
cgms
gives
quick
overview
tool
based
presented
approach
provides
experimental
evaluation
performances
tool
large
cgms
showing
approach
scales
well
respect
cgm
size
gives
overview
related
work
draw
conclusions
present
future
research
challenges
background
research
baseline
consists
previous
work
qualitative
goal
models
satisﬁability
optimization
modulo
theories
smt
omt
respectively
aim
section
introduce
necessary
background
notions
top-
ics
reader
follow
narrative
subsequent
sections
prerequisite
knowledge
assume
reader
familiar
syntax
semantics
standard
boolean
logic
linear
arithmetic
rationals
2.1
goal
models
qualitative
goal
models
introduced
concept
goal
used
represent
respectively
functional
non-functional
requirement
terms
proposition
goal
reﬁned
means
and/or
reﬁnement
relationships
qualitative
evidence
strong
weak
for/against
fulﬁllment
goal
provided
contribution
links
labelled
etc
goal
models
formalized
replacing
proposition
standing
goal
four
propositions
representing
full
partial
evidence
satisfaction/denial
traditional
implication
translated
series
implications
connecting
new
symbols
including
sp∧f
sp∧
well
etc
conﬂict
omt
solver
optimathsat
used
also
smt
solver
objective
function
set
case
works
wrapper
mathsat5
multi-objective
reasoning
constrained
goal
models
goals
captured
axioms
form
consistent
evaluated
true
time
result
even
though
semantics
goal
model
classical
propositional
theory
inconsistency
result
everything
true
fact
predicate
assigned
subset
truth
values
extended
approach
including
axioms
avoiding
conﬂicts
form
sa∧
approach
recognized
need
formalize
goal
models
automatically
evaluate
satisﬁability
goals
goal
models
however
incorporate
notion
conﬂict
inconsistency
include
concepts
goals
distinguish
nice-to-have
mandatory
requirements
notion
robust
solution
i.e
solution
without
conﬂict
goal
fully
partially
denied
respectively
fully
partially
satisﬁed
time
2.2
satisﬁability
optimization
modulo
theories
satisﬁability
modulo
theories
smt
problem
deciding
satisﬁability
quantiﬁer-free
ﬁrst-order
formula
respect
decidable
theory
see
35,5
paper
focus
theory
linear
arithmetic
ratio-
nals
lra
smt
lra
problem
checking
satisﬁability
formula
consisting
atomic
propositions
...
linear-arithmetic
constraints
ra-
tional
variables
like
2.1x1−3.4x2+3.2x3
4.2
combined
means
boolean
operators
notice
boolean
formula
also
smt
lra
for-
mula
vice
versa
lra-interpretation
function
assigns
truth
values
boolean
atoms
rational
values
numerical
variables
satisﬁes
lra
written
–aka
solution
lra–
iff
makes
formula
evaluate
true
lra-satisﬁable
iff
least
one
lra-interpretation
s.t
problem
ﬁnding
solution
smt
lra
formula
optimize
rational-valued
objective
functions
obj1
...
objk
either
singularly
lexicographi-
cally
31,37,38,40
solution
optimizes
lexicographically
cid:104
obj1
...
objk
cid:105
op-
timizes
obj1
one
obj1-optimum
solutions
exists
also
opti-
mizes
obj2
...
efﬁcient
smt
lra
omt
lra
solvers
available
com-
bine
power
modern
sat
solvers
dedicated
linear-programming
decision
minimization
procedures
see
35,5,8,31,37,38,40,39
instance
em-
pirical
evaluation
reported
omt
lra
solver
optimathsat
38,39
able
handle
optimization
problems
thousands
boolean/rational
variables
less
minutes
optimization
modulo
theories
lra
omt
lra
problem
cid:104
cid:104
obj1
...
objk
cid:105
cid:105
constrained
goal
models
narrative
next
sections
line
following
schema
chi
mai
nguyen
fig
example
cgm
one
realizations
elsewhere
round-corner
rectangles
requirements
ovals
intermediate
goals
hexagons
tasks
rectangles
domain
assumptions
labeled
bullets
merging
point
group
edges
reﬁnements
contribution
edges
labeled
conﬂict
edges
labeled
reﬁnement
bindings
edges
reﬁnements
values
numerical
attributes
associated
elements
positive
prerequisite
formulas
written
respective
elements
realization
highlighted
yellow
denied
elements
visible
highlighted
multi-objective
reasoning
constrained
goal
models
fig
cgm
realization
minimized
weight
realization
highlighted
yellow
denied
elements
visible
highlighted
chi
mai
nguyen
fig
cgm
realization
minimized
lexicographically
cid:104
weight
worktime
cost
cid:105
min-
imized
lexicographically
cid:104
weight
numunsatprefs
cid:105
realization
highlighted
yellow
denied
elements
visible
highlighted
multi-objective
reasoning
constrained
goal
models
section
introduce
notions
constrained
goal
model
cgm
realization
cgm
also
present
automated-reasoning
functionalities
cgm-tool
meeting
scheduling
example
figure
without
getting
formal
details
yet
present
abstract
syntax
semantics
cgms
deﬁning
formally
building
blocks
cgm
realizations
reader
already
introduced
informally
describe
support
automated
reasoning
functionalities
cgms
encoding
smt
omt
ﬁrst
show
encode
cgm
smt
lra
formula
search
optimum
realization
reduces
omt
lra
problem
formula
fed
omt
solver
present
reasoning
functionalities
cgms
implemented
top
omt
solver
3.1
cgm
backbone
goals
reﬁnements
domain
assumptions
model
requirements
meeting
scheduling
system
including
func-
tional
requirement
schedulemeeting
well
non-functional/quality
requirements
lowcost
fastschedule
minimaleﬀort
goodqualityschedule
repre-
sented
root
goals
notationally
round-corner
rectangles
e.g.
schedulemeeting
root
goals
rep-
resenting
stakeholder
requirements
ovals
e.g
collecttimetables
intermediate
goals
hexagons
e.g
characterisemeeting
tasks
i.e
non-root
leaf
goals
rect-
angles
e.g.
participantsusesystemcalendar
domain
assumptions
call
el-
ements
goals
domain
assumptions
labeled
bullets
merging
point
edges
connecting
group
source
elements
target
element
reﬁnements
e.g.
goodparticipation
minimalconﬂict
r20−−→
goodqualityschedule
ris
denote
labels
remark
unlike
previous
goal
modelling
proposals
reﬁnements
explicitly
la-
beled
stakeholders
refer
relations
constraints
preferences
fact
eventually
discussed
details
label
reﬁnement
omitted
need
refer
explicitly
intuitively
requirements
represent
desired
states
affairs
want
system-
to-be
achieve
either
mandatorily
preferrably
progressively
reﬁned
intermediate
goals
process
produces
actionable
goals
tasks
need
decomposition
executed
domain
assumptions
propositions
domain
need
hold
goal
reﬁnement
work
reﬁnements
used
represent
alternatives
achieve
non-leaf
element
i.e.
reﬁnement
element
represents
one
alternative
sub-elements
necessary
achieve
principal
aim
cgm
figure
achieve
requirement
schedulemeeting
mandatory
requirement
set
mandatory
means
user
asser-
tions
see
schedulemeeting
one
candidate
reﬁnement
consist-
ing
ﬁve
sub-goals
characterisemeeting
collecttimetables
findasuitableroom
chi
mai
nguyen
chooseschedule
managemeeting
since
reﬁnement
re-
quirement
sub-goals
must
satisﬁed
order
satisfy
may
one
way
reﬁne
element
e.g.
collecttimetables
reﬁned
either
r10
single
goal
byperson
single
goal
bysystem
similarly
findasuitableroom
chooseschedule
three
two
possible
re-
ﬁnements
respectively
subgoals
reﬁned
reach
level
domain
assumptions
tasks
requirements
set
mandatory
nice-to-have
ones
like
lowcost
minimaleﬀort
fastschedule
goodqualityschedule
blue
fig-
ure
requirements
would
like
fulﬁll
solution
provided
conﬂict
requirements
3.2
boolean
constraints
relation
edges
boolean
formulas
user
assertions
importantly
cgm
elements
reﬁnements
enriched
user-deﬁned
boolean
constraints
expressed
either
graphically
relation
edges
textually
boolean
smt
lra
formulas
user
assertions
++−−→
relation
edges
three
kinds
relation
edges
contribution
edges
elements
green
figure
like
scheduleautomatically
++−−→
minimalconﬂicts
mean
source
element
satisﬁed
also
target
−−←→
be-
element
must
satisﬁed
vice
versa
conﬂict
edges
−−←→
cancelmeeting
mean
tween
elements
red
like
conﬁrmoccurrence
satisﬁed
reﬁnement
bindings
ri←→rj
two
reﬁnements
purple
like
r2←→r7
used
state
target
elements
two
reﬁnements
respectively
satisﬁed
reﬁned
reﬁned
intuitively
means
two
reﬁnements
bound
two
different
instances
global
choice
instance
figure
reﬁnements
bound
binding
reﬂects
global
choice
manual
approach
automated
one
boolean
formulas
possible
enrich
cgms
boolean
formulas
represent-
ing
arbitrary
constraints
elements
reﬁnements
constraints
either
global
local
elements
reﬁnements
goal
tagged
cid:9
–called
positive
negative
prerequisite
pair
prerequisite
formulas
cid:8
formulas
respectively–
resp
denied
holds
requirement
must
satisﬁed
satisﬁed
example
require
prerequisite
fastschedule
schedulemanually
callparticipants
satisﬁed
one
add
constraint
positive
prerequisite
formula
fastschedule
resp
fastschedule
def=
...
schedulemanually
callparticipants
equivalently
add
globally
cgm
following
boolean
formula
fastschedule
schedulemanually
callparticipants
multi-objective
reasoning
constrained
goal
models
notice
way
express
relation
edges
user
assertions
cgm-tool
one
interactively
mark
unmark
require-
ments
satisﬁed
true
thus
making
mandatory
unmarked
nice-to-
ones
example
schedulemeeting
asserted
true
make
mandatory
equivalent
add
globally
cgm
unary
boolean
constraint
schedulemeeting
similarly
one
interactively
mark/unmark
effortful
tasks
denied
false
generally
one
mark
satisﬁed
denied
every
goal
domain
assumption
call
marks
user
assertions
correspond
asserting
element
must
true
i.e.
part
solutions
interested
false
i.e.
interested
solutions
include
notice
process
marking/unmarking
elements
conceived
interactive
adding/dropping
relation
edges
constraints
3.3
arithmetical
constraints
numerical
attributes
smt
lra
formulas
numerical
attributes
addition
boolean
constraints
also
possible
use
numerical
variables
express
different
numerical
attributes
elements
cost
worktime
space
fuel
etc
add
arithmetical
constraints
form
smt
lra
formulas
numerical
variables
example
suppose
estimate
fulﬁlling
usepartnerinstitutions
costs
80ac
whereas
fulﬁlling
usehotelsandconventioncenters
costs
200ac
cgm-
tool
one
express
facts
straightforwardly
adding
global
numerical
vari-
able
cost
model
every
element
cgm
cgm-tool
automatically
generates
nu-
merical
variable
coste
representing
attribute
cost
element
adds
following
defaultglobal
constraint
prerequisite
formulas
cid:88
cost
coste
every
element
def=
...
coste
def=
...
coste
set
default
value
coste
notice
default
global
con-
straint
user
free
deﬁne
his/her
objective
functions
eventually
elements
interest
one
set
new
value
coste
case
satisﬁed
e.g.
costusepartnerinstitutions
80ac
costusehotelsandconventioncenters
200ac
cgm-tool
automatically
updates
values
positive
prerequisite
formulas
e.g
usepartnerinstitutions
usehotelsandconventioncenters
def=
...
costusepartnerinstitutions
def=
...
costusehotelsandconventioncenters
200
chi
mai
nguyen
whereas
corresponding
constraint
changed
similarly
one
set
new
value
coste
case
denied
updating
values
negative
prerequisite
formulas
remark
notationally
use
variables
formulas
indexed
element
belong
like
e.g.
costusepartnerinstitutions
usepartnerinstitutions
rather
at-
tribute
variables
formulas
elements
object-oriented
notation
like
e.g.
usepartnerinstitutions.cost
usepartnerinstitutions.φ+
suitable
used
within
smt
lra
encodings
smt
lra
formulas
suppose
order
achieve
nice-to-have
require-
ment
lowcost
need
total
cost
smaller
100ac
expressed
adding
lowcost
prerequisite
formula
lowcost
cost
100
hence
e.g.
due
lowcost
usehotelsandconventioncenters
satisﬁed
matching
intuition
latter
expensive
comply
nice-to-have
lowcost
requirement
similarly
cost
one
introduce
e.g.
another
global
numerical
attribute
worktime
reason
working
time
estimate
e.g.
total
working
time
schedulemanually
scheduleautomatically
emailparticipants
callparticipants
collectfromsystemcalendar
hour
respectively
state
nice-to-have
requirement
fastschedule
must
require
global
time
smaller
hours
result
process
system
produce
following
constraints
cid:88
worktime
worktimee
fastschedule
schedulemanually
scheduleautomatically
emailparticipants
callparticipants
collectfromsystemcalendar
def=
...
worktime
def=
...
worktimeschedulemanually
def=
...
worktimescheduleautomatically
def=
...
worktimeemailparticipants
def=
...
worktimecallparticipants
def=
...
worktimecollectfromsystemcalendar
plus
corresponding
negative
prerequisite
formula
force
corresponding
numerical
attributes
zero
previous
case
e.g.
arithmetic
constraints
make
combina-
tion
schedulemanually
callparticipants
incompatible
nice-to-have
requirement
fastschedule
35ac/hour
one
redeﬁne
cost
cost
cid:80
notice
one
build
combinations
numerical
attributes
e.g.
labor
cost
coste
worktime
introduce
new
global
variable
totalcost
totalcost
cost
worktime
multi-objective
reasoning
constrained
goal
models
remark
although
nice-to-have
requirements
lowcost
fastschedule
look
isolated
figure
implicitly
linked
rest
cgm
means
arithmetic
constraints
numerical
variables
cost
worktime
respectively
implicitly
imply
boolean
constraints
like
lowcost
¬usehotelsandconventioncenters
fastschedule
schedulemanually
callparticipants
schedulemanually
emailparticipants
collectfromsystemcalendar
fastschedule
...
nevertheless
need
stakeholders
consider
implicit
constraints
since
automatically
handled
internal
omt
lra
reasoning
capabil-
ities
cgm-tool
3.4
realizations
cgm
suppose
schedulemeeting
marked
satisﬁed
means
user
as-
sertion
i.e
mandatory
element
marked
cgm
figure
possible
realizations
sub-graph
highlighted
yellow
describes
one
intuitively
realization
cgm
given
user
assertions
represents
one
alternative
ways
reﬁning
mandatory
requirements
plus
possibly
nice-to-have
ones
compliance
user
assertions
user-deﬁned
constraints
sub-graph
cgm
including
set
satisﬁed
elements
reﬁnements
includes
mandatory
requirements
resp
include
elements
satisﬁed
resp
denied
user
assertions
non-leaf
element
included
least
one
reﬁnement
included
reﬁnement
included
target
elements
included
ﬁnally
realization
complies
relation
edges
boolean
smt
lra
constraints
notationally
figures
realization
highlighted
yellow
denied
elements
visible
highlighted
apart
mandatory
requirement
realization
figure
allows
achieve
also
nice-to-have
requirements
lowcost
goodqualityschedule
fastschedule
minimaleﬀort
order
requires
accomplishing
tasks
characterisemeeting
callparticipants
listavailablerooms
useavailableroom
schedulemanually
conﬁrmoccurrence
goodparticipation
minimalconﬂicts
requires
domain
assumption
localroomavailable
3.5
setting
preferences
cgm
general
cgm
given
user
assertions
many
possible
realizations
distinguish
among
stakeholders
may
want
express
preferences
re-
chi
mai
nguyen
quirements
achieve
tasks
accomplish
elements
reﬁnements
choose
cgm-tool
provides
various
methods
express
preferences
attribute
penalties
rewards
tasks
requirements
introduce
numerical
objectives
optimize
introduce
binary
preference
relations
elements
reﬁnements
methods
described
follows
also
combined
preferences
via
penalties/rewards
first
stakeholders
deﬁne
two
numerical
at-
tributes
called
penalty
reward
stakeholders
assign
penalty
values
tasks
reward
values
non-mandatory
requirements
numbers
penalty
reward
figure
implies
requirements
resp
tasks
higher
rewards
resp
smaller
penalties
preferable
next
stakeholders
deﬁne
another
numerical
attribute
weight
represents
total
difference
penalties
rewards
deﬁned
global
constraint
weight
penalty
rewards
model
represents
preferences
omt
solver
look
realization
minimizes
global
weight
instance
one
minimum-
weight
realization
example
cgm
shown
figure
achieves
nice-
to-have
requirements
except
minimaleﬀort
total
weight
−65
minimum
achieved
cgm
realization
requires
accom-
plishing
tasks
characterisemeeting
emailparticipants
usepartnerinstitution
schedulemanually
conﬁrmoccurrence
goodparticipation
minimalconﬂicts
requires
domain
assumption
found
automatically
cgm-
tool
0.008
seconds
apple
macbook
air
laptop
preferences
via
multiple
objectives
stakeholders
may
deﬁne
rational-valued
ob-
jectives
obj1
...
objk
optimize
i.e.
maximize
minimize
functions
boolean
numerical
variables
—e.g.
cost
worktime
totalcost
suitable
objectives—
ask
tool
automatically
generate
realization
optimize
one
objective
combination
objectives
like
totalcost
optimizes
lexico-
graphically
ordered
list
objectives
cid:104
obj1
obj2
...
cid:105
recall
solution
optimizes
lexicographically
ordered
list
objectives
cid:104
obj1
obj2
...
cid:105
makes
obj1
optimum
one
solution
exists
makes
also
obj2
optimum
...
etc
notice
lexicographic
optimization
allows
deﬁning
objective
functions
ﬁne-grained
way
preventing
ties
stakeholder
wants
prevent
tie
solutions
objective
obj1
he/she
deﬁne
one
preference
criterion
obj2
case
tie
obj1
importantly
cgm-tool
provides
pre-deﬁned
objectives
frequent
us-
age
weight
see
last
paragraph
one
examples
pre-deﬁned
ob-
jectives
stakeholders
may
want
minimize
either
singularly
combination
objectives
numunsatrequirements
number
nice-to-have
requirements
in-
cluded
realization
numsattasks
number
tasks
included
realization
numunsatprefs
number
user-deﬁned
binary
preference
relations
fulﬁlled
realization
see
later
multi-objective
reasoning
constrained
goal
models
example
previously-mentioned
optimum-weight
realization
figure
weight
−65
worktime
cost
80.
cgm
many
dif-
ferent
minimum-weight
realizations
s.t
weight
−65
different
values
cost
worktime
among
possible
search
e.g.
realizations
minimum
worktime
among
minimum
cost
setting
lex-
icographic
minimization
order
cid:104
weight
worktime
cost
cid:105
results
one
realization
weight
−65
worktime
cost
achieving
nice-
to-have
requirements
shown
figure
requires
accomplishing
tasks
characterisemeeting
collectfromsystemcalendar
getroomsuggestions
cancellessimportantmeeting
scheduleautomatically
conﬁrmoccurrence
goodparticipation
minimalconﬂicts
collectioneﬀort
matchingeﬀort
requires
domain
assumptions
participantsusesystemcalendar
localroomavailable
found
automatically
cgm-tool
0.016
sec-
onds
apple
macbook
air
laptop
preferences
via
binary
preference
relations
general
stakeholders
might
al-
ways
ease
assigning
numerical
values
state
preferences
dealing
smt
lra
terms
constraints
objectives
thus
coarse-grained
user-friendly
solution
also
possible
stakeholders
express
prefer-
ences
direct
way
stating
explicitly
list
binary
preference
relations
denoted
cid:23
pairs
elements
kind
e.g
pair
requirements
tasks
domain
assumptions
pairs
reﬁnements
cid:23
means
one
prefers
satisﬁed
satisﬁed
he/she
would
rather
avoid
denied
satisﬁed
latter
case
say
pref-
erence
unsatisﬁed
notice
cid:23
allows
satisﬁed
denied
remark
binary
preferences
say
nothing
fact
singularly
desirable
case
must
stated
separately
e.g.
penalties/rewards
thus
fact
binary
preference
cid:23
allows
denied
surprise
alse
true
alse
alse
violated
cid:23
would
play
role
preference
would
reduce
unary
preference
rather
it.
dual
argument
holds
fact
cid:23
allows
satisﬁed
also
choice
general
one
since
implements
case
cid:104
cid:105
desirable/rewarding
prefer
winning
turing
award
win-
ning
lottery.
like
preference
two
requirements
well
opposite
case
undesirable/expensive
prefer
shot
hanged.
like
preference
two
tasks
plus
obviously
trivial
case
desirable
undesirable
choice
considered
general
stakeholder
add
mutual-exclusion
constraints
combine
lexicograph-
ically
penalty/rewards
directly
use
penalty/rewards
instead
cgm-tool
binary
preference
relations
expressed
either
graphically
prefer−→
via
ad-hoc
menu
window
list
via
prefer
arc
binary
preference
relations
set
system
asked
consider
number
unsatisﬁed
preference
relations
pre-deﬁned
objective
namely
numunsatprefs
chi
mai
nguyen
searches
realization
minimizes
also
possible
combine
objective
lexicographically
objectives
one
typical
usage
envision
binary
preferences
pairs
reﬁne-
ments
element
–or
equivalently
case
single-source
reﬁnements
relative
source
elements
allows
expressing
stakeholders
pref-
erences
possible
ways
one
intermediate
element
reﬁned
example
suppose
want
minimize
total
weight
example
goal
model
previously
mentioned
one
realization
mini-
mum
weight
−65
unlike
previous
example
secondary
choice
disregard
worktime
cost
rather
express
also
following
binary
preferences
bysystem
cid:23
byperson
uselocalroom
cid:23
usepartnerinstitutions
uselocalroom
cid:23
usehotelsandconventioncenters
notice
goal
preferences
pairwise
equivalent
following
reﬁnement
preferences
cid:23
r10
cid:23
cid:23
reﬁnements
single-source
ones
whose
sources
pairwise
goals
set
numunsatprefs
secondary
objective
minimize
weight
set
lexicographic
order
cid:104
weight
numunsatprefs
cid:105
tool
re-
turned
realization
figure
—that
minimizing
worktime
cost
secondary
tertiary
choice—
instead
figure
solution
found
0.018
seconds
apple
macbook
air
laptop
abstract
syntax
semantics
section
describe
formally
abstract
syntax
semantics
cgms
4.1
abstract
syntax
introduce
ﬁrst
general
deﬁnitions
call
goal
graph
directed
acyclic
graph
dag
alternating
element
nodes
reﬁnement
nodes
collapsed
bullets
s.t
element
zero
many
outgoing
edges
distinct
reﬁnements
zero
many
incoming
edges
distinct
reﬁnements
reﬁnement
node
exactly
one
outgoing
edge
element
target
one
incoming
edges
distinct
elements
sources
call
root
element
node
element
node
outgoing
reﬁnement
edges
leaf
element
node
non-root
element
node
incoming
reﬁne-
ment
edges
internal
element
node
element
node
hereafter
usually
drop
word
node
simply
saying
reﬁnement
reﬁnement
node
element
element
node
etc
multi-objective
reasoning
constrained
goal
models
table
summary
goal
model
structure
constructor
textual
representation
graphical
representation
propositional
encoding
cid:0
cid:1
r−→
goal
reﬁnement
pref
closed
world
contribution
conﬂict
++−−→
−−←→
preferences
cid:23
cid:86
j=1
cid:0
cid:87
cid:1
ri∈ref
cid:0
cid:1
¬e2
notice
construction
elements
roots
leaves
goal
graph
sets
root
leaf
internal
elements
goal
graph
denoted
roots
leaves
internals
respectively
given
reﬁnement
outgo-
ing
edge
element
incoming
edges
element
call
source
elements
target
element
denoted
sources
target
respectively
say
reﬁnement
reﬁnes
denoted
r−→
set
reﬁnements
element
denoted
reﬁnements
elements
goals
domain
assumptions
subject
following
rules
domain
assumption
root
element
target
reﬁnement
domain
assumption
sources
domain
assumptions
target
reﬁnement
goal
least
one
sources
goal
call
root
goals
leaf
goals
requirements
tasks
respectively
notationally
use
symbols
labeling
reﬁnements
generic
elements
without
specifying
goals
domain
assumptions
goals
domain
assumptions
graphically
see
figure
collapse
reﬁnements
nodes
one
bullet
see
reﬁnement
aggregation
edges
set
goals
see
table
hence
goal
graph
consider
element
nodes
nodes
reﬁnements
aggregations
edges
group
source
elements
target
element
chi
mai
nguyen
deﬁnition
constrained
goal
model
constrained
goal
model
cgm
tuple
def=
cid:104
cid:105
s.t
def=
set
atomic
propositions
def=
...
def=
...
def=
...
respectively
sets
goal
reﬁnement
domain-assumption
labels
denote
set
element
labels
def=
g∪a
set
numerical
variables
rationals
goal
graph
s.t
goal
nodes
univocally
labeled
goal
label
reﬁnements
univocally
labelled
reﬁnement
label
domain
assumption
univocally
labeled
assumption
label
smt
lra
formula
cgm
thus
backbone
goal
graph
–i.e.
and-or
directed
acyclic
graph
dag
elements
nodes
reﬁnements
grouped
edges
labeled
atomic
propositions
augmented
smt
lra
formula
element
reﬁnement
labels
numerical
variables
smt
lra
formula
conjunction
smaller
formulas
encoding
relation
edges
global
local
boolean/smt
lra
constraints
user
assertions
deﬁnition
numerical
objectives
described
later
section
intuitively
cgm
describes
possibly
complex
combination
alternative
ways
realizing
set
requirements
terms
set
tasks
certain
domain
assumptions
constraints
couple
remarks
order
remark
fact
goal
graph
and-or
graph
deduced
propositional
encoding
goal
reﬁnement
closed
world
table
combin-
ing
propositional
encodings
goal
reﬁnement
closed
world
table
infer
formulas
cid:95
cid:94
thus
non-leaf
element
or-decomposed
set
incoming
reﬁne-
ments
reﬁnement
and-decomposed
set
source
elements
remark
cgms
succinct
terms
number
goals
standard
and-or
goal
models
one
hand
standard
n-ary
and-decomposition
goal
represented
straightforwardly
cgm
one
reﬁnement
sources
figure
top
or-decomposition
one-source
reﬁnements
figure
middle
extra
goals
added
hand
order
represent
piece
cgm
non-unary
reﬁnements
standard
goal
models
need
introducing
new
auxiliary
intermediate
goals
encode
reﬁnements
cgms
encode
natively
figure
bottom
recall
reﬁnements
need
explicitly
recall
boolean
logic
formula
cid:86
labeled
unless
need
mentioned
parts
model
encoding
table
equivalent
cid:87
world
cid:87
comes
goal
reﬁnement
latter
combined
encoding
closed
gives
left
formula
right
formula
part
goal
reﬁnement
encoding
table
multi-objective
reasoning
constrained
goal
models
cid:48
cid:48
cid:48
cid:48
cid:48
g11
g12
g21
g22
g11
g12
g21
g22
fig
top
and-decomposition
translation
cgm
format
single
multi-source
reﬁnement
middle
or-decomposition
translation
cgm
format
multiple
single-source
reﬁnements
bottom
simple
piece
cgm
right
translation
standard
and-or
goal
model
format
left
necessary
introduce
two
auxiliary
goals
cid:48
cid:48
cid:48
encode
reﬁnements
stakeholders
might
ease
deﬁning
possibly-complex
global
smt
lra
las
cid:8
cid:9
cid:8
formula
encode
constraints
among
elements
reﬁnements
plus
numerical
variables
extent
mentioned
apart
possibility
deﬁning
global
formulas
cgms
provide
constructs
allowing
user
encode
graphically
locally
desired
constraints
frequent
usage
relation
edges
prerequisite
formu-
simple
smt
lra
formula
follows
conjoined
element-contribution
edges
cid:9
user
assertions
automatically
converted
++−−→
meaning
satisfying
forces
satisﬁed
vice
versa
encoded
formula
++←→
used
denote
merging
two
contribution
edge
++−−→
one
edges
−−←→
meaning
satis-
element-conﬂict
edges
ﬁed
encoded
formula
reﬁnement-binding
edges
r1←→r2
meaning
target
goals
namely
respectively
satisﬁed
reﬁnes
reﬁnes
encoded
formula
user
assertions
cid:62
encoded
formulas
¬ej
++−−→
prerequisite
formulas
cid:8
respectively
cid:9
resp
cid:8
resp
cid:9
encoded
formulas
ororandandwith
standard
goal
modelsand−or
decomposition
cgmsand−or
decompositionand
cid:88
cid:88
chi
mai
nguyen
following
instead
encoded
smt
lra
soft
constraints
preference
edges
prefer−→
resp
def=
¬e2
resp
φr1
cid:23
prefer−→
equivalent
binary
prefer-
ence
relations
cid:23
resp
cid:23
implemented
soft
constraint
def=
¬r2
see
also
remark
φe1
cid:23
§3.5
notice
resp
must
kind
i.e
must
tasks
requirements
reﬁnements
intermediate
goals
domain
assumptions
unlike
constraints
soft
constraints
added
directly
rather
following
smt
lra
constraint
deﬁnes
numeric
pseudo-
boolean
cost
function
added
numunsatprefs
ite
φei
cid:23
ite
φri
cid:23
cid:104
eiej
cid:105
cid:104
rirj
cid:105
list
binary
preference
relations
ite
denotes
if-
then-else
arithmetical
term
evaluated
evaluated
true
otherwise
hence
numunsatprefs
counts
number
unsatisﬁed
preferences
number
binary
preferences
cid:23
s.t
false
true
notice
unlike
reﬁnements
relation
edges
preference
edges
allowed
create
loops
possibly
involving
reﬁnements
fact
reﬁnements
acyclic
be-
cause
represent
and-or
decomposition
dag
cgm
requirements
arcs
formulas
represent
relations
constraints
among
elements
free
form
loops
even
reﬁnements
finally
provide
user
list
syntactic-sugaring
constructs
al-
low
deﬁning
globally
locally
standard
intuitive
con-
straints
among
assumption
goal
reﬁnement
labels
need
deﬁning
corresponding
complicate
less-intuitive
propositional
formulas
follows
...
denote
atomic
propositions
alt
denotes
fact
alternative
e.g.
one
one
requires
denotes
fact
satisfying
requires
satisﬁed
causes
denotes
fact
satisfying
causes
satisﬁed
satisﬁed
encoded
formula
¬p2
encoded
formula
encoded
formula
constraint
programming
related
disciplines
e.g
maxsat
maxsmt
omt
constraints
must
satisﬁed
called
hard
whereas
constraints
preferably
satisﬁed
safely
violated
although
paying
penalty
called
soft
practice
omt
solver
optimathsat
provides
efﬁcient
ad-hoc
encodings
soft
constraints
like
exploited
implementation
cgm-tool
refer
reader
details
notice
relation
edge
++−−→
boolean
constraints
causes
requires
equivalent
perspective
boolean
semantics
never-
theless
stakeholders
may
use
different
contexts
e.g.
causes
used
event
occurs
former
causes
latter
whereas
requires
used
occurs
former
requires
latter
prerequisite
satisﬁed
encoded
formula
cid:0
cid:86
satisﬁed
encoded
formula
cid:0
cid:87
multi-objective
reasoning
constrained
goal
models
atmostoneof
...
denotes
fact
one
...
must
atleastoneof
...
denotes
fact
least
one
...
must
oneof
...
denotes
fact
exactly
one
...
must
sat-
1≤i
j≤n
¬pi
¬pj
cid:1
1≤i≤n
cid:1
isﬁed
encoded
conjunction
previous
two
formulas
4.2
semantics
semantics
cgms
formally
deﬁned
terms
semantics
simple
boolean
expressions
follows
deﬁnition
realization
cgm
let
def=
cid:104
cid:105
cgm
real-
ization
lra-interpretation
i=1
reﬁnement
cid:0
ri∈ref
cid:1
non-leaf
element
cid:86
cid:0
cid:87
say
realizable
least
one
realization
unrealizable
otherwise
alternatively
equivalently
substituted
conditions
cid:1
r−→
cid:48
cid:86
cid:48
cid:0
cid:87
i=1
reﬁnement
cid:0
cid:1
r−→
ri∈ref
cid:1
non-leaf
element
reveal
and-or
structure
recall
remark
footnote
realization
cgm
def=
cid:104
cid:105
element
reﬁne-
ment
either
satisﬁed
denied
i.e.
label
assigned
true
false
respectively
numerical
value
assigned
rational
value
rep-
resented
graphically
sub-graph
includes
satisﬁed
elements
reﬁnements
include
denied
elements
reﬁnements
example
consider
realization
highlighted
yellow
figure
cost
coste
every
element
deﬁnition
realization
represents
sub-graph
cgm
reﬁnement
part
source
elements
also
included
moreover
part
also
target
element
part
see
e.g.
reﬁnement
schedulemeeting
source
goals
non-leaf
goal
realization
sub-graph
least
one
reﬁnements
included
realization
see
e.g.
reﬁnement
findasuitableroom
realization
complies
boolean
smt
lra
constraints
cgm
including
relational
edges
global
local
formulas
user
assertions
deﬁnitions
numerical
attributes
objectives
particular
++−−→
see
e.g.
contribution
edge
bysystem
++−−→
collectioneﬀort
chi
mai
nguyen
−−←→
collectioneﬀort
−−←→
part
see
e.g.
conﬂict
edge
byperson
r1←→r2
target
goals
part
realization
see
e.g.
binding
r16←→r17
user
assertions
marked
satisﬁed
resp
denied
resp
part
realization
see
e.g.
requirement
schedulemeeting
mandatory
i.e.
marked
satisﬁed
part
realization
must
satisﬁed
e.g.
lowcost
def=
...
cost
100
satisﬁed
compliance
part
fact
sets
cost
part
realization
must
satisﬁed
e.g.
usepartnerinstitutions
part
usepartnerinstitutions
–which
includes
costusepartnerinstitutions
satisﬁed
compliance
fact
sets
coste
every
formulas
attribute
deﬁnitions
e.g.
global
formula
cost
cid:80
global
formulas
attribute
deﬁnitions
realization
complies
global
coste
deﬁnes
attribute
cost
satisﬁed
cost
coste
every
element
need
considered
e.g.
sum
cost
cid:80
remark
importantly
deﬁnition
objectives
non-zero
terms
sums
e∈e
coste
safely
restricted
elements
usepartnerinstitutions
usehotelsandconventioncenters
allows
reducing
drastically
number
rational
variables
involved
en-
coding
implementation
cgm-tool
exploited
fact
automated
reasoning
constrained
goal
models
section
describe
perform
automated
reasoning
functionalities
cgms
encoding
smt
omt
5.1
encoding
constrained
goal
models
deﬁnition
smt
lra
encoding
cgm
let
def=
cid:104
cid:105
cgm
smt
lra
encoding
formula
def=
cid:94
cid:0
...
cid:1
r−→e
r∈r
cid:94
cid:94
cid:1
cid:0
cid:1
cid:0
cid:95
i=1
e∈roots
∪internals
ri∈reﬁnements
def=
def=
roots
internals
root
internal
elements
respectively
call
smt
lra
encoding
cgm
multi-objective
reasoning
constrained
goal
models
therefore
following
facts
straightforward
consequences
deﬁnitions
notice
formulas
encode
directly
points
deﬁnition
every
element
reﬁnement
cgm
short
component
encodes
relation
induced
and-or
goal
graph
component
formula
described
point
deﬁnition
encodes
boolean
smt
lra
constraints
cgm
including
relational
edges
global
local
formulas
user
assertions
deﬁnitions
numerical
attributes
objectives
deﬁnition
omt
lra
proposition
let
def=
cid:104
cid:105
cgm
let
smt
lra
encoding
deﬁnition
let
lra-interpretation
realization
short
proposition
says
realization
cgm
model
smt
lra
formula
therefore
realization
found
invoking
smt
lra
solver
cgm
encoding
proposition
let
proposition
let
realization
let
obj1
...
objk
numerical
objectives
occurring
every
...
minimizes
resp
maximizes
obji
solu-
tion
omt
lra
minimization
resp
maximization
problem
cid:104
cid:104
obji
cid:105
cid:105
lexicographically
minimizes
resp
maximizes
cid:104
obj1
...
objk
cid:105
solution
omt
lra
lexicographic
minimization
resp
maximization
problem
cid:104
cid:104
obj1
...
objk
cid:105
cid:105
short
proposition
says
realization
cgm
opti-
mizes
lexicographically
cid:104
obj1
...
objk
cid:105
model
smt
lra
formula
optimizes
lexicographically
cid:104
obj1
...
objk
cid:105
therefore
one
realization
found
invoking
omt
lra
solver
cid:104
obj1
...
objk
cid:105
notice
always
looking
one
realization
time
mul-
tiple
realizations
require
multiple
calls
omt
solver
5.2
automated
reasoning
constrained
goal
models
propositions
suggest
realizations
cgm
produced
applying
smt
lra
solving
encoding
optimal
realizations
produced
applying
omt
lra
list
deﬁned
objectives
obj1
...
objk
notice
list
may
include
also
pre-deﬁned
objectives
weight
numunsatrequirements
numsattasks
numunsatprefs
minimized
allowed
implement
straightforwardly
following
reason-
ing
functionalities
cgms
interfacing
smt/omt
tool
search/enumerate
realizations
stakeholders
automatically
check
realizabil-
ity
cgm
–or
enumerate
one
possible
realizations–
chi
mai
nguyen
group
user
assertions
user-deﬁned
boolean
smt
lra
con-
straints
tool
performs
task
invoking
smt
solver
formula
deﬁnition
search/enumerate
minimum-penalty/maximum
reward
realizations
stakeholders
assert
desired
requirements
set
penalties
tasks
tool
ﬁnds
au-
tomatically
realizations
achieving
former
minimizing
latter
in-
voking
omt
solver
pre-deﬁned
weight
objective
vice
versa
obtained
negating
undesired
tasks
setting
rewards
nice-to-
requirements
every
intermediate
situations
also
obtained
search/enumerate
optimal
realizations
wrt
pre-deﬁned/user-deﬁned
objectives
stakeholders
deﬁne
objective
functions
obj1
...
objk
goals
reﬁnements
numerical
attributes
tool
ﬁnds
automatically
realizations
optimiz-
ing
either
independently
lexicographically
invoking
omt
solver
obj1
...
objk
user-deﬁned
objectives
also
combined
pre-deﬁned
ones
like
weight
numunsatrequirements
numsattasks
numunsatprefs
particular
notice
numunsatprefsallows
addressing
fulﬁllment
maximum
number
binary
preferences
optimization
pre-deﬁned
objec-
tive
example
potentially
frequent
scenario
stakeholders
may
want
ﬁnd
re-
alization
minimizes
order
preference
number
unsatisﬁed
non-
mandatory
requirements
number
unsatisﬁed
binary
preferences
num-
ber
satisﬁed
tasks
achieved
setting
following
ordered
list
pre-deﬁned
objectives
minimize
lexicographically
cid:104
numunsatrequirements
numunsatprefs
numsattasks
cid:105
notice
actions
performed
interactively
marking
unmarking
nice-to-have
requirements
tasks
domain
assumptions
time
searching
suitable
optimal
realization
importantly
cgm
found
un-realizable
group
user
assertions
user-deﬁned
boolean
smt
lra
constraints
highlights
subparts
cgm
subset
assertions
causing
problem
implemented
asking
smt/omt
solver
identify
unsatisﬁable
core
input
formula
—i.e
subset
sub-formulas
caused
inconsistency
see
e.g
mapping
back
corresponding
information
implementation
cgm-tool
provides
support
modelling
reasoning
cgms
technically
cgm-tool
standalone
application
written
java
core
based
eclipse
rcp
engine
hood
encodes
cgms
invokes
optimathsat
smt/omt
solver
support
reasoning
goal
models
freely
distributed
compressed
archive
ﬁle
multiple
platforms
cgm-tool
supports
http
//optimathsat.disi.unitn.it
http
//www.cgm-tool.eu/
multi-objective
reasoning
constrained
goal
models
fig
cgm-tool
component
view
fig
cgm-tool
graphical
user
interface
tool
manual
green
notes
description
speciﬁcation
projects
cgms
created
within
scope
project
containers
project
contains
set
cgms
used
generate
reasoning
sessions
optimathsat
i.e.
scenarios
2guiandworkingenvironmentthissectiondescribesthebasicguipartsofcgm-tool
andalsoprovidesageneraloverviewofthetoolworkingenvironment.figure3outlinesthegeneralappearanceofthetool.figure3
cgm-tooloverview2.1cgm-toolguithegraphicaluserinterfaceofcgm-tooliscomposedofmenus
editorarea
paletteandseveraldi↵erentviews.thefollowingsub-sectionswillexplainpartsoftheguionebyone.2.1.1menuscommands
whicharescatteredoverthetoolmenubarandtoolbararethemaininterfacestoaccesstheprimaryfunctionsofcgm-tool.thesucceedingsub-sectionswillintroducethesecommandsandtheiruse.3
chi
mai
nguyen
fig
cgm-tool
deﬁne
numerical
attributes
instructions
red
fig
cgm-tool
deﬁne
value
numerical
attributes
associated
elements
in-
structions
red
fig
cgm-tool
deﬁne
objectives
numerical
attributes
instructions
red
click
smt
variable
deﬁne
numerical
a9ribu
ons
fill
name
numerical
a9ribu
click
deﬁne
2nd
click
element
1st
choose
node
variable
tab
see
able
deﬁne
local
numerical
a=ributes
chosen
element
choose
model
variable
tab
able
access
global
numerical
a5ributes
change
value
priority
a3ribute
lower
value
higher
miza
priority
mean
care
miza
a3ribute
choose
either
maximize
total
value
a3ribute
minimize
multi-objective
reasoning
constrained
goal
models
fig
cgm-tool
deﬁne
global
constraints
instructions
red
fig
cgm-tool
create
scenario
instructions
red
diagrammatic
modelling
tool
enables
creation
drawing
cgms
terms
diagrams
furthermore
enhances
modelling
process
providing
real-
time
check
reﬁnement
cycles
reporting
invalid
reﬁnement
contribution
binding
links
consistency/well-formedness
check
cgm-tool
allows
creation
diagrams
conform
semantics
modelling
language
providing
ability
run
consistency
analysis
model
click
global
constraint
deﬁne
constraints
type
constraint
click
add
add
constraint
right
click
constraint
able
remove
constraint
necessary
click
generate
scenario
create
scenario
give
scenario
name
click
finish
chi
mai
nguyen
fig
cgm-tool
open
created
scenario
instructions
red
fig
cgm-tool
add
user
assertions
instructions
red
fig
cgm-tool
automatically
generate
realization
click
launch
reasoner
menu
instructions
red
click
cgm
ﬁle
open
generated
scenario
right-click
element
force
true
false.
note
mandatory
requirements
must
force
true
force
true
elements
marked
red
force
false
elements
marked
green
multi-objective
reasoning
constrained
goal
models
automated
reasoning
cgm-tool
provides
automated
reasoning
functionalities
encoding
model
smt
formula
results
optimathsat
shown
directly
model
well
tabular
form
one
essential
feature
tool
expressive
constructs
may
complex
difﬁcult
use
available
demand
easy-to-use
default
settings
everything
user
decide
level
expressiveness
he/she
feels
ease
cgm-tool
extends
sts-tool
rcp
application
using
major
frameworks
shown
figure
rich
client
platform
rcp
platform
build-
ing
rich
client
applications
made
collection
low
level
frameworks
osgi
swt
jface
equnix
provide
workbench
get
things
like
menus
editors
views
graphical
editing
framework
gef
framework
used
create
graphical
editors
graphical
modelling
tools
e.g.
tool
palette
ﬁgures
used
graphically
represent
underlying
data
model
con-
cepts
eclipse
modelling
framework
emf
modelling
framework
code
gen-
eration
facility
building
tools
applications
based
structured
data
model
cgm-tool
cgm
built
progressively
sequence
scenarios
versions
cgm
automated
reasoning
functionalities
cgm-tool
applied
figure
shows
graphical
user
interface
gui
tool
figures
show
respectively
deﬁne
numerical
attribute
ele-
ment
set
value
figure
shows
set
objective
functions
numerical
attributes
e.g.
set
priorities
choose
form
optimization
max-
imize/minimize
figure
shows
deﬁne
global
constraints
model
figure
figure
show
create
open
scenario
figure
shows
user
assertions
added
using
option
force
true
ele-
ment
must
included
realization
force
false
element
must
included
realization
figure
shows
automatically
generate
realization
current
scenario
invoking
automated-reasoning
functionali-
ties
scalability
reasoning
tool
address
issue
scalability
automated-reasoning
functionalities
wrt
size
cgms
providing
empirical
evaluation
performance
cgm-tool
increasingly-large
cgms
sake
readability
pro-
vide
qualitative
description
whereas
data
plots
reported
appendix
experiments
run
macbook
air
laptop
intel
core
1.8
ghz
cores
256
cache
per
core
cache
4gb
ram
readers
convenience
compressed
directory
containing
material
reproduce
experiments
models
tools
scripts
etc
available
http
//www.cgm-tool.eu/experiment-version/
consider
ﬁrst
schedule-meeting
cgm
seed
model
model
consists
goals
–among
mandatory
requirement
nice-to-
requirements
tasks–
plus
reﬁnements
domain
assumptions
totaling
nodes
cgm
contains
also
numerical
objectives
cost
worktime
chi
mai
nguyen
weight
user-deﬁned
objectives
cost
worktime
involve
respectively
tasks
requirement
whilst
pre-deﬁned
attributes
weight
involves
tasks
plus
non-mandatory
requirements
involves
rational
variables
recall
remark
also
three
binary
preference
relations
example
reported
different
conﬁgurations
tool
returned
optimal
solutions
negligible
time
took
less
0.02
seconds
surprising
mentioned
§2.1
previous
empirical
evaluation
omt-encoded
problems
formal
veriﬁcation
optimathsat
successfully
handled
optimization
problems
thousands
boolean/rational
variables
hand-made
cgms
resulting
smt
formulas
tens
boolean
rational
variables
like
computational
challenge
perspective
since
cgm-tool
supposed
used
design
cgms
repre-
senting
possibly-large
projects
wonder
automated-reasoning
functionali-
ties
scale
large
models
choose
build
benchmark
cgms
increasing
size
combining
different
instances
schedule-meeting
cgm
various
ways
testing
different
combination
objectives
7.1
experiment
setup
experiments
cgms
produced
follows
according
three
positive
integer
parameters
choices
objectives
given
pick
distinct
instances
schedule-meeting
cgm
fresh
set
boolean
labels
rational
variables
create
artiﬁcial
root
goal
one
reﬁnement
whose
source
goals
mandatory
requirements
schedulemeetingi
cgm
instance
hence
resulting
cgm
54·
nodes
30·
rational
variables
see
figure
another
group
experiments
see
figure
dropped
non-mandatory
requirements
direct
sub-tasks
instance
contains
goals
domain
assumptions
reﬁnements
resulting
cgm
nodes
rational
variables
randomly
add
contribution
relations
++−−→
conﬂict
−−←→
tasks
belonging
different
instances
binary
prefer-
relations
ence
relations
involved
see
also
randomly
add
p·n
binary
preference
relations
involving
two
reﬁnements
one
goal
group
experiments
deﬁnition
objectives
set
value
applies
increase
values
every
choice
automatically
generate
100
instances
random
problems
schema
feed
tool
collect
median
cpu
times
solved
instances
–including
encoding
solving
times–
well
number
un-
realizable
instances
well
number
instances
optimathsat
could
solve
within
timeout
1000
seconds
perform
test
automatically
developed
automated
problem
generator/manipulator
interfaces
directly
internal
data
structure
representing
cgms
inside
cgm-tool
multi-objective
reasoning
constrained
goal
models
notice
following
ideas
different
context
20,33
parameters
chosen
allow
increase
monotonically
tune
essential
features
cgms
test
may
signiﬁcantly
inﬂuence
performances
e.g.
increases
linearly
number
boolean
rational
variables
extent
increases
connectivity
graph
ratio
unrealizable
realizable
cgms
importantly
also
play
essential
role
drastically
reducing
sym-
metry
resulting
cgms
insert
degree
randomness
another
important
parameter
borrowed
schedule-meeting
cgm
number
boolean
atoms
per
objective
remark
aware
cgms
produced
approach
may
rep-
resent
realistic
problems
however
stress
fact
focus
providing
test
scalability
automated-reasoning
functionalities
7.2
results
run
two
groups
experiments
focus
optimizing
respectively
numerical
attributes
like
cost
work-time
penalty/rewards
discrete
features
like
number
binary
preferences
want-to-have
require-
ments
tasks
accomplish
ﬁrst
group
experiments
consider
reduced
version
cgms
i.e
without
nice-to-have
requirements
without
random
binary
preference
relations
setting
run
experiments
three
functionalities
plain
realizability
check
without
objectives
single-objective
optimization
cost
worktime
weight
respectively
lexicographic
optimization
respectively
cid:104
cost
worktime
weight
cid:105
cid:104
weight
worktime
cost
cid:105
figure
shows
overall
median
cpu
time
solved
instances
ﬁrst
group
experiments
plotted
total
number
nodes
cgm
test
details
experiment
data
median
cpu
time
solved
instances
special
case
please
see
figures
19-26
appendix
first
notice
checking
realizability
cgm
ﬁnding
one
realization
verifying
none
requires
negligible
time
even
huge
cgms
000
nodes
000
rational
variables
even
cgm
real-
izable
second
time
taken
ﬁnd
optimal
solutions
single
objectives
seem
depend
number
variables
objective
actual
size
cgm
cost
variables
solver
ﬁnd
optimum
solutions
quickly
even
huge
cgms
8.000
nodes
000
rational
variables
whilst
choice
using
total
number
nodes
axis
plots
aims
providing
eye-catching
indication
actual
size
cgms
test
chi
mai
nguyen
weight
variables
handle
problems
400
nodes
200
rational
variables
third
lexicographic
optimization
takes
time
single-objective
optimization
time
mostly
depends
ﬁrst
objective
list
second
group
experiments
consider
full
version
cgms
nice-to-have
requirements
introduce
random
binary
preference
rela-
tions
run
different
experiments
12.
setting
run
experiments
three
functionalities
plain
realizability
check
without
objectives
lexicographic
optimization
cid:104
numunsatprefs
numunsatrequirements
numsattasks
cid:105
lexicographic
optimization
cid:104
numunsatrequirements
numunsatprefs
numsattasks
cid:105
prt
rpt
figure
shows
overall
median
cpu
time
solved
instances
second
group
experiments
details
experiment
data
median
cpu
time
solved
instances
special
case
please
see
figures
27-32
appendix
first
checking
realizability
accomplished
negligible
time
even
huge
cgms
000
nodes
000
rational
variables
second
notice
optimal
solutions
even
three-level
lexicographic
combination
objec-
tives
found
large
cgms
000
nodes
600
rational
variables
negative
side
problems
particular
large
ones
objectives
involving
large
amounts
elements
notice
search
optimal
real-
ization
could
accomplished
within
timeout
extent
remarks
order
first
interrupted
timeout
optimathsat
instructed
return
current
best
solution
since
optimathsat
typically
takes
time
ﬁne-
tuning
optimum
checking
better
one
see
envisage
good
sub-optimal
solutions
found
even
optimal
ones
reach
second
cgms
large
breadth
small
depth
domi-
nating
percentage
tasks
total
number
goals
envisage
may
made
number
variables
sums
deﬁning
weight
numsattasks
unrealistically
large
wrt
total
size
cgms
underscores
need
experimentation
conﬁrm
scalability
proposal
third
experiments
consider
user
assertions
consid-
ered
would
force
deterministic
assignments
hence
reduce
drastically
size
omt
search
space
fourth
omt
recent
technology
progressing
high
pace
reasonable
expect
performance
improvements
future
versions
omt
tools
particular
recent
enhancement
handling
pseudo-
boolean
cost
functions
provided
interesting
preliminary
results
overall
evaluation
showed
cgm-tool
always
checks
realizability
huge
cgms
negligible
time
ﬁnds
optimal
realizations
problems
whose
size
ranges
hundreds
thousands
nodes
mostly
depending
number
variables
involved
objective
functions
multi-objective
reasoning
constrained
goal
models
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
109
127
163
199
235
271
307
379
469
559
649
739
829
919
1819
2719
3619
121
145
169
217
265
313
361
409
505
625
745
865
985
1105
1225
2425
3625
4825
102
202
302
402
fig
first
group
experiments
summary
experimental
data.
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
101
121
141
181
221
261
301
341
421
521
621
721
821
921
1021
2021
3021
4021
129
161
193
225
289
353
417
481
545
673
833
993
1151
1313
1473
1633
3233
4833
6433
102
202
302
402
104
130
156
182
234
286
338
390
442
546
676
806
936
1066
1196
1326
2626
3926
5226
120
150
180
210
270
330
390
450
510
630
780
930
1080
1230
1380
1530
3030
4530
6030
134
178
222
266
310
398
486
574
662
750
926
1146
1366
1586
1806
2026
2246
4446
6646
8846
110
164
218
272
326
380
488
596
704
812
920
1136
1406
1676
1946
2216
2486
2756
5456
8156
10856
fig
second
group
experiments
summary
experimental
data
chi
mai
nguyen
fig
first
group
experiments
overall
median
cpu
times
solved
instances
name
plot
denotes
cost
function
used
value
e.g.
cost/time/weight
detotes
lexicographic
optimization
cost
worktime
weight
problems
built
replicas
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
cost
cost
cost
cost
0me
0me
0me
0me
weight
weight
weight
weight
cost/0me/weight
cost/0me/weight
cost/0me/weight
cost/0me/weight
weight/0me/cost
weight/0me/cost
weight/0me/cost
weight/0me/cost
multi-objective
reasoning
constrained
goal
models
fig
second
group
experiments
overall
median
cpu
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
6p_preferences
priority
8p_preferences
priority
12p_preferences
priority
6p_so5
requirements
priority
8p_so5
requirements
priority
12p_so5
requirements
priority
related
work
chi
mai
nguyen
next
offer
quick
overview
comparison
state
art
goal-oriented
modelling
languages
provide
better
deeper
comparisons
requirements
modelling
languages
goal-oriented
approach
including
advantages
limitations
kaos
kaos
supports
rich
ontology
requirements
goes
well
beyond
goals
well
linear
temporal
logic
ltl
-grounded
formal
language
con-
straints
language
coupled
concrete
methodology
capturing
analyzing
requirements
problems
kaos
supports
number
analysis
techniques
including
obstacle
inconsistency
probabilistic
goal
analysis
however
unlike
proposal
kaos
support
nice-to-have
requirements
preferences
exploit
sat/smt
solver
technologies
scalability
sebastiani
al..
sebastiani
18,36
propose
formal
goal
modelling
language
supports
scalable
reasoning
using
sat-solving
techniques
proposal
sub-
sumes
work
many
ways
including
expressive
language
much
advanced
smt/omt-solving
technology
one
construct
18,36
left
cgm
language
contributions
goals
goals
several
reasons
decision
un-
constrained
goal
models
formalizing
contributions
require
4-value
logic
fully/partially
satisﬁed/denied
principle
cgm
framework
could
extended
logic
following
drawbacks
size
boolean
search
space
would
extend
given
reasoning
functionality
paper
much
sophisticated
computa-
tionally
demanding
earlier
papers
might
drastically
reduce
efﬁciency
approach
unlike
standard
2-value
logic
allows
give
clear
semantics
re-
alization
without
vagueness
obvious
realization
could
logic
e.g.
realizations
admit
partially
satisﬁed/denied
tasks/requirements/assumptions
yes
user
interpret
partially-
satisﬁed/denied
requirement/task/assumption
realization
returned
sys-
tem
sense
realization
involving
partial
values
considered
op-
timal
optimum
differences
two
proposals
cgms
made
and/or-decompositions
explicit
making
reﬁnement
ﬁrst
class
citizen
named
talked
see
figure
remark
moreover
unlike
backbone
and/or
dag
arbitrary
constraints
added
dag
non-leaf
goal
equivalent
disjunction
re-
ﬁnements
reﬁnement
equivalent
conjunction
source
goals
relation
edges
constraints
assertions
constrain
structure
tropos
focuses
modelling
actors
requirements
engineering
problem
stakeholders
users
analysts
etc
goals
inter-dependencies
provides
two
complementary
views
requirements
actor
strategic
dependency
model
model
actor
strategic
rationale
model
model
typically
multi-objective
reasoning
constrained
goal
models
models
used
analyze
alternative
networks
delegations
among
actors
fulﬁlling
stakeholder
goals
whilst
models
used
explore
alternative
ways
fulﬁlling
single
actor
goals
expressively
lightweight
intended
early
stages
requirements
analysis
support
formal
reasoning
recent
the-
sis
work
horkoff
tropos
requirements-driven
agent-oriented
software
development
methodology
founded
goal
models
formalized
tropos
using
formal
tropos
extension
supports
ltl
formalizing
constraints
main
deﬁciencies
work
relative
proposal
formal
tropos
expressive
scalable
techne
liaskos
techne
recent
proposal
family
goal-modelling
languages
supports
nice-to-have
goals
preferences
strictly
propo-
sitional
uses
hand-crafted
algorithms
therefore
support
optimiza-
tion
goals
constitutes
ﬁrst
attempt
reason
nice-to-have
requirements
aka
preferences
scalability
experiments
conducted
used
sat
solver
se-
bastiani
added
local
search
algorithms
deal
preferences
experiments
conducted
model
500
elements
search
algorithms
returned
maximal
consistent
solution
also
near-solutions
fo-
cuses
ﬁnding
new
solutions
goal
model
changed
new
goals
added/removed
change
minimizes
development
effort
evor1
maximizes
familiarity
evor2
note
evor1
evor2
evolution
requirements
paper
uses
truth-maintenance
system
tms
builds
algorithms
top
ﬁnding
solutions
evor1
evor2
repair
previous
solution
construct
new
one
search
algorithms
would
need
redone
used
different
evolu-
tion
algorithms
unlike
cgm
tool
formally
express
evor1
evor2
variants
search
handle
backend
omt/smt
solver
14,13
continue
study
reasoning
techne
models
use
sat
solvers
hand-crafted
search
algorithms
establish
scalability
models
size
nevertheless
re-
sulting
tools
work
still
handle
quantitative
optimization
problems
features
cgms
liaskos
26,25
proposed
extensions
qualitative
goal
models
support
nice-to-have
goals
preferences
well
decision-theoretic
concepts
utility
proposal
comparable
proposal
paper
uses
reason-
ers
reasoning
planners
golog
consequently
scale
well
relative
proposal
feature
models
feature
models
share
many
similarities
goal
models
hierarchically
structured
and/or
reﬁnements
constraints
attributes
however
feature
represents
bundle
functionality
quality
fea-
ture
models
models
software
conﬁgurations
requirements
moreover
rea-
soning
techniques
feature
models
limited
relative
goal
model
cousins
search-based
software
engineering
scalable
reasoning
optimization
problems
studied
harman
context
formalizing
solving
next
release
problem
given
set
preferences
associated
cost
customer
value
attributes
select
subset
preferences
included
next
release
optimizes
given
attributes
work
uses
genetic
algorithms
search
tech-
chi
mai
nguyen
niques
may
return
close-to-optimal
solutions
use
heuristics
meaning
reasoning
complete
conclusions
future
work
proposed
expressive
goal-based
modelling
language
requirements
supports
representation
nice-to-have
requirements
preferences
optimiza-
tion
requirements
constraints
moreover
exploited
automated
rea-
soning
solvers
order
develop
tool
supports
sound
complete
reasoning
respect
goal
models
scales
well
goal
models
thousands
elements
proposal
advances
state-of-the-art
goal
modelling
reasoning
respect
expressiveness
scalability
reasoning
contributions
work
exploited
several
directions
proposed
expressive
modelling
framework
next
release
problem
founded
omt/smt
solver
technology
work
offered
formalization
next
adaptation
problem
chooses
next
adaptation
adaptive
software
system
minimizes
degree
failure
existing
re-
quirements
exploited
cgms
capture
evolution
requirements
system
evolution
shall
minimize
implementation
costs
showed
conduct
scalable
reasoning
models
include
requirements
future
work
planned
empirical
validation
cgm-tool
modelers
domain
experts
currently
working
direction
within
research
group
phd
students
post-docs
expert
modelling
ﬁeld
next
extend
validation
industrial
experts
different
domains
also
planned
different
case
studies
real-life-complex-large-scale
goal
models
speciﬁc
domain
air-trafﬁc
control
management
health-
care
smart
cities
smart
environments
proposal
address
another
notorious
scalability
problem
goal
mod-
els
namely
scalability-of-use
goal
models
shown
empirically
become
difﬁcult
conceptualize
comprehend
grow
size
there-
fore
become
unwieldy
use
kinds
artifacts
e.g.
programs
on-
tologies
scalability-of-use
issue
solution
lies
introducing
mod-
ularization
facilities
limit
interactions
model
elements
make
resulting
models
easier
understand
evolve
important
problem
agenda
future
research
goal
models
acknowledgements
would
like
thank
dagmawi
neway
technical
support
developing
cgm-tool
patrick
trentin
assistance
usage
optimathsat
references
angelopoulos
aydemir
giorgini
mylopoulos
solving
next
adaptation
problem
prometheus
rcis
2016
anton
a.i
goal-based
requirements
analysis
proceedings
2nd
international
conference
requirements
engineering
icre
136–
ieee
computer
society
1996
multi-objective
reasoning
constrained
goal
models
anton
a.i.
potts
use
goals
surface
requirements
evolving
systems
proceedings
20th
international
conference
software
engineering
icse
157–166
ieee
computer
society
1998
aydemir
mekuria
giorgini
mylopoulos
scalable
solutions
next
release
problem
goal-oriented
perspective
2016
submission
barrett
c.w.
sebastiani
seshia
s.a.
tinelli
satisﬁability
modulo
theories
handbook
satisﬁability
chap
825–885
ios
press
2009
borgida
dalpiaz
horkoff
mylopoulos
requirements
models
design-
runtime
position
paper
proceedings
5th
international
workshop
modeling
software
engi-
neering
mise
62–68
ieee
press
2013
castro
kolp
mylopoulos
towards
requirements-driven
information
systems
engineering
tropos
project
inf
syst
365–389
2002
doi
10.1016/s0306-4379
00012-1
cimatti
griggio
schaafsma
b.j.
sebastiani
mathsat
smt
solver
tools
algorithms
construction
analysis
systems
tacas
13.
lncs
vol
7795
95–109
springer
2013
cimatti
griggio
sebastiani
computing
small
unsatisﬁable
cores
sat
modulo
theo-
ries
journal
artiﬁcial
intelligence
research
jair
701–728
2011
10.
classen
boucher
heymans
text-based
approach
feature
modelling
syntax
se-
mantics
tvl
sci
comput
program
1130–1143
2011
doi
10.1016/j.scico.2010.10.005
11.
dardenne
van
lamsweerde
fickas
goal-directed
requirements
acquisition
sci
comput
program
1-2
3–50
1993
12.
ernst
n.a.
borgida
jureta
finding
incremental
solutions
evolving
requirements
15–24
ieee
2011
13.
ernst
n.a.
borgida
jureta
i.j.
mylopoulos
agile
requirements
engineering
via
paraconsis-
tent
reasoning
information
systems
100
116
2014
doi
http
//dx.doi.org/10.1016/j.is.2013
05.008
14.
ernst
n.a.
borgida
mylopoulos
jureta
agile
requirements
evolution
via
paraconsistent
ralyt´e
franch
brinkkemper
wrycza
eds
caise
lecture
notes
reasoning
computer
science
vol
7328
382–397
springer
2012
15.
ernst
n.a.
mylopoulos
borgida
jureta
i.j
reasoning
optional
preferred
require-
ments
parsons
saeki
shoval
woo
wand
eds
conceptual
modeling
2010
29th
international
conference
conceptual
modeling
vancouver
canada
november
1-4
2010.
proceedings
118–131
springer
berlin
heidelberg
berlin
heidelberg
2010
doi
10.1007/978-3-642-16373-9
16.
estrada
rebollar
a.m.
pastor
mylopoulos
empirical
evaluation
framework
model-based
software
generation
environment
dubois
pohl
eds
advanced
information
systems
engineering
18th
international
conference
caise
2006
luxembourg
luxembourg
june
5-9
2006
proceedings
lecture
notes
computer
science
vol
4001
513–527
springer
2006
doi
10.1007/11767138
17.
fuxman
liu
mylopoulos
pistore
roveri
traverso
specifying
analyzing
early
requirements
tropos
requir
eng
132–150
2004
doi
10.1007/s00766-004-0191-7
18.
giorgini
mylopoulos
nicchiarelli
sebastiani
formal
reasoning
techniques
goal
models
journal
data
semantics
1–20
2004
19.
horkoff
j.m
iterative
interactive
analysis
agent-goal
models
early
requirements
engineering
ph.d.
thesis
university
toronto
2012
aainr97565
20.
horrocks
patel-schneider
p.f.
sebastiani
analysis
empirical
testing
modal
deci-
sion
procedures
logic
journal
igpl
293–323
2000
21.
jarvis
mcarthur
mylopoulos
rodr´ıguez-gianolli
zhou
semantic
models
knowledge
management
wise
2001
22.
jureta
borgida
ernst
n.a.
mylopoulos
techne
towards
new
generation
requirements
modeling
languages
goals
preferences
inconsistency
handling
115–124
ieee
computer
society
2010
23.
jureta
mylopoulos
faulkner
revisiting
core
ontology
problem
requirements
engineering
proceedings
2008
16th
ieee
international
requirements
engineering
confer-
ence
71–80
ieee
computer
society
2008
doi
10.1109/re.2008.13
24.
lapouchnian
goal-oriented
requirements
engineering
overview
current
research
tech
rep.
department
computer
science
university
toronto
2005
chi
mai
nguyen
25.
liaskos
eliciting
contribution
measures
goal
models
proceedings
2012
ieee
20th
international
requirements
engineering
conference
221–230
ieee
computer
society
2012
doi
10.1109/re.2012.6345808
26.
liaskos
mcilraith
s.a.
sohrabi
mylopoulos
integrating
preferences
goal
models
requirements
engineering
135–144
ieee
computer
society
2010
27.
mekuria
d.n
constrained
goal
modeling
reasoning
tool
user
manual
28.
mylopoulos
chung
nixon
representing
using
nonfunctional
requirements
process-
oriented
approach
ieee
trans
softw
eng
483–497
1992
doi
10.1109/32.142871
29.
newell
simon
gps
program
simulates
human
thought
e.a
feigenbaum
feld-
man
eds
computers
thought
279–293
mcgraw-hill
1963
30.
nguyen
c.m.
sebastiani
giorgini
mylopoulos
requirements
evolution
evolution
requirements
constrained
goal
models
proceedings
37nd
international
conference
conceptual
modeling
lncs
springer
2016
31.
nieuwenhuis
oliveras
sat
modulo
theories
optimization
problems
proc
sat
lncs
vol
4121.
springer
2006
32.
paja
dalpiaz
poggianella
roberti
giorgini
sts-tool
socio-technical
security
requirements
social
commitments
proceedings
20th
ieee
international
conference
requirements
engineering
331–332
2012
33.
patel-schneider
p.f.
sebastiani
new
general
method
generate
random
modal
formulae
testing
decision
procedures
journal
artiﬁcial
intelligence
research
jair
351–389
2003
morgan
kaufmann
34.
rao
a.s.
george
m.p
bdi
agents
theory
practice
proceedings
first
interna-
tional
conference
multiagent
systems
aaai
1995
35.
sebastiani
lazy
satisﬁability
modulo
theories
journal
satisﬁability
boolean
modeling
computation
jsat
3-4
141–224
2007
36.
sebastiani
giorgini
mylopoulos
simple
minimum-cost
satisﬁability
goal
models
proc
16th
international
conference
advanced
information
systems
engineering
caise
lncs
springer
riga
latvia
2004
37.
sebastiani
tomasi
optimization
smt
cost
functions
ijcar
lnai
vol
38.
sebastiani
tomasi
optimization
modulo
theories
linear
rational
costs
acm
trans-
7364
484–498
springer
2012
actions
computational
logics
2015
39.
sebastiani
trentin
optimathsat
tool
optimization
modulo
theories
proc
inter-
national
conference
computer-aided
veriﬁcation
cav
2015
lncs
vol
9206.
springer
2015
40.
sebastiani
trentin
pushing
envelope
optimization
modulo
theories
linear-
arithmetic
cost
functions
proc
int
conference
tools
algorithms
construction
analysis
systems
tacas
lncs
vol
9035.
springer
2015
41.
sebastiani
trentin
beneﬁts
enhancing
optimization
modulo
theories
sorting
networks
maxsmt
proceedings
14th
international
workshop
satisﬁability
modulo
theories
smt-2016.
ceur
workshop
proceedings
2016
42.
van
lamsweerde
goal-oriented
requirements
engineering
guided
tour
proceedings
fifth
ieee
international
symposium
requirements
engineering
249–
ieee
com-
puter
society
2001
43.
e.s.k
towards
modeling
reasoning
support
early-phase
requirements
engineering
proceedings
3rd
ieee
international
symposium
requirements
engineering
226.
ieee
computer
society
1997
44.
zhang
harman
mansouri
s.a.
multi-objective
next
release
problem
proceedings
9th
annual
conference
genetic
evolutionary
computation
gecco
1129–1137
acm
new
york
usa
2007
doi
10.1145/1276958.1277179
multi-objective
reasoning
constrained
goal
models
appendix
data
tables
plots
a.1
first
group
experiments
chi
mai
nguyen
optimum
cost
terms
optimum
time
terms
optimum
weight
16n
terms
lexic
order
cost
time
weight
lexic
order
weight
time
cost
0.00
0.01
0.01
0.02
0.01
0.01
0.02
0.02
0.05
0.04
0.04
0.06
0.07
0.09
0.11
0.13
0.18
0.20
0.49
0.77
0.93
0.01
0.01
0.01
0.03
0.02
0.04
0.09
0.11
0.30
18.13
3.11
58.08
600.99
0.02
0.03
0.41
5.51
24.74
533.90
185.23
0.01
0.01
0.01
0.02
0.18
0.02
0.02
7.29
17.98
0.02
0.25
1.53
7.48
29.74
329.34
494.33
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
134
178
222
266
310
398
486
574
662
750
926
1146
1366
1586
1806
2026
2246
4446
6646
8846
104
130
156
182
234
286
338
390
442
546
676
806
936
1066
1196
1326
2626
3926
5226
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
fig
first
group
experiments
median
time
solved
instances
optimum
cost
terms
optimum
time
terms
optimum
weight
16n
terms
lexic
order
cost
time
weight
lexic
order
weight
time
cost
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
134
178
222
266
310
398
486
574
662
750
926
1146
1366
1586
1806
2026
2246
4446
6646
8846
104
130
156
182
234
286
338
390
442
546
676
806
936
1066
1196
1326
2626
3926
5226
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.01
0.01
0.01
0.01
0.02
0.02
0.02
0.03
0.04
0.04
0.05
0.09
0.12
0.16
0.14
0.17
0.20
0.80
0.72
1.18
0.01
0.01
0.02
0.01
0.02
0.05
0.06
0.14
0.43
2.42
28.45
97.86
537.73
0.02
0.03
0.08
0.41
1.09
9.53
13.54
0.03
0.04
0.06
0.08
0.11
0.13
0.64
1.53
36.78
368.94
0.04
0.05
0.13
0.79
2.82
14.47
447.13
fig
first
group
experiments
median
time
solved
instances
multi-objective
reasoning
constrained
goal
models
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
134
178
222
266
310
398
486
574
662
750
926
1146
1366
1586
1806
2026
2246
4446
6646
8846
104
130
156
182
234
286
338
390
442
546
676
806
936
1066
1196
1326
2626
3926
5226
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
optimum
cost
terms
optimum
time
terms
optimum
weight
16n
terms
lexic
order
cost
time
weight
lexic
order
weight
time
cost
0.01
0.00
0.01
0.01
0.03
0.01
0.02
0.02
0.03
0.04
0.05
0.07
0.12
0.12
0.12
0.16
0.16
0.23
0.51
3.33
1.49
0.01
0.01
0.01
0.02
0.03
0.03
0.27
0.13
0.17
1.23
11.87
104.67
455.20
0.02
0.06
0.07
0.56
1.51
0.45
284.79
852.66
0.03
0.04
0.04
0.07
0.14
0.11
0.71
0.92
47.55
111.58
35.31
0.03
0.08
0.11
0.67
1.69
0.69
557.00
705.92
fig
first
group
experiments
median
time
solved
instances
optimum
cost
terms
optimum
time
terms
optimum
weight
16n
terms
lexic
order
cost
time
weight
lexic
order
weight
time
cost
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
134
178
222
266
310
398
486
574
662
750
926
1146
1366
1586
1806
2026
2246
4446
6646
8846
104
130
156
182
234
286
338
390
442
546
676
806
936
1066
1196
1326
2626
3926
5226
100
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.01
0.01
0.01
0.01
0.01
0.01
0.01
0.03
0.03
0.04
0.05
0.05
0.06
0.10
0.23
0.39
0.17
0.17
1.47
40.11
0.01
0.01
0.01
0.02
0.03
0.02
0.11
0.31
0.22
0.41
0.86
149.86
406.31
0.03
0.03
0.14
0.07
1.85
14.71
17.37
79.55
131.37
0.02
0.04
0.04
0.06
0.07
0.10
0.15
0.51
0.64
6.89
0.56
104.81
fig
first
group
experiments
median
time
solved
instances
0.04
0.06
0.19
0.09
2.25
14.11
25.14
253.57
240.96
chi
mai
nguyen
fig
first
group
experiments
median
run
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
cost
weight
cost/
me/weight
weight/
me/cost
multi-objective
reasoning
constrained
goal
models
fig
first
group
experiments
median
run
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
cost
weight
cost/
me/weight
weight/
me/cost
chi
mai
nguyen
fig
first
group
experiments
median
run
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
cost
weight
cost/
me/weight
weight/
me/cost
multi-objective
reasoning
constrained
goal
models
fig
first
group
experiments
median
run
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
cost
weight
cost/
me/weight
weight/
me/cost
chi
mai
nguyen
a.2
second
group
experiments
lexic
order
prt
lexic
order
rpt
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
110
164
218
272
326
380
488
596
704
812
920
1136
1406
1676
1946
2216
2486
2756
5456
8156
10856
120
150
180
210
270
330
390
450
510
630
780
930
1080
1230
1380
1530
3030
4530
6030
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.04
0.07
0.11
0.12
0.13
0.21
0.52
0.90
2.42
39.45
1.64
694.50
0.08
0.08
0.09
0.15
0.20
0.26
0.45
0.50
2.33
1.55
1.57
468.88
fig
second
group
experiments
median
time
solved
instances
multi-objective
reasoning
constrained
goal
models
lexic
order
prt
lexic
order
rpt
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
110
164
218
272
326
380
488
596
704
812
920
1136
1406
1676
1946
2216
2486
2756
5456
8156
10856
120
150
180
210
270
330
390
450
510
630
780
930
1080
1230
1380
1530
3030
4530
6030
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.06
0.08
0.18
0.18
0.36
0.21
0.28
0.61
0.73
1.38
1.81
7.00
330.39
327.86
0.07
0.08
0.09
0.14
0.18
0.20
0.30
0.47
0.53
0.69
0.99
3.92
9.38
8.40
fig
second
group
experiments
median
time
solved
instances
lexic
order
prt
lexic
order
rpt
101
151
201
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
100
110
164
218
272
326
380
488
596
704
812
920
1136
1406
1676
1946
2216
2486
2756
5456
8156
10856
120
150
180
210
270
330
390
450
510
630
780
930
1080
1230
1380
1530
3030
4530
6030
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.06
0.09
0.13
0.15
0.25
0.39
0.43
0.81
1.15
1.32
14.66
602.22
911.26
0.06
0.07
0.12
0.17
0.20
0.30
0.49
0.56
0.89
0.37
1.97
2.13
905.11
14.79
fig
second
group
experiments
median
time
solved
instances
chi
mai
nguyen
fig
second
group
experiments
median
run
times
solved
instances
0.00
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
preferences
priority
so0
requirements
priority
multi-objective
reasoning
constrained
goal
models
fig
second
group
experiments
median
run
times
solved
instances
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
preferences
priority
so0
requirements
priority
chi
mai
nguyen
fig
second
group
experiments
median
run
times
solved
instances
0.01
0.10
1.00
10.00
100.00
1000.00
110
1100
11000
time
seconds
number
nodes
preferences
priority
so0
requirements
priority
