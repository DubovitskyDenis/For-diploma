eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
francisco
chicano1
darrell
whitley2
renato
tin´os3
dept
lenguajes
ciencias
computaci´on
university
m´alaga
spain
chicano
lcc.uma.es
dept
computer
science
colorado
state
university
fort
collins
usa
department
computing
mathematics
university
s˜ao
paulo
brazil
whitley
cs.colostate.edu
rtinos
ffclrp.usp.br
abstract
local
search
algorithms
iterated
local
search
algorithms
basic
technique
local
search
stand
along
search
methods
also
hybridized
evolutionary
algorithms
recently
shown
possible
identify
improving
moves
ham-
ming
neighborhoods
k-bounded
pseudo-boolean
optimization
prob-
lems
constant
time
means
local
search
need
enumerate
neighborhoods
ﬁnd
improving
moves
also
means
evolutionary
algorithms
need
use
random
mutation
oper-
ator
except
perhaps
way
escape
local
optima
paper
show
improving
moves
identiﬁed
constant
time
mul-
tiobjective
problems
expressed
k-bounded
pseudo-boolean
functions
particular
multiobjective
forms
landscapes
landscapes
considered
keywords
hamming
ball
hill
climber
delta
evaluation
multi-objective
optimization
local
search
introduction
local
search
iterated
local
search
algorithms
start
initial
solution
search
improving
move
based
notion
neighborhood
solutions
adjacent
current
solution
paper
consider
k-bounded
pseudo-boolean
functions
hamming
distance
neighbor-
hood
commonly
used
local
search
neighborhood
recently
shown
location
improving
moves
cal-
culated
constant
time
hamming
distance
bit
ﬂip
neighborhood
implications
local
search
algorithms
well
simple
evolu-
tionary
algorithms
1+1
evolution
strategy
since
calculate
location
improving
moves
need
enumerate
neighborhoods
discover
improving
moves
chicano
generalize
result
present
local
search
algorithm
explore
solutions
contained
hamming
ball
radius
around
chicano
whitley
tin´os
solution
constant
time
means
evolutionary
algorithms
need
use
mutation
ﬁnd
improving
moves
either
mutation
used
make
larger
moves
ﬂip
bits
mutation
used
enable
form
restarts
also
makes
crossover
important
goldman
combined
local
search
automatically
calculates
location
improving
moves
constant
time
recombination
achieve
globally
optimal
results
relatively
large
adjacent
landscape
problems
e.g
10,000
variables
whitley
introduced
notion
landspaces
replace
landscapes
landscapes
k-bounded
pseudo-boolean
optimization
prob-
lems
composed
linear
combination
subfunctions
subfunc-
tion
pseudo-boolean
optimization
problem
deﬁned
variables
deﬁnition
general
enough
include
landscapes
max-ksat
well
spin
glass
problems
paper
extend
related
concepts
multi-objective
optimiza-
tion
deﬁne
class
multi-objective
landscapes
show
generalize
previous
deﬁnitions
multi-objective
landscapes
also
show
exact
methods
used
select
improving
moves
constant
time
multi-objective
space
notion
improving
move
complex
be-
cause
improvement
improvement
objectives
improvement
part
objectives
improvement
objectives
clearly
improvement
accepted
however
improvement
subset
objectives
less
clear
moves
accepted
possible
search
algorithms
cycle
visit
previously
discovered
so-
lutions
methods
proposed
allow
identiﬁcation
improving
moves
constant
time
multi-objective
optimization
methods
also
proposed
prevent
local
search
algorithms
cycling
thus
repeatedly
revisiting
pre-
viously
discovered
solutions
results
work
could
also
introduced
existing
local
search
algorithms
multi-objective
optimization
like
anytime
pareto
local
search
rest
paper
organized
follows
next
section
intro-
duce
multi-objective
pseudo-boolean
optimization
problems
section
deﬁnes
scores
solution
score
vector
tracks
changes
evaluation
function
makes
possible
track
locations
improving
moves
algorithm
introduced
track
multiple
scores
eﬃciently
update
multi-objective
optimization
section
considers
address
prob-
lems
selecting
improving
moves
multi-objective
search
space
move
improves
objectives
section
empirically
evaluates
proposed
algorithms
section
summarizes
conclusions
outline
potential
future
work
multi-objective
pseudo-boolean
optimization
paper
consider
pseudo-boolean
vector
functions
k-bounded
epis-
tasis
component
functions
embedded
landscapes
land-
cid:88
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
scapes
extend
concept
landscapes
multi-objective
domain
thus
base
nomenclature
whitley
deﬁnition
vector
landscape
given
two
constants
vec-
tor
landscape
d-dimensional
vector
pseudo-boolean
func-
tion
deﬁned
whose
components
landscapes
com-
ponent
written
sum
subfunctions
one
depending
input
variables4
subfunctions
depend
components
l=1
deﬁnition
generalizes
aguirre
tanaka
mnk
land-
scapes
figure
show
vector
landscape
dimensions
ﬁrst
objective
function
written
sum
subfunctions
second
objective
function
writte
sum
subfunctions
subfunctions
depend
vari-
ables
could
seem
previous
class
functions
restrictive
subfunction
depends
bounded
number
variables
however
every
com-
pressible
pseudo-boolean
function
transformed
polynomial
time
quadratic
pseudo-boolean
function
useful
tool
forthcoming
analysis
co-ocurrence
graph
set
boolean
variables
contains
pairs
variables
xj1
xj2
co-occur
subfunction
variables
arguments
subfunction
terms
two
variables
xj1
xj2
co-occur
exists
subfunction
mask
j1-th
j2-th
bits
figure
show
subfunctions
vector
landscape
2-bounded
epistasis
corresponding
variable
co-occurrence
graph
consider
without
loss
generality
objectives
compo-
nents
vector
function
maximized
next
include
deﬁnition
standard
multi-objective
concepts
make
paper
self-contained
deﬁnition
dominance
given
vector
function
say
solution
dominates
solution
denoted
cid:31
exists
vector
function
clear
context
use
cid:31
instead
cid:31
deﬁnition
pareto
optimal
set
pareto
front
given
vector
function
pareto
optimal
set
set
solutions
general
use
boldface
denote
vectors
use
normal
weight
vectors
like
chicano
whitley
tin´os
vector
landscape
co-occurrence
graph
fig
vector
landscape
variables
dimensions
top
corresponding
co-occurrence
graph
bottom
dominated
solution
bn|
cid:64
cid:31
pareto
front
image
pareto
optimal
set
deﬁnition
set
non-dominated
solutions
given
vector
function
say
set
set
non-dominated
solutions
pair
solutions
cid:31
cid:64
cid:31
deﬁnition
local
optimum
given
vector
function
neighborhood
function
2bn
say
solution
local
optimum
dominated
solution
neighborhood
cid:64
cid:31
moves
hamming
ball
characterize
move
binary
string
bits
change
solution
following
extend
concept
score
vector
functions
deﬁnition
score
vector
function
denote
score
respect
move
deﬁned
follows
denotes
exclusive
bitwise
operation
sum
call
score
also
named
∆-evaluation
authors
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
score
change
vector
function
move
solution
solution
obtained
ﬂipping
bits
goal
eﬃciently
decide
move
current
solution
possible
want
apply
improving
moves
current
solution
concept
improving
move
clear
single-objective
case
improving
move
one
increases
value
objective
function
multi-objective
optimization
component
functions
could
improving
disimproving
neutral
thus
need
clear
context
deﬁne
mean
improving
move
useful
deﬁne
two
kinds
improving
moves
weak
improving
moves
strong
improving
moves
reason
distinction
clear
section
deﬁnition
strong
weak
improving
moves
given
solution
move
vector
function
say
move
weak
improving
move
exists
say
move
strong
improving
move
weak
improving
move
using
deﬁnition
score
say
move
weak
improving
move
exists
strong
improving
move
exists
deﬁnition
noticed
strong
improving
move
cid:31
concept
strong
improving
move
coincides
dominance
also
noticed
single-objective
case
concepts
strong
improving
moves
clearly
desirable
since
disimproving
objective
improve
least
one
weak
improving
moves
hand
improve
least
one
objective
could
disimprove
ones
particular
weak
strong
improving
move
solution
improve
least
one
objective
say
i-th
disimprove
least
another
one
say
j-th
move
taken
new
solution
move
weak
strong
improving
move
however
improve
least
j-th
objective
disimprove
least
i-th
taking
lead
algorithm
cycles
thus
hill
climber
taking
weak
improving
moves
include
mechanism
avoid
cycling
scores
introduced
order
eﬃciently
identify
weak
strong
improving
moves
purpose
data
structure
improving
moves
accessed
constant
time
search
progresses
score
values
change
also
move
data
structure
keep
improving
moves
separated
rest
na¨ıve
approach
track
im-
proving
moves
hamming
ball
radius
around
solution
would
require
store
possible
scores
moves
|v|
|v|
denotes
number
bits
cid:1
neighbors
hamming
ball
instead
evaluate
cid:80
naively
use
equation
explicitly
update
scores
cid:0
i=1
chicano
whitley
tin´os
objective
function
vector
landscape
fulﬁlling
requirements
described
theorem
design
eﬃcient
next
improvement
hill
climber
radius
neighborhood
stores
linear
number
scores
requires
constant
time
update
3.1
scores
update
using
fact
component
objective
vector
function
landscape
write
cid:88
cid:16
cid:17
cid:88
l=1
l=1
represent
score
subfunction
use
move
let
deﬁne
binary
string
j-th
element
depends
variable
vector
considered
mask
characterizes
variables
aﬀect
bounded
epistasis
number
ones
denoted
|wi
deﬁnition
next
equalities
immediately
follow
since
cid:40
v∧wi
otherwise
cid:88
equation
claims
none
variables
change
move
characterized
argument
score
subfunction
zero
since
value
subfunction
change
hand
depends
variables
change
need
consider
evaluation
variables
characterized
mask
vector
help
re-write
changed
variables
aﬀect
v∧wi
l=1
l∧v
cid:54
equation
simply
says
consider
subfunctions
compute
score
reduce
run
time
compute
scores
scratch
search
instead
computing
scores
using
every
move
eﬃcient
time
store
scores
current
solution
memory
update
aﬀected
move
following
abusing
notation
given
move
also
use
represent
set
variables
ﬂipped
move
addition
binary
string
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
x⊕v
scores
update
change
related
subfunction
computed
help
component
updated
subtracting
x⊕t
procedure
shown
algorithm
adding
term
represents
i-th
component
score
move
stored
memory
set
moves
whose
scores
stored
worst
na¨ıve
case
set
strings
ones
v|1
|v|
however
prove
section
3.2
vector
landscapes
need
store
scores
identify
improving
moves
ball
radius
algorithm
eﬃcient
algorithm
scores
update
input
cid:54
cid:54
end
end
3.2
scores
decomposition
scores
written
sum
scores
beneﬁt
decomposition
really
need
store
scores
memory
complete
information
inﬂuence
moves
hamming
ball
radius
objective
function
co-occurrence
graph
main
role
identifying
moves
whose
scores
fundamental
recover
improving
moves
hamming
ball
let
denote
subgraph
induced
subgraph
containing
vertices
edges
vertices
proposition
score
decomposition
let
two
moves
v1∩v2
variables
co-occur
variables
terms
co-occurrence
graph
implies
edge
variable
variable
thus
score
function
sv1∪v2
written
sv1∪v2
sv1
sv2
chicano
whitley
tin´os
proof
using
write
cid:88
cid:88
l=1
v1∨v2
cid:54
v1∪v2
v1∨v2
∧wi
v1∧wi
v2∧wi
l∧v1
l∧v2
cid:54
l=1
since
variables
co-occur
variables
cid:54
cid:54
time
write
cid:88
cid:88
v1∪v2
v1∧wi
v2∧wi
l=1
l∧v1
cid:54
l=1
l∧v2
cid:54
result
follows
cid:117
cid:116
example
vector
landscape
figure
scoring
function
s1,3,4
written
sum
scoring
functions
s3,4
used
...
denote
binary
string
positions
rest
set
consequence
proposition
need
store
scores
moves
connected
subgraph
connected
subgraph
sets
variables
applying
proposition
sv1
sv2
thus
recover
scores
hamming
ball
radius
ones
moves
|v|
connected
following
assume
set
algorithm
bn|1
|v|
connected
3.3
memory
time
complexity
scores
update
address
question
many
scores
exist
cost
time
updating
move
lemma
let
vector
landscape
boolean
variable
appears
subfunctions
number
connected
subgraphs
size
greater
co-occurrence
graph
containing
given
variable
3ck
proof
connected
subgraph
containing
ﬁnd
spanning
tree
root
degree
node
bounded
since
variable
appears
subfunctions
subfunction
depends
variables
given
tree
nodes
root
assign
variables
rest
nodes
way
two
connected
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
nodes
variables
adjacent
ways
bounded
l−1
repeat
operation
possible
rooted
trees
size
greater
number
rooted
trees
vertices
number
connected
subgraphs
containing
size
greater
nodes
bounded
cid:88
l−1
cid:88
l−1
3ck
l=1
l=1
used
result
asymptotic
behaviour
lim
l→∞
tl−1
2.955765
cid:117
cid:116
lemma
provides
bound
number
moves
contains
arbitrary
variable
eﬀect
connected
subgraphs
containing
corresponds
moves
ﬂip
variable
important
consequence
given
following
theorem
theorem
let
vector
landscape
boolean
variable
appears
subfunctions
number
connected
sub-
graphs
size
greater
3ck
linear
independent
cardinality
given
proof
set
connected
subgraphs
size
greater
union
connected
subgraphs
size
greater
contains
variables
according
lemma
cardinality
set
must
cid:117
cid:116
3ck
next
theorem
bounds
time
required
update
scores
theorem
let
vector
landscape
boolean
variable
appears
subfunctions
time
required
update
scores
using
algorithm
|t|
3ck
r+1
bound
time
required
evaluate
subfunction
proof
since
variable
appears
subfunctions
number
subfunctions
containing
least
one
bits
c|t|
number
times
body
outer
loop
starting
line
algorithm
executed
outer
loop
ﬁxed
pair
number
moves
cid:54
number
moves
contains
variable
since
|wi
using
lemma
number
moves
3ck
line
algorithm
thus
executed
|t|ck
3ck
times
considering
bound
time
evaluate
subfunctions
result
cid:117
cid:116
follows
chicano
whitley
tin´os
vector
landscape
cid:80
since
|t|
time
required
update
scores
depend
observe
number
subfunctions
i=1
hand
every
variable
appears
least
one
subfunction
otherwise
variable
could
removed
thus
consequence
multi-objective
hamming-ball
hill
climber
seen
hypothesis
theorem
linear
number
scores
provide
information
scores
hamming
ball
radius
around
solution
however
need
sum
scores
get
complete
information
improving
moves
eﬃcient
exploring
hamming
ball
order
eﬃciently
identify
improving
moves
discard
particular
discard
improving
moves
whose
scores
stored
memory
authors
proved
single-
objective
case
none
stored
scores
improving
exist
improving
move
hamming
ball
radius
around
current
solution
although
improving
moves
identiﬁed
possible
identify
local
optima
constant
time
hill
climber
reaches
desirable
property
hill
climber
prove
following
result
adapted
multi-objective
case
one
scores
stored
indicates
strong
improving
move
clear
hill
climber
local
optima
take
move
improve
current
solution
however
weak
improving
moves
found
scores
store
possible
certify
hill
climber
reached
local
optima
reason
two
weak
improving
moves
taken
together
could
give
strong
improving
move
hamming
ball
example
let
say
exploring
hamming
ball
radius
variables
co-
occur
two-dimensional
vector
function
moves
weak
improving
moves
move
s1,2
strong
improving
move
miss
strong
improving
move
exploration
discover
strong
improving
moves
hamming
ball
con-
sider
weak
improving
moves
saw
section
taking
weak
improving
moves
dangerous
could
make
algorithm
cycle
one
simple
eﬀective
mechanism
avoid
cycling
classify
weak
improving
moves
according
weighted
sum
score
components
deﬁnition
w-improving
move
w-score
let
vector
landscape
d-dimensional
weight
vector
say
move
w-improving
solution
denotes
dot
product
vectors
call
w-score
move
solution
proposition
let
vector
landscape
d-dimensional
weight
vector
exists
strong
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
improving
move
ball
radius
around
solution
exists
radius
exist
moves
cid:80
since
strong
improving
cid:80
proof
let
say
strong
improving
move
hamming
ball
l=1
svl
l=1
svl
cid:117
cid:116
must
svl
proposition
ensures
miss
strong
improving
move
hamming
ball
take
weak
improving
moves
improving
w-score
thus
proposed
hill
climber
shown
algorithm
select
strong
improving
moves
ﬁrst
place
line
w-improving
moves
strong
improving
moves
available
line
last
case
report
value
solution
since
could
non-dominated
solution
line
algorithm
stop
w-improving
move
available
case
local
optima
reached
report
ﬁnal
locally
optimal
solution
line
algorithm
cycle
since
w-improving
moves
selected
means
improvement
required
direction
cycle
would
require
take
w-disimproving
move
step
climb
strong
improving
move
algorithm
multi-objective
hamming-ball
hill
climber
input
scores
vector
weight
vector
initial
solution
output
local
optimum
potentially
non-dominated
intermediate
solutions
computescores
end
updatescores
end
report
selectstrongimprovingmove
selectwimprovingmove
report
else
procedure
report
algorithm
add
reported
solution
external
set
non-dominated
solutions
set
managed
high-level
algorithm
invoking
hamming
ball
hill
climber
eﬃcient
implementation
algorithm
scores
stored
memory
classiﬁed
three
categories
one
stored
diﬀerent
bucket
strong
improving
moves
w-improving
moves
strong
improving
moves
rest
scores
moved
one
buckets
updated
move
one
bucket
another
requires
constant
time
chicano
whitley
tin´os
thus
expected
time
per
move
algorithm
excluding
time
required
report
implementation
corresponds
next
improvement
hill
climber
approximate
form
best
improvement
hill
climber
could
also
implemented
following
guidelines
weight
vector
hill
climber
determines
direction
explore
objective
space
use
select
weak
improving
moves
equivalent
consider
improving
moves
single-objective
function
however
two
main
reasons
convenient
update
deal
vector
scores
rather
using
scalar
scores
first
using
vector
scores
identify
strong
improving
moves
stored
memory
using
scalar
scores
possible
distinguish
weak
strong
improving
moves
second
possible
change
search
without
re-computing
scores
operation
change
re-classiﬁcation
moves
strong
improving6
regarding
selection
improving
moves
selectstrongimprovingmove
selectwimprovingmove
implementation
selects
always
random
one
lowest
hamming
distance
current
solution
move
lowest
value
|t|
stated
theorem
moves
faster
principle
distant
moves
since
time
required
updating
scores
proportional
|t|
experimental
results
implemented
simple
multi-start
hill
climber
algorithm
measure
runtime
speedup
proposed
multi-objective
hamming
ball
hill
climber
algorithm
algorithm
iterates
loop
solution
weight
vector
randomly
generated
algorithm
executed
starting
algorithm
keeps
set
non-dominated
solutions
potentially
updated
whenever
algorithm
reports
solution
loop
stops
given
time
limit
reached
experiments
shown
time
limit
minute
machine
used
experiments
intel
core
quad
cpu
q9400
2,7
ghz
3gb
memory
ubuntu
14.04
lts
one
core
processor
used
algorithm
implemented
java
1.6.
test
algorithm
focused
mnk-landscapes
mnk-
landscape
vector
landscape
subfunction
depends
variables
thus
k+1
subfunctions
randomly
generated
using
real
values
order
avoid
inaccuracy
problems
ﬂoating
point
arithmetic
instead
real
numbers
use
integer
number
q−1
sum
subfunctions
divided
component
nkq-landscape
also
focused
adjacent
model
nkq-landscape
model
distinguishing
weak
strong
improving
moves
strong
disim-
proving
moves
implementation
would
reduce
runtime
since
weak
improving
moves
need
re-classiﬁed
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
variables
depends
consecutive
xi+1
xi+k
ensures
number
subfunctions
given
variable
appears
bounded
constant
particular
theorems
apply
5.1
runtime
two
procedures
hill
climber
requires
time
ﬁrst
one
problem-dependent
initialization
procedure
scores
stored
memory
determined
procedure
run
one
run
multi-start
algorithm
experiments
time
varies
284
5,377
milliseconds
second
procedure
solution-dependent
initialization
hill
climber
starting
random
solution
weight
vector
procedure
run
iteration
multi-start
hill
climber
loop
important
impact
algorithm
runtime
especially
many
moves
execution
algorithm
hand
search
progresses
non-dominated
set
solutions
grows
procedure
update
could
also
require
non-negligible
run
time
depends
number
solutions
non-dominated
set
could
proportional
number
moves
done
search
figure
show
average
time
per
move
microseconds
multi-start
hill
climber
solving
mnk-landscapes
varies
000
100
000
100
dimensions
exploration
radius
varies
performed
independent
runs
algorithm
conﬁguration
results
average
runs
compute
average
excluded
time
required
problem-
dependent
initialization
procedure
observe
moves
done
fast
tens
hundreds
mi-
croseconds
especially
surprising
consider
number
solutions
explored
neighborhood
100
000
neighborhood
contains
around
166
trillion
solutions
explored
around
millisec-
ond
values
increase
average
time
per
move
slow
grows
slight
growth
average
run
time
due
solution-dependent
initialization
non-dominated
set
update
contrasts
theoretically
time
required
black
box
algorithm
could
expect
value
great
inﬂuence
average
time
per
move
fact
time
exponential
regarding
memory
required
store
scores
already
seen
particular
case
mnk-landscapes
adjacent
interaction
model
n/k
hard
conclude
exact
number
scores
linear
5.2
quality
solutions
second
experiment
want
check
large
value
leads
better
solutions
highly
depends
algorithm
includes
hill
climber
chicano
whitley
tin´os
fig
average
time
per
move
multi-start
hill
climber
based
algo-
rithm
mnk-landscape
100
000
100
000
case
since
algorithm
multi-start
hill
climber
would
expect
improvement
solution
quality
increase
time
average
time
per
move
increased
thus
must
value
time
large
lower
values
radius
lead
solution
quality
figure
show
-empirical
attainment
surfaces
fronts
obtained
independent
runs
multi-start
hill
climber
000
100
varying
-empirical
attainment
surface
-eas
limits
region
objective
space
dominated
half
runs
algorithm
generalizes
concept
median
multi-objective
case
see
details
see
figure
-eas
obtained
completely
dominates
one
obtained
-eas
dominates
increasing
obtained
better
approximated
pareto
fronts
even
time
per
move
increased
means
less
moves
done
int
given
time
limit
minute
eﬀective
100
200
300
400
500
600
700
800
900
1000
1100102030405060708090100average
time
per
move
microseconds
number
variables
thousands
r=1
d=2r=1
d=3r=2
d=2r=2
d=3r=3
d=2r=3
d=3
eﬃcient
hill-climber
multi-objective
pseudo-boolean
optimization
fig
-empirical
attainment
surfaces
independent
runs
multi-
start
hill
climber
based
algorithm
mnk-landscape
100
000
conclusions
future
work
proposed
paper
hill
climber
based
eﬃcient
mechanism
identify
improving
moves
hamming
ball
radius
around
solution
k-bounded
pseudo-boolean
multi-objective
optimization
problem
paper
contribute
active
line
research
sometimes
called
gray-box
optimization
suggests
use
much
information
problems
possible
provide
better
search
methods
contrast
black-box
opti-
mization
proposed
hill
climber
performs
move
bounded
constant
time
variables
problem
appears
constant
number
subfunctions
practice
experiments
adjacent
mnk-landscapes
show
average
time
per
move
varies
tenths
hundreds
microseconds
exploration
radius
grows
number
independent
despite
fact
hill
climber
considering
hamming
ball
radius
solutions
work
needed
integrate
hill
climber
higher-level
algo-
rithm
including
mechanisms
escape
plateaus
local
optima
600000
610000
620000
630000
640000
650000
660000
670000
610000
630000
650000f2f1r=1r=2r=3
chicano
whitley
tin´os
hand
one
important
limitation
hill
climber
take
account
constraints
search
space
constraint
management
combination
components
build
eﬃcient
search
algorithm
seem
two
promising
challenging
directions
work
near
future
references
aguirre
h.e.
tanaka
insights
properties
multiobjective
mnk-landscapes
evolutionary
computation
2004.
cec2004
congress
vol
196–203
vol.1
june
2004
chen
whitley
hains
howe
second
order
partial
derivatives
nk-landscapes
proceeding
gecco
503–510
acm
new
york
usa
2013
chicano
whitley
sutton
a.m.
eﬃcient
identiﬁcation
improving
moves
ball
pseudo-boolean
problems
proceedings
genetic
evolutionary
computation
conference
437–444
acm
new
york
usa
2014
crama
hansen
jaumard
basic
algorithm
pseudo-boolean
pro-
gramming
revisited
discrete
applied
mathematics
2-3
171–185
1990
dubois-lacoste
nez
m.l.i.
st¨utzle
anytime
pareto
local
search
eu-
ropean
journal
operational
research
243
369–385
2015
http
//www
sciencedirect.com/science/article/pii/s0377221714009011
goldman
b.w.
punch
w.f
gray-box
optimization
using
parameter-less
population
pyramid
proceedings
genetic
evolutionary
computation
conference
855–862
acm
new
york
usa
2015
heckendorn
rana
whitley
test
function
generators
embedded
land-
scapes
foundations
genetic
algorithms
183–198
morgan
kaufmann
1999
hoos
h.h.
st¨utzle
stochastic
local
search
foundations
applications
morgan
kaufman
2004
knowles
summary-attainment-surface
plotting
method
visualizing
performance
stochastic
multiobjective
optimizers
proceedings
intelligent
systems
design
applications
552–557
sept
2005
10.
otter
number
trees
annals
mathematics
583–599
1948
11.
paquete
schiavinotto
st¨utzle
local
optima
multiobjective
com-
binatorial
optimization
problems
annals
operations
research
156
83–97
2007
12.
rosenberg
i.g
reduction
bivalent
maximization
quadratic
case
cahiers
centre
etudes
rech
oper
71–74
1975
13.
taillard
robust
taboo
search
quadratic
assignment
problem
parallel
comput
4-5
443–455
jul
1991
14.
whitley
howe
hains
greedy
best
improving
versus
ﬁrst
im-
proving
stochastic
local
search
maxsat
proc.of
aaai-2013
2013
15.
whitley
landscapes
landscapes
max-ksat
proof
challenging
problems
deceptive
proceedings
genetic
evolutionary
computation
conference
927–934
acm
new
york
usa
2015
16.
whitley
chen
constant
time
steepest
descent
local
search
lookahead
nk-landscapes
max-ksat
soule
moore
j.h
eds
gecco
1357–1364
acm
2012
