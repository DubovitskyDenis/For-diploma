essence
cid:48
description
1.6.4
peter
nightingale
andrea
rendl
introduction
purpose
document
describe
essence
cid:48
language
reference
users
essence
cid:48
essence
cid:48
constraint
modelling
language
therefore
mainly
designed
describing
np-hard
decision
prob-
lems
ﬁrst
constraint
modelling
language
essence
cid:48
began
subset
essence
extended
similar
earlier
optimization
programming
language
opl
essence
cid:48
implemented
tool
savile
row
essence
cid:48
considerably
different
procedural
programming
languages
specify
procedure
solve
problem
user
speciﬁes
problem
terms
decision
variables
constraints
solver
automatically
ﬁnds
value
variable
constraints
satisﬁed
means
example
order
constraints
presented
essence
cid:48
irrelevant
essence
cid:48
allows
user
solve
constraint
satisfaction
problems
csps
simple
example
csp
sudoku
puzzle
figure
convert
single
sudoku
puzzle
csp
square
represented
decision
variable
domain
clues
ﬁlled
squares
rules
puzzle
easily
expressed
constraints
use
sudoku
running
example
simple
ﬁrst
attempt
modelling
sudoku
essence
cid:48
shown
case
clues
example
1,1
included
model
used
not-equal
constraints
state
digits
must
used
row
column
also
omitted
sub-square
constraints
language
essence
1.0
find
matrix
indexed
int
1..9
int
1..9
int
1..9
1,1
1,2
1,5
...
9,9
forall
row
int
1..9
forall
col1
int
1..9
forall
col2
int
col1+1..9
row
col1
row
col2
forall
col
int
1..9
forall
row1
int
1..9
forall
row2
int
row1+1..9
row1
col
row2
col
example
csp
decision
variables
declared
using
find
statement
also
worth
noting
variables
exist
decision
variables
example
row
quantiﬁer
variable
exists
apply
constraints
every
row
figure
left
sudoku
puzzle
objective
ﬁll
blank
squares
using
digits
1-9
row
contains
digits
1-9
column
also
contains
digits
1-9
subsquares
outlined
thicker
lines
also
contains
digits
1-9.
right
solution
images
public
domain
wikipedia
essence
cid:48
model
usually
describes
class
csps
example
might
describe
class
sudoku
puzzles
order
solve
particular
instance
sudoku
instance
would
speciﬁed
separate
parameter
ﬁle
also
written
essence
cid:48
model
would
parameter
variables
type
integer
boolean
matrix
parameter
ﬁle
would
specify
value
variables
since
essence
cid:48
constraint
modelling
language
deﬁne
constraint
satisfaction
problem
csp
csp
cid:104
cid:105
deﬁned
set
decision
variables
cid:104
cid:105
set
domains
cid:104
cid:105
cid:40
ﬁnite
set
potential
values
conjunction
···
constraints
csp
cid:104
cid:105
constraint
consists
sequence
variables
cid:104
xk1
xkm
cid:105
domains
cid:104
xk1
xkm
cid:105
s.t
subsequence1
subsequence
variable
xki
xk1
×···×d
xkm
domain
xki
matches
variable
domain
associated
set
tuples
specify
allowed
combinations
values
variables
essence
cid:48
expression
language
essence
cid:48
expressions
built
variables
literals
using
operators
start
describing
types
expressions
may
take
describe
simplest
expressions
build
2.1
types
domains
types
domains
play
similar
role
prescribe
set
values
expression
variable
take
types
denote
non-empty
sets
contain
elements
similar
structure
whereas
domains
denote
possibly
empty
sets
drawn
single
type
manner
domain
associated
underlying
type
example
integer
type
underlying
domain
comprising
integers
10.
type
contains
integers
domain
ﬁnite
subset
essence
cid:48
strongly
typed
language
every
expression
type
types
expressions
inferred
checked
correctness
furthermore
essence
cid:48
ﬁnite-domain
language
every
decision
variable
associated
ﬁnite
domain
values
atomic
types
essence
cid:48
int
integer
bool
boolean
also
compound
type
matrix
constructed
atomic
types
use
subsequence
sense
cid:104
cid:105
subsequence
cid:104
cid:105
essence
cid:48
description
1.6.4
three
different
types
domains
essence
cid:48
boolean
integer
matrix
domains
boolean
integer
domains
atomic
domains
matrix
domains
built
atomic
domains
boolean
domains
bool
boolean
domain
consisting
false
true
integer
domains
integer
domain
represents
ﬁnite
subset
integers
speciﬁed
sequence
ranges
individual
elements
example
int
1..3,5,7,9..20
range
includes
endpoints
meaning
range
a..b
set
z|a
range
a..b
would
normally
order
i.e
strictly
required
out-of-order
ranges
correspond
empty
set
integers
meaning
integer
domain
union
ranges
individual
elements
domain
example
int
1..5
4..9
equivalent
int
1..10
finally
elements
endpoints
ranges
may
expressions
type
int
restriction
may
contain
csp
decision
variables
integer
expression
language
described
following
sections
matrix
domains
matrix
deﬁned
keyword
matrix
followed
dimensions
base
domain
dimensions
list
square
brackets
domains
instance
matrix1
matrix
indexed
int
1..10
int
1..10
int
1..5
domain
two-dimensional
square
matrix
indexed
1..10
dimensions
element
matrix
domain
int
1..5
elements
matrix
would
accessed
matrix1
integer
expressions
matrices
may
indexed
integer
domain
boolean
domain
example
matrix2
matrix
indexed
int
-2..5
int
-10..10,15,17
int
1..5
valid
matrix
domain
2.2
domain
expressions
essence
cid:48
contains
small
expression
language
boolean
integer
domains
language
consists
three
binary
inﬁx
operators
intersect
union
three
left-associative
precedences
given
appendix
language
also
allows
bracketed
subexpressions
example
ﬁrst
second
lines
exactly
equivalent
letting
dom
domain
int
1..5
3..8
letting
dom
domain
int
1..5
union
int
3..8
2.3
literals
three
types
integer
boolean
matrix
corresponding
literal
syntax
essence
cid:48
value
type
may
written
literal
sets
real
numbers
yet
part
language
integer
boolean
literals
straightforward
true
false
two
forms
matrix
literals
simpler
form
comma-separated
list
expressions
surrounded
square
brackets
example
following
matrix
literal
containing
four
integer
literals
essence
cid:48
description
1.6.4
matrix
literals
may
contain
valid
expression
essence
cid:48
example
matrix
literal
allowed
contain
matrix
literals
build
matrix
two
dimensions
types
expressions
contained
matrix
literal
must
second
form
matrix
literal
explicit
index
domain
speciﬁes
literal
indexed
speciﬁed
comma-separated
list
contents
using
follows
int
4..6,8
index
domain
must
domain
type
bool
int
must
contain
number
values
number
items
matrix
literal
index
domain
speciﬁed
matrix
size
indexed
int
1..n
finally
multi-dimensional
matrix
value
expressed
nesting
matrix
literals
suppose
following
domain
matrix
indexed
int
-2..0
int
1,2,4
int
1..5
one
value
contained
domain
following
1,2,3
int
1,2,4
1,3,2
int
1,2,4
3,2,1
int
1,2,4
int
-2..0
2.4
variables
variables
identiﬁed
string
variable
names
must
start
letter
a-z
a-z
ﬁrst
letter
may
contain
following
characters
a-z
a-z
0-9
variable
may
type
integer
boolean
matrix
scoping
variables
depends
declared
dealt
relevant
sections
well
type
variables
category
category
decision
quantiﬁer
parameter
decision
variables
csp
variables
categories
described
expressions
containing
decision
variables
referred
decision
expressions
expressions
containing
de-
cision
variables
non-decision
expressions
distinction
important
expressions
certain
contexts
allowed
contain
decision
variables
2.5
expression
types
expressions
three
basic
types
integer
boolean
matrix
integer
expressions
range
integer
domain
instance
integer
variable
integer
expression
ranging
boolean
expressions
range
boolean
domain
instance
integer
comparison
either
true
false
2.6
type
conversion
boolean
expressions
literals
automatically
converted
integers
used
context
expects
integer
conventional
false
converted
true
converted
example
following
valid
essence
cid:48
boolean
expressions
1+2-3+true-
false
true
integer
expressions
automatically
converted
boolean
matrix
expressions
converted
type
vice
versa
essence
cid:48
description
1.6.4
2.7
matrix
indexing
slicing
suppose
three-dimensional
matrix
following
domain
matrix
indexed
int
1..3
int
1..3
bool
int
1..5
would
indexed
follows
may
integer
boolean
expressions
must
boolean
matrix
base
domain
int
1..5
integer
expression
matrix
indexing
partial
function
one
indices
bounds
expression
undeﬁned
essence
cid:48
relational
semantics
brief
means
boolean
expression
containing
undeﬁned
expression
false
example
1,1
false
2,4
true
always
false
bounds
relational
semantics
fully
described
section
parts
matrices
extracted
slicing
suppose
following
two-dimensional
matrix
named
1,2,3
int
1,2,4
1,3,2
int
1,2,4
3,2,1
int
1,2,4
int
-2..0
could
obtain
ﬁrst
row
writing
equal
1,2,3
int
1..3
similarly
ﬁrst
column
obtained
..,1
1,1,3
int
1..3
general
indices
matrix
slice
may
integer
boolean
expression
contain
decision
variables
matrix
slices
always
indexed
contiguously
regardless
original
matrix
domain
matrix
slice
integer
boolean
index
bounds
expression
undeﬁned
handled
described
section
integer
boolean
expressions
2.8
essence
cid:48
range
binary
inﬁx
unary
operators
functions
building
integer
boolean
expressions
example
integer
operators
min
max
boolean
operators
quantiﬁed
sum
sum
logical
quantiﬁers
forall
exists
numerical
comparison
operators
matrix
comparison
operators
=lex
lex
=lex
lex
set
operator
global
constraints
alldiff
gcc
table
constraint
table
described
following
subsections
essence
cid:48
description
1.6.4
2.8.1
integer
operators
essence
cid:48
following
binary
integer
operators
standard
integer
operators
always
rounds
operators
integer
division
modulo
functions
a/b
deﬁned
cid:98
a/b
cid:99
i.e
match
programming
languages
example
c99
rounds
towards
modulo
operator
deﬁned
cid:98
a/b
cid:99
complementary
3/2
power
function
x**y
deﬁned
two
unary
functions
absolute
value
|x|
absolute
value
negation
unary
2.8.2
boolean
operators
essence
cid:48
operators
deﬁned
boolean
expressions
also
implies
negation
operators
take
boolean
expressions
produce
new
boolean
expression
nested
arbitrarily
comma
essence
cid:48
also
binary
boolean
operator
meaning
however
different
precedence
used
quite
differently
normally
used
within
constraint
used
separate
constraints
separate
groups
constraints
constructed
using
forall
consider
following
example
forall
int
1..n
i+1
exists
int
1..n
i+1
two
quantiﬁers
inside
comma
used
separate
forall
exists
comma
lowest
precedence
binary
operators
2.8.3
integer
boolean
functions
essence
cid:48
named
functions
min
max
take
two
integer
expressions
min
max
also
applied
one-dimensional
matrices
obtain
minimum
maximum
elements
matrix
see
section
2.10
factorial
returns
factorial
values
result
ﬁts
64-bit
signed
integer
undeﬁned
values
expression
allowed
contain
decision
variables
popcount
returns
bit
count
64-bit
two
complement
representation
may
contain
decision
variables
function
toint
takes
boolean
expression
converts
integer
function
included
compatibility
essence
needed
essence
cid:48
booleans
automatically
cast
integers
2.8.4
numerical
comparison
operators
essence
cid:48
provides
following
integer
comparisons
obvious
meanings
opera-
tors
take
two
integer
expressions
produce
boolean
expression
essence
cid:48
description
1.6.4
2.8.5
matrix
comparison
operators
essence
cid:48
provides
way
comparing
one-dimensional
matrices
operators
compare
two
matrices
using
dictionary
order
lexicographical
order
lex
short
four
operators
lex
ensures
comes
lex
order
=lex
ensures
lex
a=b
=lex
lex
identical
arguments
reversed
four
operators
may
different
lengths
may
indexed
differently
must
one-dimensional
multi-dimensional
matrices
may
ﬂattened
one
dimension
using
flatten
function
described
section
2.10
2.8.6
set
operator
operator
states
integer
expression
takes
value
set
expression
set
espression
may
contain
decision
variables
set
may
domain
expression
section
2.2
toset
function
converts
matrix
set
examples
x+y
int
1,3,5
intersect
int
3..10
x+y
toset
int
1..n
2=0
2.8.7
quantiﬁed
sum
operator
sum
operator
corresponds
mathematical
cid:80
following
syntax
sum
quantiﬁer
variable
domain
expression
contained
within
sum
one
quantiﬁer
variable
may
created
writing
comma-separated
list
example
want
take
sum
numbers
range
write
sum
int
1..n
corresponds
cid:80
i=1
decision
variable
quantiﬁed
sum
several
similarities
forall
exists
quantiﬁers
described
section
2.8.8
introduces
new
local
variables
named
quantiﬁer
variables
used
within
quantiﬁer
variables
domain
however
sum
one
important
difference
sum
integer
expression
quantiﬁed
sum
may
nested
inside
integer
operator
including
another
quantiﬁed
sum
sum
int
1..10
sum
int
i..10
2.8.8
universal
existential
quantiﬁcation
universal
existential
quantiﬁcation
powerful
means
write
series
constraints
compact
way
quantiﬁcations
syntax
sum
forall
exists
keywords
forall
exists
instance
universal
quantiﬁcation
forall
int
1..3
corresponds
conjunction
essence
cid:48
description
1.6.4
example
existential
quantiﬁcation
exists
int
1..3
corresponds
following
disjunction
quantiﬁcations
range
several
quantiﬁed
variables
arbitrarily
nested
demonstrated
sum
quantiﬁer
running
sudoku
example
forall
quantiﬁcation
used
build
set
constraints
expression
forall
row
int
1..9
forall
col1
int
1..9
forall
col2
int
col1+1..9
row
col1
row
col2
typical
use
universal
quantiﬁcation
2.8.9
quantiﬁcation
matrix
domains
three
quantiﬁers
deﬁned
matrix
domains
well
integer
boolean
domains
example
quantify
permutations
size
forall
perm
matrix
indexed
int
1..n
int
1..n
alldiff
perm
exp
variable
perm
represents
matrix
drawn
matrix
domain
alldiff
constraint
evaluates
true
perm
permutation
hence
expression
exp
quantiﬁed
permutations
constant
example
could
written
set
nested
forall
quantiﬁers
however
parameter
problem
class
difﬁcult
write
example
using
non-matrix
quantiﬁers
2.8.10
global
constraints
essence
cid:48
provides
small
set
global
constraints
alldiff
satisﬁed
vector
variables
take
different
values
global
constraints
boolean
expressions
essence
cid:48
typically
worth
using
models
solver
often
performs
better
global
constraint
compared
set
simpler
constraints
example
following
two
lines
semantically
equivalent
assuming
matrix
indexed
1..n
forall
int
1..n
alldiff
lines
ensure
variables
take
different
values
however
alldiff
perform
better
situations.2
table
summarises
global
constraints
available
essence
cid:48
alldiff
global
constraint
sudoku
example
improved
simpliﬁed
follows
language
essence
1.0
find
matrix
indexed
int
1..9
int
1..9
int
1..9
2in
current
version
savile
row
default
settings
constraints
would
aggregated
create
alldiff
therefore
difference
performance
two
statements
would
difference
performance
aggregation
switched
example
using
-o1
ﬂag
essence
cid:48
description
1.6.4
description
ensures
expressions
take
distinct
values
solution
non-decision
expression
global
constraint
alldiff
arguments
matrix
atleast
vals
atmost
vals
gcc
vals
alldifferent_except
value
matrix
vals
matrix
non-decision
expressions
vals
number
occurrences
matrix
non-decision
expressions
matrix
vals
matrix
non-decision
expressions
vals
number
occurrences
matrix
non-decision
expressions
matrix
vals
matrix
non-decision
expressions
vals
number
occurrences
matrix
matrix
value
non-decision
expression
vals
non-decision
expression
vals
least
non-decision
expression
vals
equals
ensures
variables
take
distinct
values
except
value
may
occur
number
times
table
global
constraints
essence
cid:48
may
nested
within
expressions
arbitrary
expressions
nested
within
matrix
parameter
global
constraint
must
one-dimensional
matrix
cases
param-
eter
matrix
non-decision
expressions
integer
boolean
expressions
contain
decision
variables
quantiﬁer
parameter
variables
allowed
non-decision
expressions
1,1
1,2
1,5
...
9,9
forall
row
int
1..9
alldiff
row
forall
col
int
1..9
alldiff
col
global
constraints
boolean
expressions
like
allowed
used
context
accepts
boolean
expression
2.8.11
table
constraints
table
constraint
satisfying
tuples
constraint
speciﬁed
using
matrix
allows
table
constraint
theoretically
implement
relation
although
practically
limited
relations
set
satisfying
tuples
small
enough
store
memory
efﬁciently
search
ﬁrst
argument
speciﬁes
variables
scope
constraint
second
argument
two-dimensional
matrix
satisfying
tuples
example
constraint
a+b=c
boolean
variables
could
written
table
follows
table
0,0,0
0,1,1
1,0,1
ﬁrst
argument
table
one-dimensional
matrix
expression
may
contain
decision
variables
constants
second
argument
two-dimensional
matrix
expression
containing
decision
variables
second
argument
stated
matrix
literal
identiﬁer
slicing
higher-dimension
matrix
constructing
matrix
using
matrix
comprehensions
see
section
2.9
essence
cid:48
description
1.6.4
matrix
tuples
used
many
table
constraints
letting
statement
used
state
matrix
use
many
times
lettings
described
section
3.2
2.9
matrix
comprehensions
seen
matrices
may
written
explicitly
matrix
literal
section
2.3
existing
matrices
indexed
sliced
section
2.7
matrices
also
constructed
using
matrix
comprehensions
provides
ﬂexible
way
create
matrices
variables
values
single
matrix
comprehension
creates
one-dimensional
matrix
however
nested
create
multi-dimensional
matrices
two
syntactic
forms
matrix
comprehension
exp
domain1
domain2
cond1
cond2
exp
domain1
domain2
cond1
cond2
indexdomain
exp
integer
boolean
matrix
expression
followed
number
comprehension
variables
domain
comprehension
variables
optional
list
conditions
boolean
expres-
sions
constrain
values
comprehension
variables
finally
optional
index
domain
provides
index
domain
constructed
matrix
expand
comprehension
assignment
comprehension
variables
satisﬁes
conditions
enu-
merated
lexicographic
order
assignment
values
comprehension
variables
substituted
exp
resulting
expression
becomes
one
element
constructed
matrix
simplest
matrix
comprehensions
one
comprehension
variable
example
num**2
num
int
1..5
1,4,9,16,25
int
1..5
matrix
constructed
comprehension
one-dimensional
either
indexed
contiguously
given
index
domain
given
domain
must
lower
bound
allowed
upper
bound
example
ﬁrst
line
produces
matrix
second
line
i+j
int
1..3
int
1..3
int
7..
int
7..9
matrix
comprehensions
allow
advanced
forms
slicing
matrix
slice
syntax
section
2.7.
example
possible
slice
arbitrary
subset
rows
columns
two-dimensional
matrix
following
two
nested
comprehensions
slice
entries
matrix
rows
columns
odd-numbered
build
new
two-dimensional
matrix
int
1..n
2=1
int
1..n
2=1
matrix
comprehensions
sudoku
example
completed
adding
constraints
subsquares
comprehension
used
create
matrix
variables
matrix
used
parameter
alldiff
constraint
language
essence
1.0
find
matrix
indexed
int
1..9
int
1..9
int
1..9
1,1
1,2
1,5
...
9,9
essence
cid:48
description
1.6.4
function
sum
product
min
max
flatten
description
constructs
sum
elements
constructs
product
elements
arguments
one-dimensional
matrix
one-dimensional
matrix
one-dimensional
matrix
booleans
constructs
conjunction
one-dimensional
matrix
booleans
constructs
disjunction
one-dimensional
matrix
one-dimensional
matrix
matrix
flatten
matrix
toset
one-dimensional
matrix
non-decision
expressions
integer
minimum
elements
integer
maximum
elements
constructs
one-dimensional
matrix
indexed
contiguously
contents
ﬁrst
n+1
dimensions
ﬂattened
one
dimension
indexed
contiguously
therefore
flatten
produces
new
matrix
fewer
dimensions
ﬁrst
argument
must
positive
flatten
returns
unchanged
set
elements
table
matrix
functions
forall
row
int
1..9
alldiff
row
forall
col
int
1..9
alldiff
col
3x3
subsquare
all-different
indicate
top-left
corner
subsquare
forall
int
1,4,7
alldiff
int
i..i+2
int
j..j+2
example
matrix
constructed
comprehension
depends
values
forall
quantiﬁer
comprehension
variables
take
one
three
values
cover
entries
subsquare
2.9.1
matrix
comprehensions
matrix
domains
similarly
quantiﬁers
matrix
comprehension
variables
matrix
domain
example
following
compre-
hension
builds
two-dimensional
matrix
rows
permutations
1..n.
perm
perm
matrix
indexed
int
1..n
int
1..n
alldiff
perm
2.10
functions
matrices
table
lists
matrix
functions
available
essence
cid:48
functions
sum
product
originally
intended
used
matrix
comprehensions
used
matrix
quantiﬁers
sum
forall
exists
replaced
sum
containing
matrix
comprehensions
example
consider
forall
expression
sudoku
model
replaced
second
line
forall
row
int
1..9
alldiff
row
essence
cid:48
description
1.6.4
alldiff
row
row
int
1..9
fact
matrix
functions
combined
matrix
comprehensions
strictly
powerful
quantiﬁers
also
function
product
corresponding
quantiﬁer
quantiﬁers
retained
language
easier
read
advanced
example
given
matrix
decision
variables
sum
determinant
using
leibniz
formula
outermost
comprehension
constructs
permutations
using
matrix
domain
alldiff
lines
contain
comprehension
used
obtain
number
inversions
perm
number
pairs
values
ascending
order
finally
line
builds
product
entries
matrix
without
product
function
difﬁcult
perhaps
impossible
write
leibniz
formula
essence
cid:48
matrix
unknown
size
sum
sum
perm
idx1
perm
idx2
calculate
sign
perm
number
inversions
product
perm
int
1..n
idx1
int
1..n
idx2
int
1..n
idx1
idx2
perm
matrix
indexed
int
1..n
int
1..n
alldiff
perm
flatten
function
typically
used
feed
contents
multi-dimensional
matrix
expression
constraint
accepts
one-dimensional
matrices
example
given
three-dimensional
matrix
following
example
typical
use
flatten
alldiff
flatten
ﬂattening
matrix
create
new
matrix
order
elements
deﬁned
follows
suppose
written
matrix
literal
section
2.3
order
elements
written
matrix
literal
order
elements
appear
following
example
illustrates
three-dimensional
matrix
flatten
1,2
3,4
5,6
7,8
1,2,3,4,5,6,7,8
model
structure
essence
cid:48
model
structured
following
way
header
version
number
language
essence
1.0
parameter
declarations
optional
constant
deﬁnitions
optional
decision
variable
declarations
optional
constraints
parameter
values
optional
objective
optional
solver
control
optional
constraints
parameter
declaration
constant
deﬁnitions
decision
variable
declarations
interleaved
readability
suggest
put
order
given
comments
preceded
run
end
line
parameter
values
deﬁned
separate
ﬁle
parameter
ﬁle
parameter
ﬁles
header
problem
models
hold
list
parameter
deﬁnitions
table
gives
overview
model
structure
problem
parameter
ﬁles
model
part
discussed
detail
following
sections
essence
cid:48
description
1.6.4
problem
model
structure
language
essence
1.0
parameter
file
structure
language
essence
1.0
parameter
instantiation
letting
n=7
parameter
declaration
given
int
constant
deﬁnition
letting
c=5
variable
declaration
find
int
1..n
constraints
c*y
table
model
structure
problem
ﬁles
parameter
ﬁles
essence
cid:48
denotes
comments
3.1
parameter
declarations
given
parameters
declared
given
keyword
followed
domain
parameter
ranges
parameters
allowed
range
inﬁnite
domain
int
domains
contain
open
range
int
1..
int
..10
example
given
int
0..
given
int
0..n
declares
two
parameters
domain
second
depends
value
ﬁrst
parameters
may
integer
boolean
matrix
domains
parameters
generalise
sudoku
model
represent
problem
class
sudoku
puzzles
parameter
clues
matrix
blank
spaces
represented
non-zero
entries
clues
copied
language
essence
1.0
given
clues
matrix
indexed
int
1..9
int
1..9
int
0..9
find
matrix
indexed
int
1..9
int
1..9
int
1..9
forall
row
int
1..9
forall
col
int
1..9
clues
row
col
row
col
=clues
row
col
forall
row
int
1..9
alldiff
row
forall
col
int
1..9
alldiff
col
essence
cid:48
description
1.6.4
3x3
subsquare
all-different
indicate
top-left
corner
subsquare
forall
int
1,4,7
alldiff
int
i..i+2
int
j..j+2
3.2
constant
deﬁnitions
letting
problem
models
re-occurring
constant
values
useful
deﬁne
constants
letting
statement
allows
assign
name
constant
value
statement
letting
name
introduces
new
identiﬁer
name
associated
expression
every
subsequent
occurrence
name
model
replaced
value
please
note
name
used
model
deﬁned
may
integer
boolean
matrix
expression
contain
decision
variables
integer
examples
shown
given
int
0..
letting
letting
c*n*2
second
integer
constant
depends
ﬁrst
well
integer
boolean
expressions
lettings
may
contain
matrix
expressions
example
using
matrix
literal
domain
optional
two
lettings
equivalent
version
matrix
domain
may
useful
matrix
indexed
letting
cmatrix
2,8,5,1
3,7,9,4
letting
cmatrix2
matrix
indexed
int
1..2
int
1..4
int
1..10
2,8,5,1
3,7,9,4
finally
new
matrices
may
constructed
using
slice
comprehension
example
letting
used
table
table
constraint
letting
xor_table
bool
bool
bool
find
bool
table
xor_table
3.2.1
constant
domains
constant
domains
deﬁned
similar
way
using
keywords
domain
letting
given
int
1..
letting
index
domain
int
1..c*n
example
index
deﬁned
integer
domain
upper
bound
depends
parameter
another
constant
use
letting
domain
int
1..9
constant
domains
convenient
domain
reused
several
times
sudoku
running
example
could
essence
cid:48
description
1.6.4
language
essence
1.0
letting
range
domain
int
1..9
given
clues
matrix
indexed
range
range
int
0..9
find
matrix
indexed
range
range
range
forall
row
range
forall
col
range
clues
row
col
row
col
=clues
row
col
forall
row
range
alldiff
row
forall
col
range
alldiff
col
3x3
subsquare
all-different
indicate
top-left
corner
subsquare
forall
int
1,4,7
alldiff
int
i..i+2
int
j..j+2
3.3
decision
variable
declaration
find
decision
variables
declared
using
find
keyword
followed
name
corresponding
domain
domain
must
ﬁnite
example
find
int
1..10
deﬁnes
single
decision
variable
given
domain
possible
deﬁne
several
variables
one
find
giving
multiple
names
follows
find
int
1..10
matrices
decision
variables
declared
using
matrix
domain
following
example
find
matrix
indexed
int
1..10
bool
declares
1-dimensional
matrix
boolean
variables
simple
matrix
domains
described
section
2.1.
sudoku
running
example
using
following
two-dimensional
matrix
domain
find
matrix
indexed
int
1..9
int
1..9
int
1..9
3.4
constraints
parameters
cases
useful
restrict
values
parameters
achieved
keyword
followed
boolean
expression
containing
decision
variables
following
example
require
ﬁrst
parameter
less
second
given
int
1..
given
int
1..
essence
cid:48
description
1.6.4
3.5
objective
objective
problem
either
maximising
minimising
integer
boolean
expression
instance
minimising
states
value
assigned
variable
minimised
one
objective
allowed
placed
given
find
letting
statements
3.6
solver
control
addition
instructing
solver
minimise
maximise
expression
essence
cid:48
also
supports
rudimentary
options
controlling
variables
solver
branch
variable
ordering
heuristic
use
information
passed
minion
used
solver
statements
experimental
may
removed
language
future
versions
branching
statement
speciﬁes
sequence
variables
solver
branch
heuristic
statement
speciﬁes
heuristic
used
variables
branching
list
heuristic
followed
static
sdf
conflict
srf
options
passed
minion
example
tells
solver
branch
using
smallest
domain
ﬁrst
heuristic
subsequently
branch
decision
variables
using
default
static
ordering
find
int
1..10
branching
heuristic
sdf
branching
statement
followed
comma-separated
list
individual
decision
variables
matrices
list
may
contain
matrices
different
dimensions
sizes
decision
variables
matrices
enumerated
order
produced
flatten
function
branching
list
may
contain
decision
variable
useful
pick
variables
matrix
branch
ﬁrst
include
rest
matrix
simply
including
entire
matrix
following
example
diagonal
branched
ﬁrst
rest
included
find
matrix
indexed
int
1..9
int
1..9
int
1..9
branching
int
1..9
matrix
included
branching
list
converted
one-dimensional
matrix
using
flatten
optimisation
performed
variables
branching
list
using
branching
cause
maximising
minimising
function
unusual
way
maximise
minimise
variables
branching
list
therefore
may
return
overall
maximal/minimal
solution
3.7
constraints
deﬁning
constants
declaring
decision
variables
parameters
constraints
speciﬁed
keywords
constraints
essence
cid:48
boolean
expressions
described
section
2.8.
typically
constraints
written
list
boolean
expressions
separated
operator
undeﬁnedness
essence
cid:48
since
current
version
essence
cid:48
closed
language
ﬁnite
set
partial
functions
language
example
x/y
partial
function
deﬁned
y=0
current
version
essence
cid:48
implements
relational
semantics
deﬁned
frisch
stuckey
proper
treatment
undeﬁnedness
constraint
languages
essence
cid:48
description
1.6.4
proc
principles
practice
constraint
programming
2009
pages
367-382
relational
semantics
advantage
implemented
efﬁciently
relational
semantics
may
summarised
follows
integer
matrix
expression
directly
containing
undeﬁned
expression
undeﬁned
domain
domain
expression
directly
containing
undeﬁned
expression
undeﬁned
statement
preamble
find
letting
etc
directly
containing
undeﬁned
expression
undeﬁned
boolean
expression
directly
contains
undeﬁned
expression
false
informally
relational
semantics
conﬁnes
effect
undeﬁned
expression
small
part
problem
instance
becomes
false
many
cases
avoiding
making
entire
problem
instance
false
consider
four
examples
contains
division
zero
undeﬁned
integer
expression
case
division
contained
comparison
integer
comparisons
boolean
expressions
x/0
false
x/0
false
x/0
true
x/0
true
applying
rules
relational
semantics
results
comparisons
inside
brackets
becoming
false
false
false
false
false
false
true
false
true
relational
semantics
x/0
semantically
equivalent
x/0
somewhat
counter-intuitive
another
counter-intuitive
case
arises
matrix
indexing
following
example
expression
unde-
ﬁned
index
domain
matrix
boolean
i.e
dom
bool
becomes
false
model
solution
=false
however
matrix
contains
integer
variables
i.e
dom
int
0..1
constraint
becomes
false
model
solutions
find
matrix
indexed
int
dom
savile
row
implementation
essence
cid:48
partial
functions
removed
two-step
process
transformations
applied
ﬁrst
step
follows
partial
function
boolean
expression
created
true
partial
function
deﬁned
false
undeﬁned
six
operators
may
partial
division
modulo
power
factorial
matrix
indexing
matrix
slicing
table
shows
generated
boolean
expression
operator
boolean
expression
added
model
connecting
onto
closest
boolean
expression
partial
function
abstract
syntax
tree
second
step
replace
partial
function
total
function
input
deﬁned
deﬁned
value
inputs
undeﬁned
takes
default
value
typically
integer
expressions
steps
applied
partial
function
model
well
deﬁned
everywhere
done
ﬁrst
model
transformations
thus
allows
subsequent
transformations
simpler
need
allow
undeﬁnedness
example
expression
x/y=x/y
may
simpliﬁed
true
false
y=0
however
replacing
partial
division
function
resulting
equality
simpliﬁed
true
general
equality
two
syntactically
identical
expressions
simpliﬁed
true
partial
functions
essence
cid:48
description
1.6.4
partial
function
x/y
x**y
factorial
matrix
indexing
domain
matrix
indexed
dbase
matrix
slicing
domain
matrix
indexed
dbase
deﬁned
table
partial
functions
essence
cid:48
arbitrary
expressions
correct
type
operator
precedence
essence
cid:48
table
shows
precedence
associativity
operators
essence
cid:48
would
expect
operators
higher
precedence
applied
ﬁrst
left-associative
operators
evaluated
left-ﬁrst
example
2/3/4
2/3
operator
right
associativity
allows
double
exponentiation
conventional
meaning
2**3**4
2**
3**4
unary
operators
usually
higher
precedence
binary
ones
one
exception
rule
higher
precedence
unary
minus
allows
-2**2**3
conventional
meaning
2**
2**3
=-256
opposed
2**3
=256
reserved
words
following
words
keywords
therefore
allowed
used
identiﬁers
forall
forall
exists
sum
letting
given
find
language
int
bool
union
intersect
false
true
references
alan
frisch
warwick
harvey
chris
jefferson
bernadette
mart
inez
hern´andez
ian
miguel
essence
constraint
language
specifying
combinatorial
problems
constraints
:268–306
2008
peter
nightingale
¨ozg¨ur
akg¨un
ian
gent
christopher
jefferson
ian
miguel
automatically
improving
con-
straint
models
savile
row
associative-commutative
common
subexpression
elimination
20th
inter-
national
conference
principles
practice
constraint
programming
2014
pages
590–605
springer
2014
peter
nightingale
patrick
spracklen
ian
miguel
automatically
improving
sat
encoding
constraint
problems
common
subexpression
elimination
savile
row
proceedings
21st
international
conference
principles
practice
constraint
programming
2015
pages
330–340
2015
pascal
van
hentenryck
opl
optimization
programming
language
mit
press
cambridge
usa
1999.
essence
cid:48
description
1.6.4
associativity
precedence
-10
-20
right
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
left
operator
intersect
union
=lex
lex
=lex
lex
forall
exists
sum
quantiﬁers
functionality
boolean
negation
absolute
value
power
unary
negation
multiplication
division
modulo
domain
intersection
domain
union
addition
subtraction
domain
subtraction
equality
disequality
less-equal
less
greater-equal
greater
lex
less-equal
lex
less
lex
greater-equal
lex
greater
value
set
implication
table
operator
precedence
essence
cid:48
essence
cid:48
description
1.6.4
