programming
logic
without
logic
programming
robert
kowalski
fariba
sadri
department
computing
imperial
college
london
rak
doc.ic.ac.uk
_____________________________________________________________________
abstract
previous
work
proposed
logic-based
framework
computation
execu-
tion
actions
attempt
make
reactive
rules
form
antecedent
consequent
true
canonical
model
logic
program
determined
initial
state
sequence
events
resulting
sequence
subsequent
states
model-theoretic
semantics
reactive
rules
driving
force
logic
programs
play
supporting
role
canonical
model
states
actions
events
represented
timestamps
operational
semantics
sake
efficiency
timestamps
omitted
current
state
maintained
state
transitions
performed
reactively
executing
actions
make
consequents
rules
true
whenever
antecedents
become
true
operational
semantics
sound
incomplete
make
reactive
rules
true
preventing
antecedents
becoming
true
proactively
making
consequents
true
antecedents
become
true
paper
characterize
notion
reactive
model
prove
operational
semantics
generate
models
order
focus
main
issues
omit
logic
programming
component
framework
consideration
theory
practice
logic
programming
tplp
keywords
kelps
lps
model
generation
reactive
models
state
transition
systems
__________________________________________________________________________
introduction
state
transition
systems
play
important
role
many
areas
computing
underpin
operational
semantics
imperative
programming
languages
dy-
namic
behavior
database
management
systems
many
aspects
knowledge
representation
artificial
intelligence
many
systems
state
transitions
performed
executing
reactive
rules
form
antecedent
consequent
describe
relationships
earlier
later
states
events
reac-
tive
rules
occur
explicitly
condition-action
rules
production
systems
event-
condition-action
rules
active
databases
transition
rules
abstract
state
ma-
chines
gurevich
2000
implicit
statecharts
harel
1987
bdi
agents
plans
rao
georgeff
1995
core
reaction
ruleml
paschke
2012
despite
apparently
logical
syntax
reactive
rules
systems
hardly
systems
give
if-then
rules
logical
interpretation
paper
investigate
semantics
logical
language
kelps
programs
sets
reactive
rules
form
antecedent
consequent
classical
first-
order
logic
fol
computation
understood
generating
sequence
state
transitions
purpose
making
reactive
rules
true
kelps
kowalski
sadri
2012
reactive
kernel
lps
kowalski
sadri
2009
2010
2011
2012
2014
2015
logic-based
agent
production
system
language
combines
reactive
rules
logic
programs
kelps
obtained
lps
dropping
logic
programming
component
lps
sense
kelps
language
programming
logic
without
logic
pro-
gramming
operational
semantics
kelps
similar
imperative
reac-
tive
rule
languages
maintain
single
current
state
using
destructive
state
transitions
however
model-theoretic
semantics
kelps
combines
states
single
model
associating
time
stamps
facts
actions
exter-
nal
events
kowalski
sadri
2010
2011
2014
2015
showed
lps
therefore
kelps
sound
sequence
states
events
recognizes
solving
computational
task
generates
model
makes
reac-
tive
rules
true
paper
investigate
completeness
kelps
show
generate
reactive
models
consequents
reactive
rules
made
true
antecedents
become
true
however
kelps
therefore
lps
incomplete
generate
reactive
models
kelps
generate
models
proactively
make
consequents
true
whether
antecedents
become
true
preventively
make
anteced-
ents
false
avoid
making
consequents
true
make
antecedents
true
forced
make
consequents
true
moreover
gen-
erate
models
contain
actions
irrelevant
computational
task
kelps
similar
imperative
reactive
rule
languages
incompleteness
kelps
shows
operational
semantics
con-
ventional
reactive
system
languages
also
incomplete
reactive
rules
read
logical
implications
lps
therefore
kelps
scaled-down
optimised
version
abductive
logic
programming
alp
kakas
1998
exist
proof
procedures
alp
generate
proactive
preventative
models
avoid
generating
ob-
viously
irrelevant
actions
section
6.2
discuss
relationship
kelps/lps
alp
figure
illustrates
kelps
different
kinds
models
allowed
model-theoretic
semantics
kelps
single
reactive
rule
stating
see
wolf
time
cry
wolf
time
t+1
external
event
see-wolf
occurs
time
reactive
model
includes
exter-
nal
events
actions
single
action
cry-wolf
time
moti-
vated
reactive
rule
triggered
external
events
reactive
rule
external
event
reactive
model
proactive
model
model
irrelevant
action
see-wolf
cry-wolf
drink
see-wolf
cry-wolf
t+1
cry-wolf
cry-wolf
see-wolf
cry-wolf
see-wolf
see-wolf
cry-wolf
fig
example
models
reactive
rules
kelps
example
figure
variant
figure
reactive
rule
figure
states
cry
wolf
see
wolf
outside
state
records
whether
agent
outside
causal
theory
updates
state
result
external
events
actions
agent
initially
outdoors
models
figure
include
timestamped
facts
belonging
state
timestamped
external
events
timestamped
actions
motivated
reac-
tive
rule
non-reactive
preventative
model
includes
action
going
inside
prevents
need
crying
wolf
course
another
non-reactive
model
include
actions
reactive
rule
causal
theory
initial
state
time
outdoors
external
event
reactive
model
preventative
model
see-wolf
outdoors
cry-wolf
t+1
terminates
go-inside
outdoors
initiates
go-outside
outdoors
see-wolf
outdoors
outdoors
outdoors
outdoors
outdoors
outdoors
go-inside
see-wolf
see-wolf
cry-wolf
fig
example
models
reactive
rules
kelps
paper
characterize
reactive
models
generated
kelps
models
property
every
action
motivated
instance
action
occurs
explicitly
consequent
rule
whose
earlier
conditions
antecedent
consequent
rule
already
true
remainder
paper
present
kelps
model-theoretic
opera-
tional
semantics
relationship
two
semantics
relationship
related
work
future
work
paper
extends
earlier
paper
kowalski
sadri
2014
including
proofs
theorems
appendix
extending
kelps
allow
gen-
eral
fol
conditions
simplifying
many
definitions
including
extensive
comparison
related
approaches
kelps
example
figure
illustrates
additional
features
language
exam-
ple
consequent
rule
consists
two
alternative
plans
deadlines
order
received
reliable
customer
item
needs
dis-
patched
invoice
needs
sent
within
time
units
receiving
order
alternatively
apology
needs
sent
within
time
units
temporal
constraints
defined
auxiliary
theory
presented
solved
means
constraint
solver
constraint
logic
programming
jaffar
lassez
1987
actions
kelps
executed
concurrently
consistency
maintained
monitoring
preconditions
sets
events
example
precondition
en-
sures
item
dispatched
two
different
customers
time
see
later
preconditions
also
used
prevent
sending
apology
item
already
dispatched
semantics
kelps
non-deterministic
matter
alterna-
tive
plan
chosen
however
practice
alternatives
better
others
example
may
good
strategy
try
first
plan
earliest
deadline
try
later
alternative
plan
later
deadline
earlier
plan
failed
actions
performed
earlier
partially
executed
plan
committed
choices
undone
rolling
back
time
best
effects
undone
performing
compensating
actions
later
time
practical
implementation
applications
would
desirable
pro-
vide
method
control
choice
alternatives
however
lack
space
address
control
issues
paper
dispatch
item
send-invoice
item
reactive
rule
item
orders
item
reliable
causal
theory
initiates
send-invoice
item
payment-due
item
initial
state
dispatch
item
dispatch
item
c2
false
send-apology
item
terminates
pays-invoice
item
payment-due
item
reliable
bob
fig
example
complex
consequent
operational
semantics
kelps
maintains
single
current
state
time
reasons
reactive
rules
generate
set
actions
actsi+1
combines
set
external
events
exti+1
produce
consistent
set
concurrent
events
evi+1
exti+1
actsi+1
events
evi+1
used
update
current
state
gen-
erating
successor
state
si+1
succ
evi+1
deleting
facts
terminated
events
evi+1
adding
facts
initiated
evi+1
kelps
states
represented
sets
atomic
sentences
also
called
ground
atoms
facts
fluents
events
also
represented
atomic
sentences
sets
atomic
sentences
understood
either
syntactically
theories
sematically
model-theoretic
structures
second
model-theoretic
interpretation
underpins
logical
semantics
kelps
states
events
represented
without
timestamps
representa-
tion
without
timestamps
e.g
outdoors
reliable
bob
facilitates
destructive
updates
fact
terminated
set
events
fact
without
timestamps
simply
persists
one
state
next
however
representation
timestamps
e.g
outdoors
reliable
bob
makes
possible
combine
states
events
single
model-theoretic
structure
2.1
vocabulary
kelps
first-order
sorted
language
including
sort
time
version
kelps
presented
paper
assume
time
linear
discrete
succession
timepoints
represented
ticks
logical
clock
...
stand
t+1
stands
t+n
stands
thus
represents
state
time
evi+1
represents
set
events
taking
place
transition
state
si+1
representations
time
also
possible
predicates
predicate
symbols
language
partitioned
sets
repre-
senting
fluents
events
auxiliary
predicates
meta-predicates
fluent
predicates
represent
facts
states
last
argument
timestamped
fluent
atom
time
parameter
representing
time
state
fluent
belongs
unstamped
fluent
atom
atom
without
timestamp
event
predicates
represent
events
contributing
transition
one
state
next
last
argument
timestamped
event
atom
time
pa-
rameter
representing
time
successor
state
unstamped
event
atom
atom
without
time
parameter
event
predicates
partitioned
external
event
predicates
action
predicates
fluent
event
predicates
time
parameters
called
reference
times
timestamps
example
deadline
task
time
parameter
reference
time
expresses
time
deadline
task
auxiliary
predicates
two
kinds
time-independent
predicates
example
isa
book
item
include
time
parameters
temporal
constraint
predicates
including
inequalities
form
timepoints
functional
relationships
among
timepoints
max
min
time
parameters
kelps
temporal
constraints
constrain
timestamps
fluents
events
consequence
every
temporal
constraint
reactive
rule
contains
least
one
time
parameter
occurs
timestamp
fluent
event
atom
rule
lps
auxiliary
predicates
defined
logic
programs
kelps
defined
simply
possibly
infinite
set
aux
atomic
sentences
case
auxiliary
temporal
constraint
predicates
assumption
equivalent
as-
sumption
made
semantics
constraint
logic
programming
clp
kelps
exploits
relationship
clp
using
constraint
solver
sim-
plify
temporal
constraints
check
satisfiability
meta-predicates
consist
two
predicates
initiates
events
fluent
terminates
events
fluent
specify
post-conditions
events
perform
state
transitions
illustrated
figure
first
argument
set
events
cater
case
two
events
together
different
effects
individu-
events
buy
two
books
get
cheaper
one
half
price
two
people
push
heavy
object
moved
one
person
alone
second
argument
fluent
without
timestamps
lps
meta-
predicates
defined
logic
programs
kelps
defined
atomic
sentences1
causal
theory
also
contains
constraints
preconditions
co-occurrence
events.2
notation
set
fluents
without
timestamps
representing
single
state
si*
represents
set
fluents
timestamp
eventsi
set
events
without
timestamps
taking
place
transition
state
si-1
state
eventsi*
represents
set
events
timestamp
examples
figure
elsewhere
paper
use
variables
definitions
auxiliary
predicates
shorthand
set
well-sorted
ground
instances
definitions
earlier
papers
causal
theory
called
domain
theory
2.2
kelps
framework
definition
kelps
framework
program
triple
aux
set
reactive
rules
aux
set
ground
atoms
defining
auxiliary
predicates
causal
theory
item
manages
item
item
instock
item
rules
constructed
formulas
represent
complex
patterns
states
events
expressed
conjunctions
fol
conditions
temporal
constraints
operationally
fol
condition
query
aux
si*
evi*
timestamped
state
time
augmented
recent
set
events
definition
time-independent
auxiliary
predicates
example
fol
condi-
tion
behaves
query
returns
managers
whose
departments
items
item
stock
time
variables
item
said
bound
condition
variables
unbound
condition
see
later
depending
condition
occurs
reactive
rule
variables
either
universally
existential
quantified
rule
definition
fol
condition
fol
formula
containing
exactly
one
timestamp
either
constant
variable
whose
atoms
either
fluent
atoms
event
atoms
time-independent
auxiliary
predicates
timestamp
variable
bound
quantifier
fol
condition
definition
complex
pattern
states
events
complex
short
possibly
empty
conjunction
fol
conditions
temporal
constraints
time
variables
temporal
constraints
complex
occur
time
parameters
fol
conditions
complex
functionally
dependent
time
parameters
example
functionally
dependent
max
functionally
dependent
plus
definition
reactive
rule
simply
rule
sentence
form
antecedent
consequent
set
variables
including
time
variables
occurring
antecedent
bound
fol
conditions
set
variables
including
time
variables
occurring
consequent
bound
fol
conditions
consequent
disjunction
consequent1
...
consequentn
antecedent
antecedent
consequenti
complex
every
substitution
replaces
time
variables
ground
times
temporal
constraints
antecedent
consequent
true
aux
timestamps
fol
conditions
consequent
later
equal
timestamps
fol
conditions
antecedent
every
temporal
constraint
consequenti
contains
least
one
timestamp
varia-
ble
occurs
fol
condition
consequenti
functionally
dependent
timestamp
variables
intuitively
next-to-last
bullet
restricts
reactive
rules
ones
whose
antecedent
conjunction
fol
conditions
past
present
whose
consequent
disjunction
conjunctions
fol
conditions
present
future
last
bullet
prevents
rules
constraint
consequent
constrains
timestamp
antecedent
restrictions
quantifiers
logical
equivalence
omit
quantifiers
simply
write
antecedent
consequent
antecedent
consequent1
...
consequentn
variables
unbound
fol
condition
become
bound
either
universally
existentially
depending
condition
occurs
rule
example
condition
item
manages
item
item
instock
item
occurs
antecedent
rule
bound
universal
quantifi-
ers
rule
condition
occurs
consequent
rule
occur
antecedent
rule
bound
existential
quantifiers
consequent
rule
avoid
ambiguity
fol
condition
consequent
rule
empty
antecedent
write
rule
form
true
consequent
note
operational
semantics
components
fol
condition
evaluated
together
aux
si*
evi*
several
fol
conditions
evaluated
time
timestamps
unified
time
note
also
antecedent
empty
antecedent
equivalent
true
consequent
empty
consequent
equivalent
false
fol
condition
contains
action
atom
evaluated
aux
si*
evi*
like
fol
condition
however
action
atom
act
conjunct
fol
condition
form3
conjunct1
act
conjunct2
consequent
rule
also
selected
candidate
execution
transition
next
state
si+1
action
atoms
called
bare
action
atoms
definition
let
consequenti
rule
form
conjunct1
act
conjunct2
act
action
atom
act
bare
action
atom
consequenti
state
transitions
performed
means
causal
theory
imposes
precon-
ditions
sets
events
defines
postconditions
sets
events
definition
causal
theory
cpost
cpre
consists
two
parts
cpost
set
atomic
sentences
defining
predicates
initiates
terminates
cpre
set
sentences
form
current
t-1
events
false
current
t-1
possibly
empty
fol
condition
timestamp
t-1
events
non-empty
fol
simplicity
say
formula
particular
form
mean
formula
rewritten
form
simply
reordering
conjunctions
disjunctions
taking
commutativity
associativity
account
in-stock
item
t-1
dispatch
item
false
condition
timestamp
containing
fluents
variables
explicitly
bound
fol
conditions
implicitly
universally
quantified
syntax
cpre
allows
specification
typical
preconditions
exe-
cution
single
action
in-stock
item
fluent
initiated
terminated
actions
stock
item
dispatch
item
respectively
syntax
cpre
also
allows
prohibition
concurrent
sets
events
also
possible
specify
certain
actions
must
co-occur
example
figure
sending
apology
item
already
dis-
patched
dispatched
prevented
means
preconditions
dispatched
item
send-apology
item
false
dispatch
item
send-apology
item
false
dispatch
item
dispatch
item
false
leave-house
take-keys
false
dispatched
item
fluent
initiated
action
dispatch
item
use
atomic
sentences
define
predicates
initiates
terminates
similar
use
add-lists
delete-lists
strips
fikes
nilsson
1972
however
general
first
argument
predicates
set
events
defining
fluents
initiated
terminated
sets
concurrent
events
explicitly
means
atomic
sentences
practical
clarifies
model-theoretic
semantics
simplifies
operational
semantics
moreover
paves
way
practical
representation
initiates
terminates
defined
logic
programs
lps
kelps
model-theoretic
semantics
operational
semantics
kelps
states
updated
adding
deleting
model-theoretic
semantics
kelps
truth
values
rules
preconditions
cpre
defined
according
standard
non-modal
semantics
classical
first-order
logic
contrasts
semantics
modal
logics
states
represented
possible
worlds
linked
accessibility
relations
fluents
fluents
affected
update
left
untouched
definition
aux
kelps
framework
set
unstamped
fluents
representing
single
state
set
unstamped
events
representing
concur-
rent
events
associated
successor
state
succ
terminates
cpost
initiates
cpost
model-theoretic
semantics
fluents
events
timestamped
included
single
model-theoretic
structure
aux
ev*
notation
initial
state
ext1
exti
sequence
sets
external
events
acts1
actsi
sequence
sets
actions
s0*
si*
si+1
succ
evi+1
ev*
ev0*
evi*
ev0
evi
exti
actsi
computation
conventional
reactive
system
consists
generating
stream
act1
acti
actions
response
stream
ev1
evi
external
events
previously
generated
actions
computation
kelps
similar
purpose
namely
make
reactive
rules
preconditions
actions
true
definition
given
kelps
framework
aux
initial
state
compu-
tational
task
every
every
sequence
ev0
evi
sets
external
events
previously
generated
actions
generate
set
actsi+1
actions
cpre
true
herbrand
interpretation
aux
ev*
definition
truth
reactive
rules
classic
definition
sentences
fol
consequence
computational
task
allows
generation
actions
make
rules
true
making
antecedents
false
making
conse-
quents
true
whether
antecedents
true
false
also
allows
perfor-
mance
actions
irrelevant
task
kinds
preventative
pro-
active
irrelevant
actions
generated
conventional
reactive
systems
generated
kelps
paper
identify
kind
reactive
models
generated
kelps
operational
semantics
note
kelps
generated
actions
actsi+1
need
direct
reaction
current
situation
si*
evi*
partial
response
earlier
situations
3.1
herbrand
interpretations
semantics
herbrand
interpretations
simplified
version
standard
semantics
first-order
logic
definition
given
sorted
first-order
language
herbrand
universe
set
well-sorted
ground
i.e
variable-free
terms
constructed
non-empty
set
constants
function
symbols
vocabulary
herbrand
base
set
well-sorted
ground
atoms
constructed
pred-
icate
symbols
ground
terms
vocabulary
herbrand
interpretation
subset
herbrand
base
herbrand
model
set
sentences
her-
brand
interpretation
every
sentence
true
one
difference
standard
definition
truth
base
case
her-
brand
interpretation
ground
atom
true
difference
definition
truth
universally
existentially
quantified
sen-
tences
sentence
form
true
sort
sentence
true
similarly
true
sort
sentence
true
sensible
herbrand
universe
needs
non-empty
standard
defi-
nition
truth
thus
rulex
antecedent
consequent1
...
consequentn
true
every
ground
instance
antecedent
true
exists
ground
instance
consequenti
also
true
substitutions
replace
variables
respectively
terms
appropriate
sort
herbrand
universe
simplicity
assume
except
time
parameters
fluents
ground
instances
states
3.2
temporal
structure
kelps
interpretations
timestamping
fluents
events
restrictions
syntax
kelps
provide
herbrand
interpretations
kelps
programs
rich
structure
sub-
interpretations
structure
captured
following
theorem
immediate
consequence
definition
truth
true
aux
ev*
true
aux
si*
evi*
theorem
given
kelps
framework
aux
initial
state
sequence
sets
events
ev0
evi
conjunction
temporal
constraints
whose
time
parameters
ground
true
aux
ev*
true
aux
conjunction
fol
conditions
temporal
constraints
whose
time
parameters
ground
timestamps
time
latest
timestamp
true
aux
ev*
true
aux
s0*
...
si*
ev0*
...
evi*
obvious
similarity
possible
world
semantics
modal
logic
aux
si*
evi*
similar
possible
world
single
interpretation
aux
ev*
similar
complete
frame
possible
worlds
accessibility
relations
possible
world
semantics
fluents
belong
possible
worlds
events
belong
accessibility
relations
kelps
fluents
events
timestamped
contained
single
interpretation
aux
ev*
3.3
sequencing
temporal
constraints
complex
impose
partial
order
timestamps
fol
conditions
complex
although
timestamps
partially
ordered
complex
used
recognize
generate
linearly
ordered
sequences
states
satisfying
fol
conditions
complex
useful
notation
meta-language
distinguishes
different
sequences
represented
complex
notation
part
kelps
object
language
useful
defining
reactive
interpretations
operational
semantics
kelps
intuitively
sequencing
form
earlier
later
means
fol
conditions
earlier
evaluated
recognised
gen-
erated
fol
conditions
later
definition
let
earlier
earlier
later
complexes.4
earlier
later
sequencing
form
earlier
later
form
earlier
later
exists
substitution
time
variables
earlier
later
temporal
constraints
earlier
later
true
aux
timestamps
fol
conditions
earlier
earlier
earlier
equal
timestamps
fol
conditions
later
notice
true
true
allowed
sequencings
example
complex
strict
sequencings
true
true
earlier
papers
allowed
actions
selected
execution
con-
tain
non-timestamp
variables
variables
instantiated
suc-
cessfully
executed
feedback
environment
paper
restrict
selection
actions
ones
variables
purpose
require
kelps
frameworks
range-restricted
definition
kelps
framework
aux
range
restricted
every
bare
action
atom
act
containing
non-timestamp
variables
rule
form
antecedent
earlier
act
rest
sequencing
anteced-
ent
earlier
act
rest
non-timestamp
variables
act
occur
antecedent
earlier
3.4
reactive
interpretations
figure
figure
exemplify
different
kinds
models
kelps
program
following
definition
characterizes
reactive
interpretations
models
loosely
speaking
action
occurs
reactive
interpretation
occurs
bare
action
atom
one
alternative
consequents
instance
reactive
rule
earlier
fol
conditions
antecedent
alternative
consequent
instance
rule
already
true
interpretation
time
action
definition
given
range
restricted
kelps
framework
aux
initial
state
set
ev*
timestamped
events
let
cpre
true
aux
ev*
let
ev*
ext*
acts*
partitioning
ev*
external
events
ext*
actions
acts*
reactive
every
action
action
exists
rule
form
antecedent
earlier
act
rest
exists
substitution
supports
action
sense
action
act
antecedent
earlier
act
rest
antecedent
earlier
act
true
reactive
model
aux
reactive
interpretation
true
sufficient
require
later
complex
want
allow
later
temporal
constraints
time
variables
occurring
earlier
note
condition
allows
rest
false
kelps
operational
semantics
cry-wolf
¬help-arrives
t+1
cry-wolf
t+2
operational
semantics
exploits
internal
structure
kelps
interpretations
aux
ev*
generate
progressively
extending
partial
interpretation
aux
s0*
...
si*
ev0*
...
evi*
one
step
time
moreover
maintaining
unstamped
current
state
events
evi
gave
rise
without
remembering
earlier
states
events
recognise
complex
sequences
states
events
antecedents
rules
without
remembering
past
states
events
maintains
current
set
par-
tially
evaluated
rules
need
monitored
future
example
suppose
contains
rule
evi*
contains
event
occurrence
cry-wolf
evaluates
condition
cry-wolf
augmented
current
state
adds
new
rule
also
maintains
goal
state
containing
partially
evaluated
alternative
plans
made
true
future
example
evi+1*
contain
event
oc-
currence
help-arrives
i+1
evaluates
¬help-arrives
i+1
aug-
mented
current
state
true
adds
gi+1
new
top-level
goal
cry-wolf
i+2
logically
goal
state
conjunction
gi1
...
gin
gij
dis-
junction
partially
evaluated
alternative
plans
making
true
consequent
instance
rule
whose
antecedent
already
become
true
precise
disjunct
gij
instantiated
remainder
later
rule
antecedent
earlier
later
whose
earlier
part
antecedent
earlier
al-
ready
true
partial
interpretation
aux
s0*
...
si*
ev0*
...
evi*
gener-
ated
far
similarity
goal
clauses
logic
programming
disjuncts
later
also
called
goal
clauses
kelps
¬help-arrives
i+1
cry-wolf
i+2
operationally
goal
state
set
conjunction
independent
threads
gij
thread
goal
tree
root
node
instantiated
consequent
rule
whose
antecedent
already
become
true
non-root
nodes
goal
clauses
goal
tree
representation
helps
structure
search
space
alternative
plans
guide
search
alternatives
goal
trees
searched
depth-first
fashion
implemented
stacks
prolog
backtracking
pos-
sible
previously
generated
actions
states
undone
following
abstract
specification
ignores
many
optimizations
improve
efficiency
described
kowalski
sadri
2010
2011
2012
2014
optimizations
restrict
models
generated
hence
affect
relationship
interpretations
generated
interpretations
sanctioned
definition
reactive
interpretation
following
definition
presented
agent
cycle
end
cycle
external
events
input
combined
selected
actions
result-
ing
combined
set
events
used
update
current
state
versions
updates
performed
beginning
cycle
definition
cycle
given
range
restricted
kelps
framework
aux
initial
state
let
ev0
let
goal
state
obtained
creating
every
rule
form
true
consequent
goal
tree
consequent
root
adding
disjunct
consequent
whose
constraints
satisfiable
aux
child
root
let
without
rules
given
evi
i-th
cycle
consists
following
steps
step
evaluate
antecedents
every
sequencing
current
later
antecedent
instance
rule
form
current
later
consequent
current
non-empty
complex
add
later
consequent
new
reactive
rule
current
true
aux
si*
evi*
instantiates
variables
current
instantiates
variable
timestamps
fol
conditions
current
current
contains
temporal
constraints
antecedent
become
true
aux
result
evaluating
fol
conditions
current
later
empty
equivalent
true
delete
later
consequent
start
new
thread
consequent
root
add
disjunct
consequent
whose
constraints
satisfiable
aux
child
root
step
evaluate
goal
clauses
choose
set
sequencings
current
later
instances
goal
clauses
current
non-empty
complex
one
threads
choice
add
later
child
current
true
aux
si*
evi*
instantiates
variables
current
instantiates
variable
timestamps
fol
conditions
current
current
contains
temporal
constraints
become
true
aux
step
choose
candidate
actions
choose
set
sequencings
actions
rest
instances
goal
clauses
one
threads
instanti-
ates
timestamp
variables
actions
i+1
actions
con-
junction
ground
bare
action
atoms
timestamp
i+1
let
candidate-actsi+1
set
action
atoms
actions
step
update
choose5
subset
actsi+1*
candidate-actsi+1
cpre
true
aux
si*
evi*
evi+1*
evi+1*
exti+1*
actsi+1*
external
events
exti+1*
given
let
si+1
succ
evi+1
gi+1
ri+1
note
action
act
goal
clause
selected
step
successfully
executed
step
candidate
selected
step
next
cycle
act
candi-
date
selected
evaluation
true
moreover
occurrences
act
goal
clauses
evaluated
true
cycle
even
selected
step
previous
cycle
result
evaluating
fol
conditions
current
note
attempt
make
instance
consequent
reactive
rule
true
even
though
instance
consequent
already
made
true
avoided
easily
adding
extra
case
step
analo-
gous
case
step
would
make
corresponding
definition
reactive
interpretations
complex
however
optimisations
made
without
affecting
definition
reactive
interpretation
optimisations
include
removing
rules
whose
antecedents
timed
removing
goal
clauses
containing
fluent
event
atom
timed
relationships
model-theoretic
operational
semantics
proof
soundness
lps
kowalski
sadri
2010
2011
2014
also
applies
kelps
details
proof
given
appendix
theorem
soundness
given
kelps
framework
aux
initial
state
sequence
ext1
exti
sets
external
events
suppose
gener-
ates
sequences
sets
acts1
actsi
actions
states
cpre
true
aux
ev*
every
goal
tree
added
goal
state
goal
clause
true
added
goal
tree
goal
state
following
theorem
characterises
interpretations
generated
correctness
result
reactive
interpretations
detailed
proof
appendix
theorem
every
interpretation
generated
reactive
given
range
restricted
kelps
framework
aux
initial
state
set
external
events
ext*
let
acts*
set
actions
generated
ev*
ext*
acts*
aux
ev*
reactive
interpretation
proof
sketch
sketch
proof
case
variables
rules
antecedent
consequent
replaced
ground
instances
resulting
ground
temporal
constraints
evaluated
resulting
rules
longer
contain
temporal
constraints
show
action
generated
supported
show
gener-
ally
goal
clause
goal
state
exists
rule
form
antecedent
earlier
earlier
antecedent
earlier
true
aux
s0*
...
si*
ev0*
evi*
action
act
generated
belongs
actsi+1
act
selected
candidate
step
time
goal
clause
sequencing
act
rest
follows
supports
act
supported
following
theorem
kind
completeness
result
reactive
interpretations
detailed
proof
appendix
theorem
every
reactive
interpretation
generated
given
range
restricted
kelps
framework
aux
initial
state
external
events
ext*
let
acts*
set
actions
aux
ev*
ev*
ext*
acts*
reactive
interpretation
exist
choices
steps
generates
acts*
therefore
generates
proof
sketch
sketch
case
variables
rules
antecedent
consequent
replaced
ground
instances
temporal
constraints
evaluated
let
acti
acts*
action
time
supported
rule
form
antecedent
early
acti
rest
antecedent
early
true
aux
s0*
...
si-1*
ev0*
evi-1*
suffices
show
contains
goal
clause
form
acti
rest
choose
candidate
actions
step
combination
evi*
exti*
actsi*
external
events
candidate
actions
step
actsi*
set
actions
acti
show
contains
goal
clause
form
acti
rest
show
generally
times
support
action
actsi*
exist
choices
steps
either
form
antecedent
early
late
late
antecedent
early
true
aux
s0*
...
sk-1*
ev0*
evk-1*
form
earlier
later
consequent
later
consequent
earlier
true
aux
s0*
...
sk-1*
ev0*
evk-1*
frame
axioms
logic-based
causal
theories
employ
frame
axioms
represent
reason
change
state
frame
axioms
represent
prop-
erty
fluent
persists
one
state
next
unless
terminated
events
give
rise
state
transition
used
either
reason
forwards
copy
fluents
unchanged
one
state
next
reason
backwards
deter-
mine
whether
fluent
holds
state
determining
whether
holds
previous
state
use
destructive
assignment
lps
kelps
avoids
computa-
tionally
expensive
forms
reasoning
kowalski
sadri
2015
show
frame
axioms
emergent
prop-
erty
lps
operational
semantics
analogous
showing
example
associativity
addition
emergent
property
program
computes
addition
proof
lps
also
applies
kelps
fact
proof
de-
pend
definition
succ
evi+1
theorem
frame
axioms
emergent
property
given
definitions
cpost
predicates
initiates
terminates
initial
state
sequence
sets
concur-
rent
events
ev1
evi
...
let
cpost
ev*
evi
fluents
following
sentence
true
s0*
si*
si+1
succ
evi+1
ev*
ev1*
evi*
initiates
evi+1
i+1
terminates
evi+1
i+1
related
work
development
kelps/lps
influenced
work
many
different
areas
computing
including
programming
databases
artificial
intelligence
make
task
comparison
related
work
manageable
focus
primari-
comparing
kelps/lps
approaches
attempt
give
logical
semantics
rule-based
systems
earlier
papers
kowalski
sadri
2009
2010
2011
2012
2014
2015
include
extensive
comparisons
lps
many
systems
paper
relate
earlier
comparisons
kelps
include
related
work
6.1
lps
sentence
agent
agent
agent
sentence
turing
sentence
robot
sec
adj
agent
t+1
say
agent
human
t+1
noun
agent
t+1
say
agent
human
t+1
first
need
clarify
relationship
kelps
lps
consider
example
reactive
rule
lps
expresses
robot
goal
replying
sentence
sentence
said
agent
called
turing
predicate
sentence
represents
composite
event
action
start
end
times
lps
predicate
defined
logic
program
used
recognize
generate
sentences
logic
program
could
include
among
clauses
defining
predicates
clauses
say
represents
primitive
event
start
end
times
kelps
primitive
event
represented
simply
end
time
infinitely
many
rules
including
example
rule
say
robot
say
robot
say
robot
intelligent
neither
practical
desirable
lps
reactive
rules
logic
programs
far
know
chr
section
6.4
language
derived
alp
combines
reactive
rules
logic
programs
retains
separate
character
languages
reactive
rules
simu-
late
logic
programs
treating
goals
facts
approaches
give
logical
semantics
reactive
rules
translate
logic
programs
simplifies
clarifies
investigation
completeness
paper
restricted
attention
reactive
rules
kelps
kelps
possible
get
similar
effect
lps
replacing
one
rule
say
turing
say
turing
say
turing
human
6.2
abductive
logic
programming
alp
event
calculus
lps
therefore
kelps
originated
earlier
work
alp
fung
kow-
alski
1997
kakas
1998
alp
agents
kowalski
sadri
1999
2009
kowalski
2011
alp
extends
logic
programming
allowing
certain
predicates
called
abducible
open
predicates
assumed
order
solve
problem
assumptions
restricted
means
integrity
constraints
alp
agents
abducible
predicates
represent
actions
integrity
constraints
include
reac-
tive
rules
main
difference
kelps/lps
uses
destructive
updates
state
transitions
whereas
alp
agents
use
event
calculus
kowalski
sergot
1986
although
event
calculus
viewed
solving
frame
problem
sha-
nahan
1997
believe
compete
practical
applications
de-
structive
change
state
however
destructive
change
state
obvious
logical
semantics
particular
states
axiomatic
theories
syntactic
objects
destructive
change
state
problematic
possible
change
axioms
course
trying
prove
theorem
kelps/lps
retains
ontology
event
calculus
replaces
explicit
rea-
soning
event
calculus
axioms
implicit
construction
timestamped
her-
brand
interpretations
consequence
kelps/lps
generate
reactive
models
contrast
use
event
calculus
alp
agents
also
generate
preventative
proactive
models
lps
inherits
alp
property
models
contain
irrelevant
actions
alp
irrelevant
actions
avoided
minimizing
set
actions
contained
model
lps
generation
irrelevant
actions
reduced
generating
reactive
interpretations
contain
actions
instances
action
atoms
occur
explicitly
consequents
reactive
rules
6.3
metatem
best
knowledge
metatem
barringer
1996
framework
based
alp
describes
state
transitions
reactive
rules
logical
form
treats
computation
model
generation
programs
metatem
consist
sentences
modal
temporal
logic
form
past
present
formula
implies
present
future
formula
computation
consists
generating
model
sentences
true
metatem
formally
distinguish
events
fluents
explicit
causal
theory
frame
axioms
logic
programs
writ-
ten
needed
form
reactive
rules
like
kelps
metatem
lacks
logic
programs
lps
main
differences
kelps
time
represented
explicitly
models
classical
rather
mod-
models
constructed
means
destructive
updates
lps
difference
logic
programs
separate
additional
reactive
rules
barringer
1996
presents
operational
semantics
propositional
me-
tatem
without
external
events
despite
claim
page
148
metatem
complete
examples
non-reactive
models
kelps
translated
metatem
show
metatem
generate
reactive
models
therefore
incomplete
6.4
constraint
handling
rules
chr
closer
lps
syntactic
structure
expressive
power
language
chr
constraint
handling
rules
frühwirth
1998
2009
lps
two
kinds
rules
equivalences
propagation
rules
equivalences
used
like
ordinary
logic
programs
also
used
simplification
propagation
rules
logical
implications
used
reason
forward
like
reactive
rules
kelps
chr
abdennadher
schütz
1998
extends
chr
include
disjunctions
conse-
quents
propagation
rules
like
reactive
rules
kelps
operational
semantics
propagation
rules
chr
similar
kelps
operational
semantics
propagation
rules
equivalences
similar
lps
chr
classical
logic
semantics
computation
interpreted
theorem-proving
similar
iff
proof-procedure
fung
kowalski
1997
semantics
justify
destructive
updates
chr
also
translation
linear
logic
betz
frühwirth
2005
justifies
de-
structive
updates
style
lps
without
use
timestamps
linear
logic
semantics
chr
different
model-theoretic
semantics
kelps/lps
time
represented
explicitly
state
transi-
tions
performed
means
causal
theory
although
propagation
rules
similar
reactive
rules
clear
completeness
incompleteness
kelps/lps
relate
completeness
results
chr/
chr
6.5
production
systems
production
systems
computer
languages
programs
sets
sentences
form
conditions
actions
state
transitions
performed
evaluating
conditions
current
state
executing
corresponding
actions
perform-
ing
conflict
resolution
choose
conflicting
actions
chosen
actions
destructively
update
current
state
attempt
understand
logic
production
systems
rela-
tionship
logic
programs
led
development
lps
explains
lps
several
authors
also
attempted
provide
production
rules
logical
semantics
mostly
mapping
logic
programs
raschid
1994
particular
transforms
production
rules
logic
programs
uses
fixed
point
semantics
logic
programming
perform
forward
chaining
baral
lobo
1995
hand
translate
production
rules
situation
calculus
represented
logic
program
stable
model
semantics
recently
damásio
2010
use
incremental
answer
set
programming
asp
realize
different
conflict
resolution
strategies
rif-prd
production
system
dialect
eiter
2012
simulate
production
systems
asp
inter-
face
external
environment
performing
state
changes
updating
accessing
environment
via
action
atoms
external
atoms
gebser
2011
use
dis-
junctive
logic
programs
without
existential
quantifiers
represent
reactive
rules
asp
reasoning
real-time
dynamic
systems
running
online
changing
environments
best
knowledge
none
mappings
logic
programs
per-
form
destructive
updates
manner
production
systems
kelps/lps
contrast
approaches
kelps/lps
reformulates
production
rules
reactive
rules
logic
programs
lps
logic
programs
like
deduc-
tive
databases
reactive
rules
like
database
integrity
constraints
6.6
integrity
constraints
model-theoretic
semantics
kelps
fundamental
investigation
completeness
paper
based
upon
model-theoretic
semantics
integ-
rity
constraints
deductive
databases
alp
however
historical
perspec-
tive
kowalski
2014
model-theoretic
semantics
one
two
main
alter-
natives
alternative
theorem-hood
view
integrity
con-
straints
queries
meant
theorems
logical
consequence
database
regarded
theory
parallel
world
logic
programming
shift
away
theorem-proving
view
computation
model-generation
view
work
semantics
kelps/lps
followed
shift
theorem-proving
model-generation
lps
semantics
logic
programs
kowalski
sadri
2015
spirit
well-founded
semantics
van
gelder
1991
case
kelps
role
logic
programs
played
simply
sets
ground
atoms
equivalent
relational
databases
reactive
rules
kleps/lps
similar
syntax
integrity
constraints
form
disjunctive
tuple-generating
dependencies
relational
databases
wang
2001
whereas
relational
databases
main
focus
prob-
lem
deciding
whether
given
set
tuple-generating
dependencies
logically
im-
plies
another
dependency
kelps/lps
focus
generating
model
makes
integrity
constraints
form
reactive
rules
preconditions
cpre
true
recent
years
activity
deductive
databases
become
associated
datalog
databases
logic
programs
without
function
symbols
dat-
alog±
calì
2009
extends
datalog
existential
rules
similar
syntax
reactive
rules
kelps/lps
without
disjunctive
consequents
similarly
viewed
integrity
constraints
however
whereas
reactive
rules
logic
programs
separate
components
lps
datalog±
logic
pro-
grams
special
case
existential
rules
effect
datalog±
distin-
guish
database
integrity
constraints
moreover
deals
one
database
state
time
deal
database
updates
datalog±
generates
answers
queries
using
bottom-up
procedure
called
chase
maier
1979
also
used
wang
2001
gavanelli
2015
map
datalog±
alp
show
sciff
proof
procedure
alberti
2008
extends
iff
proof
procedure
fung
kowalski
1997
generates
answers
chase
procedure
iff
proof
procedure
turn
one
progenitors
kelps/lps
iff
proof
procedure
turn
similar
satchmo
proof
procedure
manthey
bry
1988
full
clausal
form
first-order
logic
satchmo
bottom-up
procedure
viewed
resolution-based
theorem-
prover
model-generator
6.7
transaction
logic
transaction
logic
bonner
kifer
1993
logic-based
formalism
defining
transactions
similar
complex
plans
kelps/lps
similarly
update
states
logic
program
database
transactions
logical
model-theoretic
semantics
like
possible
world
semantics
modal
logic
based
sets
possible
worlds
states
unlike
modal
logic
truth
value
transaction
defined
along
path
states
starting
state
beginning
transaction
ending
state
end
transaction
kelps/lps
state
transitions
performed
means
destruc-
tive
updates
although
direct
analogue
reactive
rules
kelps/lps
simulated
transactions
rezk
kifer
2012
use
simulation
give
logic-based
semantics
production
system
language
kelps
shares
view
computation
making
goal
true
generat-
ing
sequence
destructively
updated
states
moreover
inclusion
fol
con-
ditions
kelps/lps
largely
inspired
similar
fol
conditions
trans-
actions
main
differences
kelps
transactions
consequents
reactive
rules
triggered
antecedents
become
true
time
repre-
sented
explicitly
states
actions
events
combined
single
model-
theoretic
structure
trev
gomes
alferes
2014
extends
combining
generation
com-
plex
transactions
recognition
complex
events
consequence
ex-
pressive
power
similar
kelps
represents
complex
events
complex
transactions
separately
without
combining
reactive
rules
logical
implications
6.8
active
databases
number
researchers
attempted
develop
logic-based
semantics
active
databases
majority
approaches
map
reactive
rules
form
event-
condition-action
eca
rules
logic
programs
example
zaniolo
1993
lausen
1998
use
frame
axioms
similar
theorem
reduce
eca
rules
logic
programs
action
t+1
condition
event
t+1
fernandes
1997
give
separate
logical
formalisations
events
conditions
actions
without
combining
reactive
rules
logical
implications
like
production
systems
unlike
kelps/lps
active
databases
restricted
rules
whose
antecedents
query
current
state
whose
consequents
update
current
state
6.9
agent
languages
bailey
1995
argue
although
differ
intended
applications
research
communities
many
agent
languages
developed
similar
active
database
systems
particular
agent
plans
bdi
agents
similar
eca
rules
active
databases
moreover
bdi
agents
active
databases
maintain
destructively
updated
database
state
lack
declarative
semantics
lps
direct
descendant
alp
agents
embed
alp
thinking
component
bdi-like
agent
cycle
alp
agents
logic
program
represents
agent
beliefs
initial
goals
integrity
constraints
represent
agent
goals
desires
database
updated
using
event
calculus
using
frame
axi-
oms
alp
agent
approach
developed
kgp
agent
model
mancarella
2009
contrast
operational
semantics
lps
employs
destructively
updated
database
represents
current
state
event
conditions
goals
actions
destructive
updates
lps
inspired
part
use
bdi-agent
languages
agentspeak
rao
1996
programs
agentspeak
collections
statements
form
event
addition
deletion
belief
literal
goal
atom
stored
database
conditions
query
database
goals
actions
update
database
adding
deleting
goals
beliefs
result
plans
com-
bine
functionality
reactive
rules
logic
programs
lps
however
allow
complex
events
event
conditions
part
plans
include
temporal
constraints
moreover
logical
semantics
fact
addition
belief
literal
arrow
opposite
arrow
logical
implication
kelps/lps
number
authors
also
developed
agent
languages
systems
logic
programming
context
example
dali
costantini
tocchio
2014
evolp
brogi
2002
events
transform
initial
agent
logic
program
se-
quence
logic
programs
era
alferes
2006
extends
evolp
complex
events
complex
actions
event-condition-action
rules
semantics
evolutionary
sequence
logic
programs
dali
evolp
era
given
associated
sequence
models
era
eca
rules
translated
logic
pro-
grams
form
action
condition
event
contrast
kelps/lps
distinguishes
semantics
logic
programs
reactive
rules
combines
se-
quence
states
events
single
model
using
timestamps
flux
thielscher
2005
constraint
logic
programming
language
imple-
menting
intelligent
agents
using
fluent
calculus
one
objectives
fluent
calculus
avoid
computational
inefficiency
reasoning
frame
axioms
reifying
states
lists
fluents
however
list
representation
re-
quires
explicit
use
recursion
query
whether
fluent
member
list
representing
state
delete
fluent
terminated
action
argua-
bly
nearly
inefficient
reasoning
explicit
frame
axioms
contrast
kelps/lps
states
represented
explicitly
language
repre-
sented
implicitly
sets
fluents
membership
deletion
performed
associative
look-up
flux
states
updated
sensing
actions
seems
analogue
reactive
rules
kelps/lps
governatori
rotolo
2013
authors
present
efficient
algorithm
computing
argumentation-style
extensions
temporal
defeasible
logic
tdl
pro-
grams
tdl
logical
implications
time
stamps
similar
reactive
rules
kelps
time
complexity
algorithm
proportional
size
rules
much
efficient
explicit
reasoning
event
calculus
style
frame
axioms
however
algorithm
described
terms
destructive
updates
difficult
compare
directly
kelps
approaches
focus
internal
reasoning
individual
agents
treating
agents
part
external
environment
contrast
sciff
alberti
2008
focuses
directly
specification
verification
multi-agent
sys-
tems
abstracting
away
internal
structure
individual
agents
uses
alp
represent
expected
behavior
agents
variant
iff
proof
procedure
fung
kowalski
1997
verify
actual
behaviour
conforms
expectations
integrity
constraints
sciff
resemble
eca
rules
used
specify
oc-
currence
events
generate
events
timestamped
related
fluents
causal
theory
6.10
reactive
systems
programming
languages
although
lps
origins
logic
programming
turing
complete
kernel
lps
reactive
rules
shift
logic
programs
reactive
rules
reflects
better
appreciation
fundamental
role
state
transition
systems
areas
computing
including
reactive
systems
programming
languages
david
harel
1987
puts
much
literature
also
seems
agree-
ment
states
events
piori
rather
natural
medium
describing
dynamic
behaviour
complex
system
...
basic
fragment
description
state
transition
takes
general
form
event
occurs
state
condition
true
time
system
transfers
state
harel
contrasts
reactive
systems
transformational
systems
transform
inputs
out-
puts
purely
declarative
manner
arguably
lps
reconciles
harel
two
kinds
computational
systems
reactive
rules
providing
reactive
part
logic
programs
providing
structure
transformational
part
contrast
shapiro
1989
argues
concurrent
logic
programming
languages
well
suited
specifying
reactive
systems
languages
state
computation
consists
goal
sequence
atoms
assignment
values
variables
goals
programs
guarded
horn
clauses
form
head
guard
body
goal
atoms
match
head
satisfy
guard
reduced
goal
atoms
body
goal
atom
viewed
process
goal
whole
viewed
network
concurrent
processes
processes
communicate
instantiating
shared
logical
variables
external
environment
represented
process
whose
be-
haviour
specified
another
concurrent
logic
program
approach
reactive
systems
different
kelps/lps
states
sets
time-stamped
atoms
operationally
kelps/lps
closer
coordination
languages
linda
carriero
gelernter
1989
pro-
cesses
interact
medium
shared
state
whereas
harel
sees
need
transformational
reactive
systems
shapiro
reduces
kinds
systems
logic
programs
gurevich
2000
models
varieties
computation
abstract
state
machines
asm
programmed
rules
form
guard
assignments
states
abstract
model-theoretic
structures
consisting
objects
functions
state
transitions
performed
evaluating
guards
rules
guard
assignments
true
current
state
executing
corresponding
assignments
destructively
parallel
rules
asm
similar
condition-action
rules
production
systems
reactive
rules
kelps
however
asm
rules
restricted
kelp/lps
rules
whose
antecedents
consequents
involve
entire
complex
tempo-
rally
constrained
fol
conditions
compared
lps
states
com-
bined
single
model
individual
states
asm
model-theoretic
character
moreover
if-then
syntax
guarded
assignments
asm
mean
logical
implication
conclusions
future
work
paper
makes
contribution
analyzing
relationship
opera-
tional
model-theoretic
semantics
kelps
future
would
useful
extend
results
lps
would
also
interesting
extend
capture
non-reactive
interpretations
satisfy
model-theoretic
semantics
practical
side
would
useful
extend
reactive
rules
allow
complex
event
conditions
extension
would
affect
model-theoretic
se-
mantics
implemented
example
storing
window
past
events
also
important
explore
treatment
concurrency
greater
depth
espe-
cially
context
multi-agent
systems
external
events
single
agent
include
actions
generated
agents
number
implementations
lps
making
available
wider
use
major
priority
future
work
acknowledgements
grateful
anonymous
referees
careful
reading
earlier
submission
many
helpful
comments
references
abdennadher
schütz
1998.
chrv
flexible
query
language
fqas
1-14.
alberti
chesani
gavanelli
lamma
mello
torroni
2008.
verifiable
agent
interaction
abductive
logic
programming
sciff
framework
acm
transac-
tions
computational
logic
tocl
alferes
j.j.
banti
brogi
2006.
event-condition-action
logic
programming
language
10th
european
conference
logics
artificial
intelligence
jelia
lecture
notes
artificial
intelligence
4160
springer-verlag
29-
42.
bailey
georgeff
kemp
kinny
ramamohanarao
1995.
active
data-
bases
agent
systems—a
comparison
rules
database
systems
342-356.
baral
lobo
1995.
characterizing
production
systems
using
logic
programming
situation
calculus
http
//www.cs.utep.edu/baral/papers/char-prod-systems.ps
barringer
fisher
gabbay
owens
reynolds
1996.
imperative
future
principles
executable
temporal
logic
john
wiley
sons
inc.
betz
frühwirth
2005
linear-logic
semantics
constraint
handling
rules
principles
practice
constraint
programming
2005.
springer
berlin
heidel-
berg
137-151.
bonner
kifer
1993.transaction
logic
programming
warren
logic
programming
proc
10th
international
conf
257-279.
brogi
leite
pereira
2002.
evolving
logic
programs
8th
european
conference
logics
artificial
intelligence
jelia'02
flesca
greco
leone
ianni
eds
springer-verlag
lncs
2424
springer-verlag
50-61.
calì
gottlob
lukasiewicz
2009.
datalog±
unified
approach
ontologies
integrity
constraints
proc
12th
international
conference
database
theo-
acm
14-30.
carriero
gelernter
1989
linda
context
communications
acm
444-458.
costantini
tocchio
2004.
dali
logic
programming
agent-oriented
lan-
guage
alferes
j.j.
leite
eds
jelia
2004.
lncs
lnai
vol
3229
springer
hei-
delberg
685–688
damásio
alferes
leite
2010
declarative
semantics
rule
interchange
format
production
rule
dialect
semantic
web–iswc
2010
798-813.
eiter
feier
fink
2012.
simulating
production
rules
using
acthex
cor-
rect
reasoning
211-228.
fernandes
a.a.a.
williams
m.h.
paton
1997.
logic-based
integration
active
deductive
databases
new
generation
computing
vol
205—244
fikes
nilsson
1972.
strips
new
approach
application
theorem
proving
problem
solving
artificial
intelligence
,189-208.
frühwirth
1998.
theory
practice
constraint
handling
rules
journal
logic
programming
1-3
95-138.
frühwirth
2009.
constraint
handling
rules
cambridge
university
press
fung
kowalski
1997.
iff
proof
procedure
abductive
logic
program-
ming
journal
logic
programming
151-165.
gavanelli
lamma
riguzzi
bellodi
zese
cota
2015.
abductive
logic
programming
datalog±
ontologies
proceedings
iclp
2015.
gebser
grote
kaminski
schaub
2011.
reactive
answer
set
programming
logic
programming
nonmonotonic
reasoning
springer
berlin
heidelberg
54-66.
gelfond
lifschitz
1988.
stable
model
semantics
logic
programming
iclp/slp
vol
1070-1080.
gomes
alferes
2014.
transaction
logic
complex
events.arxiv
pre-
print
arxiv:1405.3790.
governatori
rotolo
2013.
computing
temporal
defeasible
logic
ruleml
2013
114-128.
gurevich
2000.
sequential
abstract-state
machines
capture
sequential
algorithms
acm
transactions
computational
logic
tocl
77-111.
harel
1987.
statecharts
visual
formalism
complex
systems
sci
comput
pro-
gramming
231-274.
jaffar
lassez
1987.
constraint
logic
programming
proceedings
14th
acm
sigact-sigplan
symposium
principles
programming
languages
acm
111-
119.
kakas
kowalski
toni
1998.
role
logic
programming
abduction
handbook
logic
artificial
intelligence
programming
oxford
university
press
235-324.
kakas
mancarella
sadri
stathis
toni
2004.
kgp
model
agency
proc
ecai-2004
kowalski
2011.
computational
logic
human
thinking
artificially
intelli-
gent
cambridge
university
press
kowalski
2014.
logic
problem
solving
revisited
edited
thom
frühwirth
herstelling
und
verlag
books
demand
gmbh
norderstedt
kowalski
sadri
1999.
logic
programming
towards
multi-agent
systems
annals
mathematics
artificial
intelligence
vol
391-419.
kowalski
sadri
2009.
integrating
logic
programming
production
systems
abductive
logic
programming
agents
proceedings
third
international
confer-
ence
web
reasoning
rule
systems
chantilly
virginia
usa
kowalski
sadri
2010.
agent
language
destructive
assignment
mod-
el-theoretic
semantics
dix
leite
governatori
jamroga
eds
proc
11th
international
workshop
computational
logic
multi-agent
systems
clima
200-218.
kowalski
sadri
2011.
abductive
logic
programming
agents
destructive
databases
annals
mathematics
artificial
intelligence
vol
129-158.
kowalski
sadri
2012.
logic-based
framework
reactive
systems
rules
web
research
applications
2012
ruleml
2012
springer-verlag
bika-
kis
giurca
eds
lncs
7438
1–15
kowalski
sadri
2014
logical
characterization
reactive
system
language
ruleml
2014
bikakis
eds
ruleml
2014
lncs
8620
springer
internation-
publishing
switzerland
22-36
kowalski
sadri
2015.
model-theoretic
operational
semantics
reactive
computing
new
generation
computing
33-67.
kowalski
sergot
1986.
logic-based
calculus
events
new
generation
com-
puting
67-95.
lausen
ludäscher
may
1998.
active
deductive
databases
statelog
approach
transactions
change
logic
databases
69–106
maier
mendelzon
sagiv
1979.
testing
implications
data
dependencies
acm
trans
database
syst
455-469.
manthey
bry
1988.
satchmo
theorem
prover
implemented
prolog
pro-
ceedings
cade
1988.
lecture
notes
computer
science
310
springer
415-434.
mancarella
terreni
sadri
toni
endriss
2009.the
ciff
proof
proce-
dure
abductive
logic
programming
constraints
theory
implementation
ex-
periments
theory
practice
logic
programming
paschke
boley
zhao
teymourian
athan
2012.
reaction
ruleml
1.0
standardized
semantic
reaction
rules
rules
web
research
applications
springer
berlin
heidelberg
100-119.
rao
1996.
agentspeak
bdi
agents
speak
logical
computable
language
agents
breaking
away
42-55.
rao
georgeff
1995.
bdi
agents
theory
practice
international
conference
multiagent
systems
icmas
312-319.
raschid
1994.
semantics
class
stratified
production
system
programs
journal
logic
programming
31-57.
rezk
kifer
2012
formalizing
production
systems
rule-based
ontologies
foundations
information
knowledge
systems
332-351.
shanahan
1997.
solving
frame
problem
mathematical
investigation
common
sense
law
inertia
mit
press
shapiro
1989
family
concurrent
logic
programming
languages
acm
computing
surveys
csur
413-510.
thielscher
2005.
flux
logic
programming
method
reasoning
agents
theory
practice
logic
programming
4-5
533-565.
van
gelder
ross
schlipf
1991.
well-founded
semantics
general
logic
programs
journal
acm
jacm
619-649.
wang
topor
j.w
maher
m.j.
2001.
reasoning
disjunctive
constrained
tuple-
generating
dependencies
dexa
2001
963-973
zaniolo
1993.
unification
active
databases
deductive
databases
advances
databases
springer
berlin
heidelberg
23-39.
appendix
theorem
given
kelps
framework
aux
initial
state
sequence
ext1
exti
sets
external
events
suppose
generates
sequenc-
sets
acts1
actsi
actions
states
cpre
true
aux
ev*
every
goal
tree
added
goal
state
goal
clause
true
added
goal
tree
goal
state
proof
show
cpre
true
aux
ev*
suffices
show
cpre
true
aux
si*
evi*
evi+1*
ensured
step
ear
true
aux
s0*
...
si*
ev0*
evi*
ear
con
con
consequent
show
true
aux
ev*
need
show
every
rule
form
antecedent
consequent
whenever
instance
antecedent
antecedent
true
corresponding
instance
consequent
consequent
also
true
antecedent
true
antecedent
be-
comes
true
time
aux
s0*
...
si*
ev0*
...
evi*
conse-
quent
added
root
new
goal
tree
current
goal
state
dis-
junct
consequentj
whose
temporal
constraints
satisfiable
aux
added
child
root
node
clearly
consequentj
implies
consequent
true
consequentj
true
consequent
true
truth
true
consequentj
follows
general
fact
goal
clause
added
step
child
goal
clause
true
therefore
existence
goal
state
true
added
goal
tree
consequent
implies
consequent
true
time
therefore
consequent
true
proof
theorem
uses
lemma
proved
using
lemma
lemma
let
rule
exists
rule
form
ear
con
consequent
substitution
grounds
variables
ear
proof
let
number
applications
step
derivation
proof
induction
base
case
derived
applications
step
follows
form
ear
con
consequent
ear
empty
equivalent
true
let
empty
substitution
inductive
step
let
added
application
step
rule
step
form
current
later
consequent
current
later
form
later
consequent
current
true
aux
sk*
evk*
instantiates
variables
current
instantiates
timestamp
variables
fol
conditions
current
inductive
hypothesis
applied
exists
rule
form
earlier
curr
rest
conseq
substitution
grounds
variables
earlier
earlier
true
aux
s0*
...
sk*
ev0*
evk*
earlier
curr
rest
ear
true
aux
s0*
...
si*
ev0*
evi*
ear
con
con
consequent
proves
base
case
current
curr
later
rest
earlier
curr
true
aux
s0*
...
si*
ev0*
evi*
earlier
curr
rest
rest
conseq
proves
inductive
step
lemma
let
goal
clause
exists
rule
form
antecedent
earlier
conds
substitution
grounds
variables
antecedent
earlier
antecedent
earlier
true
aux
s0*
...
si*
ev0*
evi*
earlier
conds
conds
proof
let
number
applications
step
derivation
proof
induction
similar
lemma
base
case
definition
exists
rule
form
true
earlier
earlier
empty
form
required
statement
lemma
added
step
contains
rule
form
true
new
root
node
added
consequence
lemma
exists
rule
form
ear
con
consequent
substitution
grounds
variables
ear
let
consequent
form
alternatives
earlier
conds
earlier
true
conds
grounds
variables
ear
con
earlier
inductive
step
let
added
step
child
goal
clause
step
form
current
later
current
later
form
later
current
true
aux
sk*
evk*
instantiates
variables
current
instantiates
timestamp
variables
fol
conditions
current
inductive
hypothesis
applied
exists
rule
form
antecedent
earlier
curr
rest
substitution
antecedent
earlier
true
aux
s0*
...
sk*
ev0*
evk*
earlier
curr
rest
current
curr
later
rest
ear
true
aux
s0*
...
sk*
ev0*
evk*
ear
con
con
consequent
con
true
consequent
ear
con
earlier
true
aux
s0*
...
si*
ev0*
evi*
earlier
conds
conds
proves
base
case
grounds
variables
antecedent
earlier
rest
proves
inductive
step
true
aux
s0*
...
si*
ev0*
evi*
antecedent
earlier
curr
earlier
curr
rest
theorem
given
range
restricted
kelps
framework
aux
initial
state
set
external
events
ext*
let
acts*
set
actions
generated
ev*
ext*
acts*
aux
ev*
reactive
interpretation
proof
assume
action
action
added
candidate-actsi+1
step
included
actsi+1
step
time
follows
exists
sequencing
action
rest
instance
goal
clause
action
rest
instantiates
timestamp
variable
action
time
i+1
lemma
exists
rule
form
antecedent
earlier
conds1
conds2
substitution
grounds
variables
antecedent
earlier
antecedent
earlier
true
aux
s0*
...
si*
ev0*
evi*
follows
supports
action
sense
conds1
action
conds2
rest
earlier
action
rest
action
conds1
antecedent
earlier
conds1
conds2
antecedent
earlier
conds1
true
moreover
step
ensures
cpre
true
aux
si*
evi+1*
therefore
cpre
true
therefore
reactive
end
proof
theorem
given
range
restricted
kelps
framework
aux
initial
state
external
events
ext*
let
acts*
set
actions
aux
ev*
ev*
ext*
acts*
reactive
interpretation
exist
choices
steps
generates
acts*
therefore
generates
proof
let
supports
action
actt
time
show
induc-
tion
times
exist
choices
steps
beginning
cycle
time
either
exists
reactive
rule
form
earlier
later
consequent
earlier
true
aux
s0*
...
si-1*
ev0*
evi-1*
later
consequent
instance
earlier
later
exists
goal
clause
form
antecedent
early
late
antecedent
early
true
aux
s0*
...
si-1*
ev0*
evi-1*
late
instance
antecedent
early
late
end
cycle
time
i-1
chosen
step
actions
actsi*
clearly
implies
statement
theorem
let
form
true
earlier
act
rest
supports
act
early
earlier
act
rest
early
empty
i.e
true
desired
goal
clause
otherwise
form
later
consequent
later
empty
form
earlier
later
consequent
earlier
empty
desired
reactive
rule
case
holds
also
holds
actions
time
let
assume
holds
beginning
cycle
time
i-1
holds
end
cycle
time
i-2
show
holds
time
let
induction
hypothesis
either
holds
time
i-1
suppose
first
holds
time
i-1
exists
reactive
rule
ri-1
form
earlier
later
consequent
earlier
true
aux
s0*
...
si-2*
ev0*
evi-2*
earlier
later
later
consequent
instance
ri-1
timestamp
later
equal
i-1
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
otherwise
later
form
current
rest
current
true
aux
si-1*
evi-1*
current
rest
step
must
evaluate
fol
conditions
temporal
constraints
current
in-
stance
generating
rule
ri-1
rest
consequent
instance
therefore
ri-1
form
earlier
current
rest
consequent
earlier
current
true
aux
s0*
...
si-1*
ev0*
evi-1*
rest
consequent
instance
earlier
current
rest
rest
empty
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
rest
empty
deletes
adds
new
goal
tree
gi-1
root
node
consequent
instance
supports
action
actt
time
i-1
form
antecedent
con-
clusion
actt
bare
action
conjunction
conclusion
adds
gi-1
goal
clause
child
new
root
node
form
antecedent
conclusion
antecedent
true
aux
s0*
...
si-1*
ev0*
evi-1*
conclusion
instance
antecedent
conclusion
timestamp
fol
conditions
conclusion
equal
i-1
rewrite
con-
clusion
early
late
early
empty
form
antecedent
early
late
antecedent
early
true
aux
s0*
...
si-1*
ev0*
evi-1*
late
instance
antecedent
early
late
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
otherwise
conclusion
form
early
late
early
empty
early
true
aux
si-1*
evi-1*
early
late
let
step
choose
evaluate
fol
conditions
temporal
constraints
early
instance
generating
goal
clause
gi-1
late
instance
form
antecedent
early
late
antecedent
early
true
aux
s0*
...
si-1*
ev0*
evi-1*
late
instance
antecedent
early
late
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
suppose
instead
induction
hypothesis
holds
exists
goal
clause
ci-1
gi-1
form
antecedent
early
late
antecedent
early
true
aux
s0*
...
si-2*
ev0*
evi-2*
late
instance
ci-1
antecedent
early
late
true
aux
s0*
...
si-1*
ev0*
evi-1*
timestamp
fol
conditions
late
equal
i-1
ci-1
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
otherwise
late
form
current
rest
current
empty
current
true
aux
si-1*
evi-1*
current
rest
let
step
choose
evaluate
fol
conditions
temporal
constraints
ci-1
current
instance
generating
goal
clause
gi-1
rest
instance
form
antecedent
early
current
rest
antecedent
early
current
rest
instance
antecedent
early
current
rest
persists
end
cycle
becomes
desired
beginning
next
cycle
holds
time
show
holds
time
need
ensure
steps
choose
acti
follows
ensures
form
antecedent
earlier
action
rest
action
acti
supports
acti
exists
goal
clause
ci-1
action
rest
instance
ci-1
easy
see
step
include
acti
candidate-
actsi
cpre
true
step
choose
acti
among
actions
generated
end
cycle
moreover
bare
action
atom
act
goal
clause
whether
whether
step
chooses
act
step
choose
act
possible
satisfies
cpre
