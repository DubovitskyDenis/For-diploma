set
theoretic
approach
knowledge
representation
representation
part
zhou
artiﬁcial
intelligence
research
group
western
sydney
university
nsw
australia
september
2018
abstract
paper
propose
set
theoretic
approach
knowledge
representa-
tion
syntax
application
domain
captured
set
theoretic
con-
structs
including
individuals
concepts
operators
knowledge
formalized
equality
assertions
ﬁrst
present
primitive
form
uses
minimal
assumed
knowledge
constructs
assuming
naive
set
theory
extend
def-
initions
special
kinds
knowledge
interestingly
show
primitive
form
expressive
enough
deﬁne
logic
operators
proposi-
tional
connectives
also
quantiﬁers
introduction
knowledge
representation
reasoning
one
central
focuses
artiﬁcial
intelligence
baral
2003
brachman
levesque
2004
van
harmelen
al.
2008
intends
syntactically
formalize
information
application
domain
knowl-
edge
complex
problems
domain
solved
reasoning
knowledge
interests
also
highly
inﬂuential
many
subﬁelds
including
expert
systems
multi-agent
systems
planning
uncertainty
cognitive
robotics
semantic
web
brachman
levesque
2004
van
harmelen
al.
2008
nevertheless
encountered
huge
difﬁculties
one
issue
many
features
building
blocks
considered
van
harmelen
al.
2008
in-
stance
propositions
variables
connectives
rules
actions
common
sense
time/space
uncertainty
mental
states
fact
made
huge
successes
formaliz-
ing
building
blocks
separately
however
combing
together
even
several
seems
extremely
difﬁcult
task
side
many
application
domains
e.g
robotics
need
multiple
building
blocks
time
another
critical
related
issue
balance
expressiveness
ef-
ﬁciency
widely
believe
expressive
less
efﬁcient
vice
versa
levesque
brachman
1987
however
many
application
domains
e.g.
robotics
need
yet
difﬁcult
task
formalisms
consider
propositional
logic
fundamental
formalism
takes
propositions
nat-
ural
propositional
connectives
account
inference
problem
conp
complete
means
likely
takes
exponential
time
worst
case
backdrop
argue
needs
simple
extensible
expressive
efﬁcient
approach
extensible
means
approach
allow
current
sys-
tem
easily
extended
building
blocks
expressive
means
approach
able
represent
different
types
knowledge
given
set
building
blocks.
efﬁcient
means
approach
efﬁciently
reason
derive
new
knowledge
order
solve
problems
nevertheless
simple
am-
biguous
term
elaborated
three
aspects
primitive
using
minimal
primitive
constructs
succinct
able
represent
knowledge
various
appli-
cation
domains
relatively
small
knowledge
bases
user-friendly
easy
understood
used
knowledge
engineers
towards
goal
propose
set
theoretic
knowledge
representation
approach
syntactically
representing
knowledge
application
domains
syntax
application
domain
captured
set
individuals
concepts
operators
knowledge
simply
formalized
equality
assertions
form
either
atomic
individuals
compound
individuals
semantically
individuals
concepts
operators
interpreted
elements
sets
functions
respectively
naive
set
theory
knowledge
form
means
two
individuals
referring
element
separate
representation
reasoning
paper
mainly
concerned
basic
ideas
representation
part
leave
reasoning
part
another
paper
paper
ﬁrst
present
primitive
form
uses
minimal
assumed
knowledge
primitive
constructs
assuming
naive
set
theory
extend
building
blocks
deﬁnitions
use
assertions
deﬁne
new
syntactic
objects
including
individuals
concepts
operators
new
objects
deﬁned
used
basis
deﬁne
example
show
deﬁne
multi-assertions
using
cartesian
product
nested
assertions
using
multi-assertions
interestingly
show
method
i.e.
extending
primitive
form
deﬁnitions
based
native
set
theory
powerful
enough
syntactically
capture
logic
operators
including
propositional
connectives
quantiﬁers
primitive
form
section
present
primitive
form
set
theoretic
knowledge
repre-
sentation
approach
goal
syntactically
represent
knowledge
application
domains
two
essential
tasks
i.e.
capture
syntax
domain
represent
knowledge
assume
naive
set
theory
halmos
1960
including
basic
concepts
elements
sets
functions
cartesian
product
built-in
relationships
built-in
operators
boolean
set
set
natural
numbers
cardinality
set
speciﬁcations
2.1
capturing
syntax
given
application
domain
syntactic
structure
structure
short
clear
context
domain
triple
collection
individuals
rep-
resenting
objects
domain
collection
concepts
representing
groups
objects
sharing
something
common
collection
operators
representing
relationships
connections
among
individuals
concepts
concepts
operators
considered
individuals
well
needed
concepts
concepts
concepts
operators
concepts
concepts
operators
operator
could
multi-ary
maps
tuple
individuals
sin-
gle
individual.1
multi-ary
operator
associated
domain
form
representing
possible
values
operator
operate
concept
call
arity
tuple
matching
domain
operator
i.e.
maps
individual
denoted
also
use
denote
set
called
range
operator
operators
similar
functions
ﬁrst-order
logic
differs
two
essential
ways
first
operators
many-sorted
could
different
concepts
importantly
could
high-order
constructs
e.g.
assertions
concepts
concepts
concepts
operators
instance
consider
arithmetic
domain
etc.
individuals
set
natural
numbers
concept
successor
operator
succ
add
operators
add
operators
convenience
unary
sometimes
use
a.o
c.o
denote
binary
sometimes
use
denote
range
operator
boolean
sometimes
use
denote
2.2
representing
knowledge
let
syntactic
structure
term
individual
either
atomic
individ-
ual
result
operator
operating
individuals
also
call
latter
compound
individuals
assertion
form
two
terms
intuitively
assertion
form
piece
knowledge
application
domain
claiming
left
right
side
referring
objects
built-in
equality
relation
naive
set
theory
hence
understood
alternative
way
true
knowledge
base
set
assertions
terms
assertions
considered
individuals
well
instance
arithmetic
succ
two
typical
assertions
1note
naive
set
theory
tuple
sets
cartesian
product
sets
set
well
therefore
multi-ary
operators
essentially
viewed
single-ary
similar
concepts
group
individuals
use
schemas
group
terms
assertions
schema
term
either
atomic
concept
collection
results
essentially
schema
term
represents
set
terms
every
concept
grounded
corresponding
individual
schema
assertion
form
form
except
terms
replaced
schema
terms
similarly
schema
assertion
represents
set
assertions
note
could
case
two
different
individuals
referring
concept
schema
terms
assertions
case
need
use
different
copies
denoted
distinguish
among
instance
assertions
numbers
captured
schema
assertion
side
schema
copy
concept
refer
individual
instance
set
assertions
form
2.3
semantics
introduce
set
theoretic
semantics
deﬁne
meanings
syntactic
structures
knowledge
interpretation
pair
domain
elements
admits
naive
set
theory
mapping
function
maps
individuals
domain
elements
concepts
sets
operators
functions
mapping
functions
generalized
mapping
terms
elements
let
interpretation
assertion
say
model
denoted
iff
also
written
let
knowledge
base
say
model
denoted
iff
model
every
assertion
say
assertion
property
denoted
iff
interpretations
particular
say
assertion
tautology
iff
modeled
interpretations
since
assume
naive
set
theory
directly
borrow
set
theoretic
constructs
individuals
concepts
operators
instance
use
also
writ-
ten
denote
new
concept
unions
two
concepts
applying
assertions
see
assertions
form
indeed
represent
many
important
features
knowledge
representation
instance
membership
asser-
tion
stating
individual
instance
concept
following
assertion
also
written
containment
assertion
stating
con-
cept
contained
another
concept
following
assertion
also
written
range
declaration
stating
range
oper-
ator
operating
concept
equals
another
concept
following
assertion
deﬁnitions
extensibility
primitive
form
foundation
uses
minimal
assumed
knowledge
primitive
constructs
nevertheless
sometimes
convenient
use
formalizing
application
domain
e.g.
represent
logic
expressions
hence
extend
building
blocks
discussed
introduction
section
extensibility
critical
issue
approaches
purpose
introduce
deﬁnitions
approach
deﬁnitions
use
schema
assertions
deﬁne
new
syntactic
objects
individuals
concepts
operators
based
existing
ones
note
deﬁnitions
nothing
extra
special
kinds
knowledge
3.1
deﬁning
individuals
operators
concepts
start
deﬁning
new
individuals
individual
deﬁnition
special
kind
assertion
form
atomic
individual
term
individual
deﬁned
assertion
claims
left
side
deﬁned
right
side
instance
means
individual
deﬁned
empty
set
deﬁning
new
operators
similar
deﬁning
new
individuals
except
use
schema
assertions
purpose
let
operator
deﬁned
domain
operator
deﬁnition
schema
assertion
form
schema
term
mentions
concepts
could
case
mentions
note
refer
concept
need
use
different
copies
respectively
since
schema
assertion
represents
set
assertions
essentially
operator
def-
inition
form
deﬁnes
operator
deﬁning
value
one-by-one
sometimes
also
deﬁne
operators
way
instance
deﬁning
successor
operator
succ
use
schema
assertion
succ
equivalent
alternative
deﬁnition
stat-
ing
every
natural
number
successor
deﬁned
i.e.
succ
instance
succ
deﬁned
deﬁning
new
concepts
different
concepts
essentially
sets
de-
ﬁned
set
theoretic
constructions
directly
borrow
set
theory
notations
deﬁne
concepts
follows
enumeration
let
individuals
collection
concept
written
instance
deﬁne
concept
digits
digits
operation
let
two
concepts
union
intersection
difference
cartesian
product
2c1
power
set
concepts
operation
written
assertions
well
instance
following
assertion
states
concept
deﬁned
union
example
one
deﬁne
concept
human
ale
comprehension
let
concept
schema
assertion
mentions
concept
individuals
satisfying
denoted
c|a
simply
c|a
form
concept
written
c|a
instance
deﬁne
concept
ale
ale
animal
|sex
animal
male
meaning
ale
consists
animals
whose
sex
male
replacement
let
operator
concept
well
deﬁned
individuals
mapped
denoted
simply
form
concept
written
instance
deﬁne
concept
arents
arents
arentof
human
meaning
consists
individuals
arentof
human
deﬁnitions
incremental
may
deﬁne
syntactic
objects
ﬁrst
deﬁned
used
deﬁne
one
always
continue
incre-
mental
process
extend
current
system
instance
arithmetic
deﬁne
successor
operator
ﬁrst
deﬁned
used
deﬁne
add
operator
served
basis
deﬁne
useful
syntactic
objects
clarity
use
symbol
replace
deﬁnitions
force
uniqueness
deﬁnitions
syntactic
object
deﬁned
another
critical
issue
recursiveness
clearly
deﬁnition
invalid
meaningless
hence
need
restrict
deﬁnitions
however
sometimes
use
recursion
deﬁne
concepts
instance
arithmetic
natural
numbers
deﬁne
succ
meaning
natural
number
successor
i.e
succ
also
natural
number
require
recursion
used
replacement
deﬁnition
concepts
recursive
replacement
used
interpret
inﬁnite
process
beginning
concepts
contain
contain
individuals
deﬁned
non-
replacement
deﬁnitions
apply
replacement
deﬁnitions
obtain
new
versions
concepts
ﬁnishes
ﬁrst
step
continue
process
step
ﬁrst
use
non-replacement
deﬁnitions
expand
concepts
apply
replacement
deﬁnitions
obtain
new
versions
concepts
could
inﬁnite
process
instance
consider
deﬁnition
natural
numbers
initially
applying
replacement
deﬁnition
expand
succ
continue
process
obtain
inﬁnite
set
natural
num-
bers
succ
succ
succ
require
deﬁnitions
non-recursive
formally
deﬁnition
dependency
graph
set
deﬁnitions
without
replacements
directed
graph
consists
syntactic
objects
appeared
deﬁnitions
set
pairs
exists
deﬁnition
whose
left
side
whose
right
side
mentions
b.2
set
deﬁnitions
said
non-recursive
corresponding
deﬁnition
dependency
graph
acyclic
2for
operator
deﬁnitions
ignore
concepts
arguments
operator
schema
term
since
essentially
grounded
individuals
fact
one
observe
backus-naur
form
bnf
widely
used
computer
science
deﬁne
syntax
considered
special
case
concept
deﬁnitions
strings
precisely
bnf
uses
three
features
enumeration
single
element
union
operation
recursive
replacement
using
pre-assumed
con-
catenation
operator
comprehension
set
operations
used
3.2
multi-assertions
case
study
extending
primitive
form
deﬁnitions
extend
assertions
form
multi-assertions
given
number
deﬁne
new
operator
multi-assertions
arity
following
schema
assertion
concepts
terms
assertion
states
assertions
assertioni
form
namely
hence
holds
assertioni
holds
sense
single
assertion
used
represent
assertions
assertioni
deﬁne
concept
multi-assertions
follows
ulti
assertion
1≤i≤∞
copies
standard
assertions
convenience
use
assertion1
assertionn
denote
n-ary
multi-assertion
note
multiple
assertions
syntactic
sugar
primitive
form
deﬁned
primitive
form
using
ordered
pairs
cartesian
products
sense
increase
expressive
power
primitive
form
never-
theless
using
make
representation
task
convenient
cases
multi-assertions
interests
deﬁned
used
deﬁne
syntactic
building
blocks
note
ﬁnite
knowledge
bases
ﬁnite
sets
assertions
i.e.
multi-assertions
essentially
viewed
single
assertions
3.3
nested
terms
assertions
continue
extensions
primitive
form
introducing
nested
terms
nested
assertions
note
terms
deﬁned
section
nested
sense
individuals
used
inside
operator
must
atomic
generalized
nested
terms
operators
use
compound
individuals
inside
nested
terms
deﬁned
following
deﬁnition
ested
erm
erm
erm
erm
ested
erm
erm
concept
standard
term
deﬁned
section
arbitrary
operator
est
erm
replacement
deﬁnition
individuals
est
erm
domain
deﬁnition
recursive
deﬁnition
fact
simpliﬁed
ested
erm
erm
ested
erm
however
deﬁnition
uses
nested
terms
well
since
ested
erm
atomic
hence
formally
deﬁning
meaning
nested
terms
use
former
nevertheless
example
see
interpret
nested
terms
whenever
nested
term
used
introduce
new
atomic
individual
replace
claim
atomic
individual
deﬁnes
nested
term
formalize
idea
also
need
nested
assertions
terms
used
sides
assertion
nested
ested
assertion
ested
erm
ested
erm
mentioned
nested
assertions
represented
non-nested
multi-assertions
introducing
new
individuals
whenever
result
nested
term
used
introduce
new
individual
replace
claim
new
individual
deﬁned
nested
term
every
nested
term
op′
occurred
nested
assertion
introduce
new
atomic
individual
replace
term
add
new
assertion
op′
instance
nested
assertion
op′
op′
deﬁned
op′
op′
new
individuals
sense
nested
assertion
essentially
multi-assertion
represented
single
assertion
therefore
nested
assertion
syntactic
sugar
primitive
form
well
using
nested
assertions
simplify
representation
task
however
one
can-
overuse
nested
assertions
since
essentially
every
use
nested
term
introduces
new
individual
instance
one
easily
get
lost
nested
assertion
like
op′
op′
logic
operators
assertions
section
continue
extend
primitive
form
logic
operators
assertions
interestingly
deﬁne
propositional
connectives
also
quantiﬁers
based
naive
set
theory
one
side
provides
another
case
study
extend
primitive
form
side
shows
assuming
naive
set
theory
primitive
form
expressive
enough
capture
logic
4.1
propositional
operators
assertions
start
propositional
case
let
concept
nested
assertions
introduce
number
operators
including
negation
conjunction
disjunction
implication
equivalence
could
different
ways
deﬁne
operators
depending
oper-
ators
deﬁned
directly
deﬁned
based
previous
ones
directly
deﬁne
negation
conjunction
disjunction
implication
indirectly
deﬁne
equivalence
let
two
nested
assertions
propositional
connectives
deﬁned
follows
also
use
denote
one
observe
ranges
logic
operators
nested
assertions
hence
similar
multi-
nested
assertions
propositional
logic
operators
syntactic
sugar
well
consider
properties
instance
according
deﬁnitions
de-
morgan
laws
tautologies
theorem
let
two
nested
assertions
interpretations
also
relationship
implication
disjunction
i.e.
¬a1∨
tautology
well
fact
tautologies
propositional
logic
tautologies
context
i.e.
modeled
interpretations
vice
versa
actually
follows
follow-
ing
theorem
stating
syntactic
deﬁnitions
deﬁnes
semantics
logic
operators
theorem
let
two
nested
assertions
interpretations
iff
model
iff
model
iff
model
either
|=→
iff
model
implies
model
|=≡
iff
model
model
4.2
quantiﬁers
assertions
consider
quantiﬁers
including
universal
quantiﬁer
existential
quantiﬁer
domain
quantiﬁers
pair
concept
schema
assertion
mentions
quantiﬁers
deﬁnes
follows
c|a
c|a
intuitively
true
iff
individuals
holds
equals
concept
individuals
holds
true
iff
individuals
holds
equal
empty
set
exists
least
one
individual
holds
see
ranges
quantiﬁers
nested
assertions
well
thus
quantiﬁers
also
syntactic
sugar
primitive
form
similarly
syntactic
deﬁnitions
quantiﬁers
based
naive
set
theory
capture
semantics
theorem
let
concept
schema
assertion
mentions
interpretations
iff
individuals
iff
exists
least
one
individual
consequence
one
prove
properties
quantiﬁers
instance
universal
quantiﬁers
existential
quantiﬁers
dual
negation
note
quantiﬁers
deﬁned
ranging
arbitrary
concept
concept
atomic
individuals
quantiﬁers
range
concept
quantiﬁers
ﬁrst-order
nevertheless
concepts
could
different
case
many-sorted
ﬁrst-order
logic
moreover
could
complex
concepts
e.g.
concept
possible
concepts
case
monadic
second-
order
logic
yet
could
many
e.g.
concept
assertions
concept
concepts
terms
etc
sense
quantiﬁers
become
high-order
conclusions
discussions
related
work
paper
proposed
set
theoretic
approach
syntactically
represent
knowledge
application
domains
syntax
domain
captured
individ-
uals
i.e.
objects
domain
concepts
i.e.
groups
objects
sharing
something
common
operators
i.e.
connections
relationships
among
objects
set
theory
point
view
individuals
concepts
operators
interpreted
ele-
ments
sets
functions
respectively
primitive
form
knowledge
domain
simply
captured
equality
assertions
form
terms
shown
extend
system
deﬁnitions
special
kinds
knowledge
used
deﬁne
new
individuals
concepts
operators
instance
extended
primitive
form
multi-assertions
nested
assertions
syntactic
sugar
primitive
form
expressed
extensibility
critical
issue
approach
able
deﬁne
new
syntactic
objects
based
exiting
ones
deﬁned
objects
used
deﬁne
interestingly
shown
logic
operators
propositional
connec-
tives
also
quantiﬁers
deﬁned
primitive
form
based
naive
set
theory
one
side
shows
deﬁne
semantics
logic
operators
syntacti-
cally
side
shows
expressiveness
approach
discussed
introduction
section
motivation
propose
simple
ex-
tensible
expressive
efﬁcient
approach
extensibility
expressiveness
discussed
two
paragraphs
simplicity
difﬁcult
justify
argue
approach
indeed
satisfy
three
aspects
simplicity
primitiveness
approach
uses
naive
set
theory
syntax
including
individuals
concepts
opera-
tors
knowledge
form
succinctness
primitive
form
needs
double
length
simulate
logic
arguably
succinct
formalism
user-friendliness
believe
knowledge
form
similar
as-
signment
statement
programming
easily
understood
used
knowledge
engineers
certainly
one
deﬁne
multi-assertion
nested
assertion
logic
operators
di-
rectly
nevertheless
motivation
provide
simple
foundation
knowledge
representation
features
building
blocks
deﬁned
extensions
believe
primitive
form
candidate
evident
fact
able
capture
high-order
logic
expressions
work
two
philosophical
implications
first
answering
question
knowledge
approach
deﬁnes
equality
assertions
two
terms
evident
fact
single
equality
assertions
capture
high-order
logic
expressions
based
naive
set
theory
believe
provides
uniformed
view
knowledge
uniformed
view
critical
understanding
representing
knowledge
also
utilizing
reasoning
knowledge
second
shown
deﬁne
semantics
logic
syntactically
based
naive
set
theory
believe
thing
done
semantics
features
e.g.
nonmonotonic
reasoning
useful
operations
done
machines
syntax
based
paper
mainly
focused
representation
part
leave
reasoning
part
efﬁciency
discussions
another
paper
nevertheless
worth
mentioning
little
roughly
speaking
reasoning
derive
properties
knowledge
base
distinguish
querying
reasoning
former
check
whether
assertion
property
knowledge
base
latter
ﬁnd
properties
given
knowledge
base
clearly
reasoning
serve
means
querying
querying
generally
difﬁcult
approach
express
logic
nevertheless
reasoning
could
efﬁcient
exactly
focus
reasoning
paper
although
querying
full
language
generally
undecidable
could
meaningful
useful
tractable
subclasses
important
case
database
note
primitive
form
knowledge
simply
formalized
equality
assertions
form
nevertheless
indeed
expressive
could
complex
nested
terms
database
context
contains
two
kinds
equality
asser-
tions
i.e.
data
form
atomic
individuals
membership
statements
atomic
individual
atomic
concept
sense
data
special
kind
knowledge
querying
database
tractable
leave
detailed
discussions
another
work
set
theoretic
approach
deeply
inspired
rooted
many
formalisms
including
propositional
ﬁrst-order
logic
semantic
network
description
logic
dynamic
version
approach
presented
another
paper
deeply
related
rule
based
formalisms
including
hoare
logic
answer
set
programming
interestingly
although
originated
different
motivation
approach
shares
many
basic
ideas
borrows
many
notations
description
logic
baader
al.
2003
fact
rewrite
building
blocks
description
logic
approach
since
primitive
form
capture
ﬁrst-order
logic
table
depicts
deﬁned
transform
binary
boolean
relationship
table
rewriting
description
logic
approach
constructs
individual
concept
role
intersection
union
complement
reverse
role
existential
restriction
universal
restriction
least
restriction
nominal
concept
assertion
role
assertion
individual
equality
concept
inclusion
description
logic
approach
individual
concept
role
∃r.c
∀r.c
nr.c
individual
concept
binary
boolean
operator
cr−
cr−
cr−
unary
operator
i.e.
d|r
denotes
cardinality
nevertheless
approach
differs
description
logic
several
essential
ways
important
difference
purpose
forming
new
concepts
operators/roles
approach
directly
uses
set
theoretic
constructs
including
compre-
hension
replacement
description
logics
use
role
restrictions
example
suppose
want
specify
concept
including
human
female
children
approach
formalized
human
children
human
emale
description
logic
formalized
arentof
emale
secondly
use
multi-ary
operators
e.g.
add
operator
instead
binary
boolean
relationships
connect
individuals/concepts
thirdly
knowledge
approach
essentially
formalized
form
i.e.
equality
assertions
fourthly
allow
complex
as-
sertions
including
high-order
constructs
last
least
particularly
highlight
importance
extensibility
approach
shall
present
series
papers
propose
set
theoretic
knowledge
repre-
sentation
approach
paper
foundation
mainly
concerned
basic
ideas
representation
part
mentioned
number
things
present
future
one
critical
task
present
reasoning
part
another
one
formal-
ize
dynamics
including
represent
basic
compound
actions
describe
effects
actions
interactions
among
knowledge
actions
references
baader
al.
2003
franz
baader
diego
calvanese
deborah
mcguinness
daniele
nardi
peter
patel-schneider
editors
description
logic
hand-
book
theory
implementation
applications
cambridge
university
press
new
york
usa
2003
baral
2003
chitta
baral
knowledge
representation
reasoning
declarative
problem
solving
cambridge
university
press
new
york
usa
2003
brachman
levesque
2004
ronald
brachman
hector
levesque
knowl-
edge
representation
reasoning
elsevier
2004
halmos
1960
paul
halmos
naive
set
theory
van
nostrand
1960.
reprinted
springer-verlag
undergraduate
texts
mathematics
1974
levesque
brachman
1987
hector
levesque
ronald
brachman
expres-
siveness
tractability
knowledge
representation
reasoning
computational
intelligence
3:78–93
1987
van
harmelen
al.
2008
frank
van
harmelen
vladimir
lifschitz
bruce
porter
editors
handbook
knowledge
representation
volume
foundations
artiﬁcial
intelligence
elsevier
2008
