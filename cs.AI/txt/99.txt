solving
maxsat
successive
calls
sat
solver
mohamed
halaby
department
mathematics
faculty
science
cairo
university
giza
12613
egypt
halaby
sci.cu.edu.eg
abstract
maximum
satisﬁability
maxsat
problem
problem
ﬁnding
truth
assignment
maximizes
number
satisﬁed
clauses
given
boolean
formula
conjunctive
normal
form
cnf
many
exact
solvers
maxsat
de-
veloped
recent
years
many
presented
well-known
sat
conference
algorithms
maxsat
generally
fall
two
categories
branch
bound
algorithms
algorithms
use
successive
calls
sat
solver
sat-
based
paper
practical
problems
sat-based
algorithms
shown
eﬃcient
paper
provides
experimental
investigation
compare
performance
recent
sat-based
branch
bound
algorithms
benchmarks
maxsat
evaluations
contents
introduction
preliminaries
linear
search
algorithms
binary
search-based
algorithms
core-guided
algorithms
4.1
malik
algorithm
4.2
wpm1
4.3
improved
wpm1
4.4
wpm2
4.5
wmsu1-ror
4.6
wmsu3
4.7
wmsu4
core-guided
binary
search
algorithms
portfolio
maxsat
techniques
translating
pseudo-boolean
constraints
cnf
7.1
introduction
7.2
encoding
method
7.3
complexity
encoding
7.3.1
polynomial
cases
7.3.2
exponential
cases
7.4
encoding
techniques
experimental
investigation
8.1
solvers
descriptions
8.2
benchmarks
descriptions
8.3
results
8.3.1
random
category
8.3.2
crafted
category
8.3.3
industrial
category
acknowledgments
list
algorithms
linearunsat
linear
search
unsat-based
algorithm
solving
wp-
maxsat
linearsat
linear
search
sat-based
algorithm
solving
wpmaxsat
bins-wpmaxsat
binary
search
based
algorithm
solving
wpmaxsat
binlin-wpmaxsat
alternating
binary
linear
searches
solving
wpmaxsat
bitbased-wpmaxsat
bit-based
algorithm
solving
wpmaxsat
malik
malik
algorithm
solving
pmaxsat
wpm1
wpm1
algorithm
wpmaxsat
wpm2
wpm2
algorithm
wpmaxsat
newbound
wmsu1-ror
hard
determines
clause
hard
ror
determines
clause
hard
ancestors
improvedwpm1
stratiﬁed
approach
wpm1
algorithm
used
wmsu3
wmsu3
algorithm
wpmaxsat
wmsu4
wmsu4
algorithm
wpmaxsat
coreguided-bs
core-guided
binary
search
algorithm
solving
wp-
maxsat
disjointcoreguided-bs
core-guided
binary
search
extended
disjoint
cores
solving
wpmaxsat
introduction
preliminaries
variable
negation
clause
disjunction
literals
i.e.
cid:87
clause
composed
deﬁned
cid:86
boolean
variable
take
one
two
possible
values
false
true
literal
i=1
cnf
formula
conjunction
clauses
formally
cnf
formula
composed
clauses
j=1
paper
set
clauses
referred
boolean
formula
i=1
cid:87
truth
assignment
satisﬁes
boolean
formula
satisﬁes
every
clause
given
cnf
formula
satisﬁability
problem
sat
deciding
whether
satisfying
truth
assignment
i.e.
assignment
variables
satisﬁes
every
clause
maximum
satisﬁability
maxsat
problem
asks
truth
assignment
maximizes
number
satisﬁed
clauses
many
theoretical
practical
problems
encoded
sat
maxsat
debugging
circuits
design
scheduling
observation
satellite
captures
photos
earth
course
timetabling
software
package
upgrades
routing
reasoning
protein
structure
alignment
bioinformatics
let
cs+1
cs+h
cnf
formula
natural
numbers
weighted
partial
maxsat
problem
asks
assignment
satisﬁes
cs+1
cs+h
called
hard
clauses
maximizes
sum
weights
satisﬁed
clauses
called
soft
clauses
general
exact
maxsat
solvers
follow
one
two
approaches
successively
calling
sat
solver
sometimes
called
sat-based
approach
branch
bound
ap-
proach
former
converts
maxsat
problem
diﬀerent
hypothesized
maximum
weights
multiple
sat
problems
uses
sat
solver
solve
sat
problems
determine
actual
solution
sat-based
approach
converts
wpmaxsat
prob-
lem
sequence
sat
instances
solved
using
sat
solvers
one
way
given
unweighted
maxsat
instance
check
assignment
falsiﬁes
clauses
assignment
found
check
assignment
falsiﬁes
one
clause
repeated
time
increment
number
clauses
allowed
alse
sat
solver
returns
rue
meaning
minimum
number
falsiﬁed
clauses
determined
recent
comprehensive
surveys
sat-based
algorithms
found
second
approach
utilizes
depth-ﬁrst
branch
bound
search
space
possible
assignments
evaluation
function
computes
bound
applied
search
node
determine
pruning
opportunity
paper
surveys
satisﬁability-
based
approach
provides
experimental
investigation
comparison
performances
approaches
sets
benchmarks
numerous
calls
sat
solver
approach
makes
improvement
sat
algorithms
immediately
beneﬁts
maxsat
sat-based
methods
experimental
results
maxsat
evaluations1
shown
sat-based
solvers
competent
handle
large
maxsat
instances
industrial
applications
branch
bound
methods
1web
page
http
//www.maxsat.udl.cat
linear
search
algorithms
lower
bound
initialized
maximum
possible
cost
i.e
cid:80
|φs|
simple
way
solve
wpmaxsat
augment
soft
clause
new
variable
called
blocking
variable
constraint
added
speciﬁed
cnf
saying
sum
weights
falsiﬁed
soft
clauses
must
less
given
value
next
formula
without
weights
together
constraint
sent
sat
solver
check
whether
satisﬁable
cost
optimal
solution
found
algorithm
terminates
otherwise
decreased
process
continues
sat
solver
returns
rue
algorithm
start
searching
optimal
cost
i=1
decrease
optimal
cost
set
increase
optimal
cost
solvers
employ
former
approach
called
satisﬁability-based
confused
name
general
method
solvers
ones
follow
latter
called
unsat-based
solvers
cost
means
soft
clauses
satisﬁed
cost
means
soft
clauses
falsiﬁed
algorithm
employs
ﬁrst
method
search
optimal
cost
maintaining
maintaining
lower
bound
initialized
line
algorithm
linearunsat
linear
search
unsat-based
algorithm
solving
wpmaxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
foreach
let
new
blocking
variable
state
sat
cid:80
|φs|
rue
i=1
wibi
state
rue
return
pdatebound
next
algorithm
relaxes
soft
clause
new
variable
lines
2-4.
formula
contains
soft
clause
augmented
new
blocking
variable
loop
lines
5-9
sends
clauses
without
weights
sat
solver
line
sat
solver
returns
rue
linearunsat
terminates
returning
solution
lines
7-8
otherwise
lower
bound
updated
loop
continues
sat
solver
returns
rue
function
pdatebound
line
updates
lower
bound
either
simply
increasing
means
depend
distribution
weights
input
formula
later
paper
see
subset
sum
problem
possible
implementation
pdatebound
note
could
ineﬃcient
pdatebound
changes
one
iteration
consider
wpmaxsat
formula
ﬁve
soft
clauses
weights
100.
cost
optimal
solution
anything
else
100
101
102
103
104.
thus
assigning
values
unnecessary
result
large
number
iterations
example
2.1.
let
¬x6
¬x1
¬x2
¬x2
¬x3
¬x3
¬x4
¬x4
∨¬x5
¬x5
∨¬x1
run
linearunsat
soft
clauses
relaxed
¬x6
initialized
sequence
iterations
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
included
state
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
included
state
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
included
state
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
included
state
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
included
state
rue
sat
solver
returns
assignment
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
leads
wpmaxsat
solution
ignore
values
variables
cost
20.
next
algorithm
describes
sat-based
technique
algorithm
starts
ini-
tializing
upper
bound
one
plus
sum
weights
soft
clauses
line
algorithm
linearsat
linear
search
sat-based
algorithm
solving
wp-
maxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
cid:80
|φs|
foreach
i=1
let
new
blocking
variable
rue
state
alse
state
sat
cid:80
|φs|
cid:80
|φs|
i=1
lasti
return
lasti
i=1
wibi
iteration
algorithm
except
last
formula
satisﬁable
cost
optimal
solution
found
immediately
transition
satisﬁable
unsatisﬁable
instance
linearsat
begins
initializing
upper
bound
one
plus
sum
weights
soft
clauses
line
loop
lines
4-8
continues
formula
becomes
unsatisﬁable
line
algorithm
returns
wpmaxsat
solution
terminates
line
long
formula
satisﬁable
formula
sent
sat
note
updating
upper
bound
cid:80
|φs|
solver
along
constraint
assuring
sum
weights
falsiﬁed
soft
clauses
less
line
upper
bound
updated
sum
weights
soft
clauses
falsiﬁed
assignment
returned
sat
solver
line
i=1
eﬃcient
simply
decreasing
upper
bound
one
uses
less
iterations
thus
problem
solved
less
sat
calls
example
2.2.
run
linearsat
previous
example
soft
clauses
relaxed
x1∨b1
x2∨b2
x3∨b3
x4∨b4
x5∨b5
x6∨b6
¬x6∨
initialized
51.
sequence
iterations
constraint
5b1+5b2+10b3+5b4+10b5+5b6+10b7
included
state
rue
alse
alse
alse
alse
alse
alse
rue
rue
rue
rue
rue
rue
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
in-
cluded
state
rue
alse
alse
alse
alse
rue
alse
rue
rue
rue
rue
alse
rue
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
in-
cluded
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
constraint
5b1
5b2
10b3
5b4
10b5
5b6
10b7
20−
included
state
alse
assignment
previous
step
indeed
solution
ignore
values
variables
cost
binary
search-based
algorithms
wpmaxsat
algorithm
take
cid:80
|φs|
value
optimal
cost
among
set
values
cid:80
|φs|
number
iterations
linear
search
algorithms
wpmaxsat
take
linear
sum
weights
soft
clauses
thus
worst
case
linear
search
i=1
calls
sat
solver
since
searching
i=1
binary
search
used
uses
less
iterations
linear
search
algorithm
searches
cost
optimal
assignment
using
binary
search
algorithm
bins-wpmaxsat
binary
search
based
algorithm
solving
wp-
maxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
state
sat
state
alse
return
cid:80
|φs|
foreach
i=1
let
new
blocking
variable
cid:99
mid
cid:98
lb+u
state
sat
cid:80
|φs|
cid:80
|φs|
i=1
state
rue
lasti
else
pdatebound
|φs|
mid
i=1
wibi
mid
return
lasti
bins-wpmaxsat
begins
checking
satisﬁability
hard
clauses
line
beginning
search
solution
sat
solver
returns
alse
line
bins-wpmaxsat
returns
empty
assignment
terminates
line
algorithm
updates
lower
bound
upper
bound
initialized
respectively
one
plus
sum
weights
soft
clauses
lines
4-5
soft
clauses
augmented
blocking
variables
lines
6-8
iteration
main
loop
lines
9-16
middle
value
mid
changed
average
constraint
added
requiring
sum
weights
relaxed
soft
clauses
less
equal
middle
value
clauses
describing
constraint
sent
sat
solver
along
clauses
line
sat
solver
returns
rue
line
cost
optimal
solution
less
mid
updated
line
otherwise
algorithm
looks
optimal
cost
mid
updated
line
main
loop
continues
number
iterations
bins-wpmaxsat
i=1
considerably
lower
complexity
executes
proportional
log
cid:80
|φs|
linear
search
methods
following
example
pdatebound
assigns
mid
example
3.1.
consider
example
2.1
weights
soft
clauses
set
beginning
following
sequence
iterations
algorithm
executes
mid
cid:98
cid:99
constraint
included
state
alse
mid
cid:98
8+3
cid:99
constraint
included
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
assignment
indeed
optimal
one
falsifying
four
clauses
often
stated
binary
search
algorithm
performs
better
linear
search
although
true
time
instances
linear
search
faster
binary
search
let
sum
soft
clauses
falsiﬁed
assignment
returned
sat
solver
ﬁrst
iteration
indeed
optimal
solution
linear
search
methods
would
discover
fact
next
iteration
binary
search
ones
would
take
log
iterations
declare
optimal
cost
order
beneﬁt
search
methods
developed
pmaxsat
algorithm
called
qmaxsat
version
0.4
alternates
linear
search
binary
search
see
algorithm
algorithm
binlin-wpmaxsat
alternating
binary
linear
searches
solving
wpmaxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
state
sat
state
alse
return
foreach
let
new
blocking
variable
cid:80
|φs|
i=1
mode
binary
cid:99
mid
cid:98
lb+u
mode
binary
else
mid
state
sat
cid:80
|φs|
cid:80
|φs|
i=1
state
rue
lasti
i=1
wibi
mid
else
mode
binary
pdatebound
|φs|
mid
else
mid
mode
binary
mode
linear
else
mode
binary
return
lasti
clauses
constraint
cid:80
|φs|
algorithm
begins
checking
set
hard
clauses
satisﬁable
line
algorithm
returns
empty
assignment
terminates
line
next
soft
clauses
relaxed
lines
4-6
lower
upper
bounds
initialized
respectively
one
plus
sum
weights
soft
clauses
lines
7-8
binlin-wpmaxsat
two
execution
modes
binary
linear
mode
execution
initialized
line
binary
search
iteration
main
loop
lines
10-27
sat
solver
called
i=1
wibi
bounded
mid
point
line
current
mode
binary
upper
bound
mode
linear
line
formula
satisﬁable
line
upper
bound
updated
otherwise
lower
bound
updated
mid
point
end
iteration
mode
execution
ﬂipped
lines
24-27
since
cost
optimal
solution
integer
represented
array
bits
algorithm
uses
fact
determine
solution
bit
bit
bitbased-wpmaxsat
starts
signiﬁcant
bit
iteration
moves
one
bit
closer
least
signiﬁcant
bit
optimal
cost
found
algorithm
bitbased-wpmaxsat
bit-based
algorithm
solving
wp-
maxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
state
sat
state
alse
return
foreach
let
new
blocking
variable
cid:98
cid:80
|φs|
i=1
cid:99
currbit
cost
currbit
i=1
wibi
cost
state
rue
lasti
let
constants
state
sat
cid:80
|φs|
i=1
cid:80
cid:80
|φs|
cost
cid:80
j=0
2jsj
representation
current
cost
currbit
max
currbit
currbit
j=currbit
2jsj
else
currbit
currbit
cost
cost
2currbit
binary
return
lasti
beginning
algorithm
previous
ones
satisﬁability
hard
clauses
checked
soft
clauses
relaxed
sum
weights
soft
clauses
upper
bound
cost
thus
computed
determine
number
bits
needed
represent
optimal
solution
line
index
current
bit
considered
initialized
line
value
solution
constructed
initialized
line
main
loop
lines
10-20
terminates
reached
least
signiﬁcant
bit
currbit
iteration
sat
solver
called
constraint
saying
sum
weights
falsiﬁed
soft
clauses
must
less
cost
line
sat
solver
returns
rue
line
sum
weights
soft
clauses
falsiﬁed
current
assignment
computed
set
bits
needed
represent
number
determined
well
line
index
current
bit
decreased
next
currbit
line
index
exist
currbit
becomes
following
iteration
algorithm
terminates
hand
sat
solver
returns
alse
search
continues
signiﬁcant
bit
decrementing
currbit
line
since
optimal
cost
greater
current
value
cost
decreased
2currbit
line
example
3.2.
consider
example
2.1
weights
soft
clauses
beginning
algorithm
soft
clauses
relaxed
formula
becomes
¬x6
also
variables
currbit
cost
initialized
respectively
following
iterations
bitbased-wpmaxsat
executes
constraint
included
state
alse
currbit
cost
constraint
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
currbit
core-guided
algorithms
previous
method
unsat
methods
use
sat
solvers
iteratively
solve
maxsat
purpose
iterative
sat
calls
identify
relax
unsatisﬁable
formulas
unsatisﬁable
cores
maxsat
instance
method
ﬁrst
proposed
2006
malik
see
algorithm
algorithms
described
section
malik
algorithm
wpm1
improved
wpm1
wpm2
wmsu1-ror
wmsu3
wmsu4
deﬁnition
4.1
unsatisﬁable
core
unsatisﬁable
core
cnf
formula
subset
unsatisﬁable
deﬁnition
4.2
minimum
unsatisﬁable
core
minimum
unsatisﬁable
core
contains
smallest
number
original
clauses
required
still
unsatisﬁable
deﬁnition
4.3
minimal
unsatisﬁable
core
minimal
unsatisﬁable
core
unsatis-
ﬁable
core
proper
subset
core
modern
sat
solvers
provide
unsatisﬁable
core
by-product
proof
unsatisﬁability
idea
paradigm
follows
given
wpmaxsat
instance
cs+1
cs+h
let
sat
instance
satisﬁable
assignment
cost
less
equal
encode
cid:32
cid:88
cid:33
conversion
constraint
cid:80
i=1
wibi
extend
every
soft
clause
new
auxiliary
variable
add
cnf
cs+1
cs+h
wibi
kopt
unsatisﬁable
kopt
may
range
cid:80
let
kopt
cost
optimal
assignment
thus
satisﬁable
i=1
hence
search
optimal
assignment
corresponds
location
transition
satisﬁable
unsatisﬁable
encoding
guarantees
satisfying
as-
signments
φkopt
set
optimal
assignments
wpmaxsat
instance
i=1
4.1
malik
algorithm
malik
implemented
two
pmaxsat
solvers
chaﬀbs
uses
binary
search
ﬁnd
optimal
cost
chaﬀls
uses
linear
search
ﬁnd
optimal
cost
top
sat
solver
called
zchaﬀ
pmaxsat
solvers
participated
ﬁrst
second
maxsat
evaluations
method
algorithm
basis
many
wpmaxsat
solvers
came
later
notice
input
algorithm
pmaxsat
instance
since
weights
soft
clauses
algorithm
malik
malik
algorithm
solving
pmaxsat
input
cs+1
cs+h
output
cost
optimal
assignment
sat
cs+1
cs+h
alse
return
opt
rue
state
sat
state
rue
cost
optimal
solution
number
clauses
falsified
return
opt
foreach
cid:54
let
new
blocking
variable
cid:80
i∈b
add
cardinality
constraint
hard
clauses
opt
opt
malik
algorithm
also
referred
msu1
begins
checking
hard
clause
falsiﬁed
line
terminates
returning
cost
line
next
unsatisﬁable
cores
identiﬁed
iteratively
calling
sat
solver
soft
clauses
line
working
formula
satisﬁable
line
algorithm
halts
returning
cost
optimal
assignment
line
algorithm
starts
second
phase
relaxing
soft
clause
unsatisﬁable
core
obtained
earlier
adding
fresh
variable
addition
saving
index
relaxed
clause
lines
11-14
next
new
working
formula
constraints
added
indicating
exactly
one
variables
rue
line
finally
cost
increased
one
line
clause
falsiﬁed
procedure
continues
sat
solver
declares
formula
satisﬁable
4.2
wpm1
ans´otegui
bonet
levy
extended
malik
wpmaxsat
resulting
algo-
rithm
called
wpm1
described
algorithm
algorithm
wpm1
wpm1
algorithm
wpmaxsat
input
wpmaxsat
instance
output
optimal
cost
wpmaxsat
solution
sat
alse
return
cost
rue
state
sat
state
rue
return
cost
wmin
min
cid:54
compute
minimum
weight
soft
clauses
foreach
cid:54
let
new
blocking
variable
wmin
wmin
else
return
alse
unsatisfiable
cid:0
cid:80
b∈bv
cid:1
add
cardinality
constraint
hard
clauses
cost
cost
wmin
malik
algorithm
calls
sat
solver
iteratively
working
formula
without
weights
line
sat
solver
returns
unsatisﬁable
core
algorithm
terminates
core
contains
hard
clauses
algorithm
computes
minimum
weight
clauses
core
wmin
line
next
working
formula
transformed
duplicating
core
line
one
copy
clauses
associated
original
weight
minus
minimum
weight
second
copy
clauses
augmented
blocking
variables
original
weight
i=1
cid:16
cid:80
cid:16
cid:80
cid:17
cid:17
···
finally
cardinality
constraint
blocking
variable
added
hard
clauses
line
cost
increased
minimum
weight
line
wpm1
uses
blocking
variables
eﬃcient
way
unsatisﬁable
core
appears
times
copies
get
set
blocking
vari-
ables
possible
two
formulae
maxsat
equivalent
meaning
minimum
number
unsatisﬁable
clause
however
algo-
rithm
avoid
using
one
blocking
variable
per
clause
disadvantage
eliminated
wmsu3
described
later
example
4.1.
consider
¬x1
¬x2
x1∨¬x3
x2∨¬x3
following
jth
iteration
possible
execution
sequence
algorithm
relaxation
variable
added
clause
cid:16
cid:80
i=1
i=1
cid:17
state
alse
¬x3
¬x1
¬x2
¬x3
¬x3
wmin
¬x1
¬x2
¬x3
¬x3
state
alse
¬x1∨¬x2
wmin
x1∨b2
x2∨
¬x3
¬x1
¬x2
¬x3
cid:88
state
rue
optimal
assignment
soft
satisﬁes
sat
solver
returns
diﬀerent
unsatisﬁable
core
ﬁrst
iteration
diﬀerent
execution
sequence
going
take
place
4.3
improved
wpm1
2012
ans´otegui
bonet
levy
presented
modiﬁcation
wpm1
algorithm
wpm1
clauses
core
duplicated
computing
minimum
weight
wmin
clause
core
wmin
wmin
added
working
formula
removed
process
duplication
ineﬃcient
clause
weight
converted
copies
weight
authors
provided
following
example
illustrate
issue
consider
¬x2
sat
solver
always
includes
ﬁrst
clause
identiﬁed
core
working
¬x2
formula
ﬁrst
iteration
iteration
sat
solver
includes
ﬁrst
clause
¬x2
unsatisﬁable
core
iterations
formula
1∨···∨bi
would
x1∨b1
case
wpm1
would
need
iterations
solve
problem
x2∨b2∗1
x2∨bi
w−i
¬x2
+b1
algorithm
improvedwpm1
stratiﬁed
approach
wpm1
algorithm
input
wpmaxsat
instance
cm+1
cm+m
cid:48
wm+m
cid:48
output
cost
optimal
wpmaxsat
solution
sat
alse
return
cost
hard
clauses
satisfied
cost
wmax
max
wmax
initialize
wmax
largest
weight
smaller
rue
state
sat
wmax
state
rue
wmax
return
cost
else
state
rue
wnax
max
wmax
else
set
blocking
variables
unsatisfiable
core
wmin
min
cid:54
minimum
weight
soft
clauses
unsatisfiable
core
foreach
cid:54
let
new
variable
wmin
wmin
cid:80
b∈bv
cardinality
constraint
added
hard
clauses
cost
cost
wmin
algorithm
overcomes
problem
utilizing
stratiﬁed
approach
aim
restrict
clauses
sent
sat
solver
force
concentrate
higher
weights
leads
sat
solver
return
unsatisﬁable
cores
clauses
larger
weights
cores
clauses
larger
weight
better
contribute
increasing
cost
faster
clauses
lower
weights
used
sat
solver
returns
rue
algorithm
starts
initializing
wmax
largest
weight
smaller
line
clauses
weight
greater
equal
wmax
sent
sat
solver
algorithm
terminates
sat
solver
returns
rue
wmax
zero
lines
7-8
wmax
zero
formula
satisﬁable
wmax
decreased
largest
weight
smaller
wmax
lines
10-11
sat
solver
returns
alse
algorithm
proceeds
regular
wpm1
potential
problem
stratiﬁed
approach
worst
case
algorithm
could
use
calls
sat
solver
regular
wpm1
contribution
made
cost
sat
solver
returns
rue
time
wmax
authors
apply
diversity
heuristic
decreases
wmax
faster
big
variety
distinct
weights
assigns
wmax
next
value
low
diversity
among
weights
4.4
wpm2
2007
marques-silva
planes
discussed
important
properties
malik
mentioned
number
clauses
input
formula
proved
algorithm
performs
iterations
number
relaxation
variables
used
worst
case
marques-silva
planes
also
tried
improve
work
malik
malik
use
pairwise
encoding
constraints
relaxation
variables
use
quadratic
number
clauses
becomes
impractical
solving
real-world
instances
instead
marques-silva
planes
suggested
several
encodings
linear
number
variables
constraint
another
drawback
malik
several
blocking
variables
asso-
ciated
given
clause
due
fact
clause
participate
one
unsatisﬁable
core
time
part
computed
unsatisﬁable
core
new
blocking
variable
added
although
number
blocking
variables
per
clause
possibly
large
still
linear
one
variables
used
prevent
clause
participating
unsatisﬁable
core
simple
solution
re-
duce
search
space
associated
blocking
variables
require
one
cid:80
blocking
variables
belonging
given
clause
assigned
rue
clause
let
blocking
variables
associated
condition
j=1
assures
one
blocking
variables
assigned
rue
useful
executing
large
number
iterations
many
clauses
involved
signiﬁcant
number
unsatisﬁable
cores
resulting
algorithm
incorporated
improvements
called
msu2
ans´otegui
bonet
levy
also
developed
algorithm
wpmaxsat
2010
called
wpm2
every
soft
clause
extended
unique
fresh
blocking
variable
note
sat
solver
assign
rue
alse
every
iteration
algorithm
modiﬁes
two
sets
at-most
at-least
constraints
blocking
variables
called
respectively
algorithm
relies
notion
covers
deﬁnition
4.4
cover
given
set
cores
set
covers
covers
deﬁned
minimal
partition
every
covers
cid:54
algorithm
wpm2
wpm2
algorithm
wpmaxsat
input
wpmaxsat
instance
cm+1
cm+m
cid:48
output
optimal
wpmaxsat
solution
sat
alse
return
cm+1
cm+m
cid:48
covers
w1b1
wmbm
rue
state
sat
state
rue
return
return
remove
hard
clauses
foreach
cid:48
∈rc
cid:48
cid:83
cid:80
cid:80
covers
cid:54
ewbound
covers
covers
i∈b
wibi
i∈b
cid:48
wibi
cid:48
cid:48
cid:80
i∈b
wibi
solution
constraints
give
lower
bounds
optimal
cost
ones
ensure
solutions
set
solutions
minimal
cost
turn
ensures
solution
optimal
assignment
authors
use
following
deﬁnition
cores
introduced
new
notion
called
covers
show
computed
given
deﬁnition
4.5
core
core
set
indices
cid:32
cid:88
cid:33
wibi
function
core
cid:0
cid:80
i∈a
wibi
cid:1
returns
core
cores
returns
core
i∈a
deﬁnition
4.6
disjoint
cores
let
set
unsatisﬁable
cores
set
blocking
variables
core
disjoint
cid:54
given
set
constraints
set
at-most
constraints
cid:80
cover
cores
solution
minimizing
cid:80
i∈a
wibi
i∈a
wibi
subject
rue
alse
beginning
w1b1
wmbm
corresponding
w1b1
wmbm
ensures
solution
alse
alse
every
iteration
unsatisﬁable
core
identiﬁed
sat
solver
set
indices
soft
clauses
computed
also
called
core
next
set
covers
cid:48
covers
cid:48
cid:48
∈rc
cid:48
new
set
covers
covers
covers
set
at-least
constraints
enlarged
i∈b
wibi
ewbound
ewbound
wibi≥k
i∈a
cid:48
wibi
cid:48
cid:48
given
computation
ewbound
diﬃcult
since
reduced
subset
sum
problem
j=1
wjxj
equivalent
ewbound
weights
j=1
wjxj
authors
implementation
ewbound
cid:54
intersect
computed
well
union
cid:83
adding
new
constraint
cid:80
i∈a
wibi
subject
set
constraints
cid:80
correspond
minimize
cid:80
cid:80
cid:48
cid:80
following
way
given
minimize
cid:80
cid:80
j=1
wjxj
subject
cid:80
computed
algorithm
10.
algorithm
newbound
i∈b
cid:48
wibi
cid:48
cid:48
cid:9
cid:80
cid:8
cid:48
cid:80
sat
cid:0
cid:0
cid:80
repeat
subsetsum
i∈b
wibi
cid:1
cid:1
return
subsetsum
function
called
line
optimization
version
decision
subset
sum
problem
returns
largest
integer
subset
sums
example
4.2.
consider
example
2.1
weights
soft
clauses
set
main
loop
algorithm
x5∨b5
x6∨b6
¬x6∨b7
∪φh
covers
following
iterations
algorithm
executes
soft
clauses
core
denoted
sof
state
alse
sof
¬x6
covers
state
alse
sof
covers
state
alse
sof
covers
state
alse
sof
covers
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
sum
wpm2
algorithm
groups
identiﬁed
cores
covers
decomposition
cores
disjoint
sets
constraints
added
relaxation
variables
cover
relax
particular
weight
clauses
changed
next
largest
value
weights
clauses
sum
computing
next
expensive
since
relies
subset
sum
problem
np-hard
ans´otegui
invented
three
improvements
wpm2
first
applied
stratiﬁcation
technique
second
introduced
new
criteria
decide
soft
clauses
hardened
finally
showed
focusing
search
solving
optimality
subformulae
original
wpmaxsat
instance
eﬃciency
wpm2
increased
allows
combine
strength
exploiting
information
extracted
unsatisﬁable
cores
optimization
approaches
solving
smaller
optimization
problems
authors
obtained
signiﬁcant
boost
new
wpm2
version
4.5
wmsu1-ror
wmsu1-ror
modiﬁcation
wpm1
attempts
avoid
adding
blocking
variables
applying
maxsat
resolution
clauses
unsatisﬁable
core
given
unsatisﬁable
core
resolution
refutation
contradiction
obtained
performing
resolution
calculated
specialized
tool
much
refutation
possible
copied
applying
maxsat
resolution
steps
working
formula
transformation
derived
empty
clause
means
core
trivial
sequence
calls
sat
solver
continue
without
adding
relaxation
variables
step
otherwise
transformed
core
relaxed
wpm1
classical
resolution
rule
applied
maxsat
preserve
equivalence
among
weighted
formulae
maxsat
resolution
rule
used
wmsu1-ror
called
max-res
described
following
deﬁnition
extends
resolution
rule
sat
wmaxsat
deﬁnition
4.7
wpmaxsat
resolution
cid:127
cid:127
disjunctions
cid:127
deﬁned
weights
cid:62
cid:26
cid:54
cid:62
cid:62
cid:62
cid:127
min
clauses
¬x∨
called
clashing
clauses
called
resolvent
cid:127
cid:127
called
posterior
clashing
clauses
compensation
clauses
added
recover
equivalent
maxsat
formula
example
max-res
applied
x∨y
¬x∨y∨z
cid:62
obtain
cid:127
cid:127
ﬁrst
fourth
clauses
simpliﬁed
observing
a∨c∨¬b
second
ﬁfth
clauses
deleted
since
former
weight
zero
latter
tautology
morgan
laws
applied
maxsat
instance
preserving
equivalence
among
instances
following
rule
applied
instead
resolution
proof
ordered
set
cid:48
cid:46
cid:47
cid:48
cid:48
ci+1
cid:48
cid:46
cid:47
cid:48
cid:48
ci+k
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
resolution
step
resolution
proof
resolvent
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
clashing
clauses
set
compensation
clauses
denoted
cid:48
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
ror
approach
captured
lines
12-22
algorithm
11.
wmsu1-ror
handles
wpmaxsat
formulae
way
maintains
working
formula
lower
bound
resolution
proof
obtained
line
maxsat
resolution
applied
lines
14-21
read-once
step
detail
weights
clashing
clauses
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
decreased
minimum
weight
clauses
unsatisﬁable
core
lines
15-16
clashing
clauses
soft
deleted
lines
17-18
resolvent
cid:3
added
lines
21-22
hand
clashing
clauses
hard
kept
core
could
used
diﬀerent
resolution
step
lastly
compensation
clashing
clauses
added
lines
19-20
algorithm
wmsu1-ror
input
wpmaxsat
instance
cm+1
cm+m
cid:48
wm+m
cid:48
output
cost
optimal
solution
sat
alse
return
rue
state
sat
state
rue
return
min
cid:62
beginning
read-once
resolution
getp
roof
foreach
cid:48
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
ror
cid:48
cid:48
cid:48
cid:48
cid:127
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:127
cid:48
cid:62
cid:48
cid:48
cid:62
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
cid:54
cid:3
end
read-once
resolution
foreach
cid:62
let
new
relaxation
variable
cid:127
else
cid:0
cid:80
b∈b
cid:1
hard
algorithm
returns
rue
hard
clause
ancestors
hard
otherwise
returns
alse
input
called
line
returns
rue
resolvent
step
i.e.
original
clause
otherwise
returns
alse
ancestors
called
line
returns
pair
clauses
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
derived
dictated
algorithm
hard
determines
clause
hard
input
proof
output
rue
hard
alse
otherwise
input
cid:62
return
rue
input
cid:54
cid:62
return
alse
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
ancestors
return
hard
cid:48
cid:48
hard
cid:48
cid:48
cid:48
cid:48
function
ror
algorithm
returns
rue
hard
soft
ancestors
used
resolution
proof
cid:48
cid:48
cid:46
cid:47
cid:48
cid:48
cid:48
cid:48
last
resolvent
resolution
proof
entire
proof
read-once
ror
returns
rue
case
last
step
ror
resolvent
step
cid:3
situation
occurs
algorithm
need
augment
clauses
relaxation
variables
cardinality
constraints
improves
upon
original
algorithm
algorithm
ror
determines
clause
hard
ancestors
used
input
proof
output
rue
hard
ancestors
used
exactly
alse
otherwise
hard
return
rue
input
sed
return
rue
sed
return
alse
cid:48
cid:48
cid:48
cid:48
cid:48
cid:48
ancestors
return
ror
cid:48
cid:48
ror
cid:48
cid:48
cid:48
cid:48
problem
approach
applying
max-res
instead
adding
blocking
vari-
ables
cardinality
constraints
soft
clauses
weights
greater
zero
resolved
maxsat
resolution
ensure
produce
resolvents
weights
greater
zero
technique
work
authors
restrict
appli-
cation
resolution
case
clause
used
referred
read-once
resolution
ror
unfortunately
ror
generate
resolution
proofs
unsatisﬁable
clauses
4.6
wmsu3
wmsu3
wpmaxsat
algorithm
adds
single
blocking
variable
per
soft
clause
thus
limiting
number
variables
formula
sent
sat
solver
iteration
algorithm
wmsu3
wmsu3
algorithm
wpmaxsat
input
wpmaxsat
instance
output
cost
optimal
wpmaxsat
solution
sat
alse
return
rue
state
sat
cid:80
bi∈b
wibi
set
blocking
variables
working
formula
initialized
lower
bound
initialized
state
rue
return
foreach
cid:54
pdatebound
algorithm
begins
initializing
set
blocking
variables
augmented
later
line
working
formula
line
lower
bound
zero
line
msu3
loops
unsatisﬁable
working
formulae
loop
lines
6-13
ﬁnds
satisﬁable
one
line
iteration
unsatisﬁable
core
returned
sat
solver
algorithm
adds
one
blocking
variable
soft
clause
augmented
blocking
variable
yet
line
unlike
wpmaxsat
algorithms
discussed
previously
wpm1
algorithm
indeed
one
blocking
variable
added
clause
iteration
blocked
iteration
clause
function
pdatebound
line
updates
lower
bound
either
simply
incrementing
subset
sum
problem
following
example
illustrates
algorithm
works
example
4.3.
let
¬x1
¬x2
¬x2
¬x3
state
alse
¬x1
¬x2
¬x1
¬x2
¬x2
¬x3
constraint
3b2
included
satisfying
implies
must
falsiﬁed
thus
3b2
replaced
¬b2
state
alse
x2∨b2
¬x2∨¬x3
¬b2
∩φs
x1∨b1
x2∨
¬x1
¬x2
¬x2
¬x3
previous
iteration
satisfying
constraint
3b2
implies
must
falsiﬁed
constraint
+3b2
+b3
included
state
rue
assignment
alse
rue
alse
rue
alse
rue
indeed
satisﬁes
last
iteration
ignoring
values
blocking
variables
indeed
optimal
assignment
falsiﬁes
soft
clauses
satisﬁes
4.7
wmsu4
like
wmsu3
wmsu4
algorithm
adds
one
blocking
variable
soft
clause
thought
maintains
upper
bound
well
lower
bound
current
working
formula
satisﬁable
line
changed
sum
weights
falsiﬁed
clauses
solution
returned
sat
solver
hand
working
formula
unsatisﬁable
sat
solver
returns
unsatisﬁable
core
algorithm
adds
blocking
variable
clause
yet
relaxed
core
soft
clauses
unsatisﬁable
core
relaxed
line
algorithm
updates
lower
bound
line
exists
main
loop
following
example
illustrates
algorithm
works
algorithm
wmsu4
wmsu4
algorithm
wpmaxsat
input
wpmaxsat
instance
output
cost
optimal
wpmaxsat
solution
sat
alse
return
cid:80
|φs|
set
blocking
variables
working
formula
initialized
lower
bound
initialized
i=1
upper
bound
initialized
sum
weights
soft
clauses
plus
one
state
sat
cid:80
cid:80
bi∈b
state
rue
bi∈b
wibi
update
sum
weights
falsified
clauses
without
blocking
variables
else
foreach
cid:54
cid:48
cid:48
cid:48
else
cid:48
pdatebound
return
example
4.4.
let
¬x1∨¬x2
¬x1∨¬x3
¬x1∨¬x4
¬x2∨¬x3∨¬x4
ﬁrst
iteration
loop
state
alse
φc∩φs
x2∨b2
x3∨
constraint
included
state
rue
rue
alse
alse
alse
rue
rue
rue
constraint
included
state
alse
constraint
included
state
sat
alse
alse
rue
rue
rue
rue
alse
alse
cost
optimal
assignment
indeed
since
falsiﬁed
core-guided
binary
search
algorithms
core-guided
binary
search
algorithms
similar
binary
search
algorithms
described
ﬁrst
section
except
augment
soft
clauses
blocking
variables
beginning
main
loop
heras
morgado
marques-silva
proposed
technique
see
algorithm
algorithm
coreguided-bs
core-guided
binary
search
algorithm
solving
wpmaxsat
input
wpmaxsat
instance
output
cost
optimal
wpmaxsat
solution
state
sat
state
alse
return
cid:80
|φs|
i=1
cid:99
mid
cid:98
lb+u
state
sat
cid:80
cid:80
|φs|
i=1
state
rue
lasti
else
pdatebound
mid
else
foreach
let
new
blocking
variable
return
lasti
bi∈b
wibi
mid
similar
algorithms
coreguided-bs
begins
checking
satisﬁability
hard
clauses
lines
1-3
initializes
lower
bound
line
upper
bound
line
set
blocking
variables
line
respectively
one
plus
sum
weights
soft
clauses
iteration
main
loop
lines
7-21
sat
solver
called
working
formula
constraint
ensuring
sum
weights
relaxed
soft
clauses
less
equal
middle
value
line
formula
satisﬁable
line
upper
bound
updated
sum
falsiﬁed
soft
clauses
current
assignment
line
otherwise
soft
clauses
relaxed
line
lower
bound
updated
line
non-relaxed
sot
clauses
belonging
core
relaxed
lines
17-19
main
loop
continues
long
example
5.1.
consider
example
2.1
weights
soft
clauses
set
beginning
algorithm
satisﬁable
following
iterations
algorithm
executes
mid
cid:98
−1+8
cid:99
since
constraint
included
state
alse
¬x6
¬x6
mid
constraint
included
state
alse
x1∨b1
x2∨b2
x6∨
¬x6
mid
constraint
included
state
alse
¬x6
mid
constraint
included
state
alse
¬x6
x1∨b1
x2∨b2
x3∨b3
x4∨b4
x5∨
¬x6
mid
included
state
alse
¬x6
mid
constraint
b1+b2+b3+b4+b6+b7
included
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
values
variables
indeed
constitute
optimal
assignment
core-guided
binary
search
approach
improved
heras
disjoint
cores
see
deﬁnition
4.6
algorithm
disjointcoreguided-bs
core-guided
binary
search
extended
disjoint
cores
solving
wpmaxsat
input
wpmaxsat
instance
output
wpmaxsat
solution
sat
alse
return
repeat
foreach
midi
lbi
else
midi
cid:98
lbi+u
state
sat
cid:83
cid:99
state
rue
lasti
foreach
cid:80
br∈b
ci∈c
cid:80
bi∈b
wibi
midi
else
subc
intersectingcores
|subc|
mid
subc
mid
else
foreach
let
new
blocking
variable
cid:80
foreach
lbi
midi
subc
bi∈b
lbi
subc
∀ci∈cu
lbi
return
lasti
core-guided
binary
search
methods
disjoint
unsatisﬁable
cores
maintains
smaller
lower
upper
bounds
disjoint
core
instead
one
global
lower
bound
one
global
upper
bound
thus
algorithm
add
multiple
smaller
cardinality
constraints
sum
weights
soft
clauses
rather
one
global
constraint
maintain
smaller
constraints
algorithm
keep
information
pre-
vious
cores
set
called
initialized
line
main
loop
whenever
sat
solver
returns
alse
line
also
provides
new
core
new
entry
lbi
midi
added
set
blocking
variables
associated
soft
clauses
lbi
lower
bound
midi
current
middle
value
upper
bound
main
loop
terminates
lbi
line
entry
middle
value
calculated
lines
constraint
entry
added
working
formula
calling
sat
solver
line
working
formula
unsatisﬁable
line
using
intersectiongcores
every
core
intersects
current
core
identiﬁed
corre-
sponding
entry
added
subc
line
core
contain
soft
clauses
need
relaxed
|subc|
line
assigned
value
midpoint
line
hand
exists
clauses
relaxed
yet
algorithm
relaxes
lines
21-24
new
entry
current
core
added
accumulates
information
previous
cores
subc
lines
25-31
example
5.2.
consider
example
2.1
weights
soft
clauses
set
beginning
algorithm
following
iterations
algorithm
executes
constraints
include
state
alse
¬x6
subc
¬x6
constraint
+b7
included
state
alse
φc∩φs
subc
¬x6
constraints
+b7
+b2
included
state
alse
subc
x4∨b4
x6∨b6
¬x6∨b7
∪φh
constraints
included
state
alse
subc
x6∨b6
¬x6∨b7
∪φh
constraints
in-
cluded
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
constraints
included
state
alse
subc
state
rue
alse
alse
rue
alse
rue
alse
rue
rue
alse
rue
alse
rue
alse
sat-based
wpmaxsat
solvers
rely
heavily
hardness
sat
formulae
returned
underlying
sat
solver
used
obviously
location
optimum
solution
depends
structure
instances
returned
number
iterations
takes
switch
rue
alse
alse
rue
portfolio
maxsat
techniques
results
maxsat
evaluations
suggest
absolute
best
algorithm
solving
maxsat
eﬃcient
solver
often
depends
type
instance
words
diﬀerent
solution
approaches
work
well
diﬀerent
families
instances
oracle
able
predict
suitable
maxsat
solver
given
instance
would
result
robust
solver
success
satzilla
sat
due
regression
function
trained
predict
performance
every
solver
given
set
solvers
based
features
instance
faced
new
instance
solver
best
predicted
runtime
run
given
instance
resulting
sat
portfolios
excelled
sat
competitions
2007
2009
pushed
state-of-the-art
sat
solving
approach
extended
maxsat
resulting
portfolio
achieve
signiﬁcant
performance
improvements
representative
set
instances
isac
instance-speciﬁc
algorithm
conﬁguration
one
successful
wp-
maxsat
portfolio
algorithms
works
computing
representative
feature
vector
characterizes
given
input
instance
order
identify
clusters
similar
instances
data
therefore
clustered
non-overlapping
groups
single
solver
selected
group
based
performance
characteristic
given
new
instance
features
computed
assigned
nearest
cluster
instance
solved
solver
assigned
cluster
translating
pseudo-boolean
constraints
cnf
section
discusses
translating
pseudo-boolean
constraints
cnf
proce-
dure
needed
almost
every
sat-based
wpmaxsat
algorithm
eﬃciency
surely
aﬀects
overall
performance
solver
7.1
introduction
constraint
linear
constraint
boolean
variables
constraints
inten-
sively
used
expressing
np-hard
problems
dedicated
solvers
sat4j
solving
constraints
good
reasons
interested
transforming
constraints
sat
cnf
formulae
number
methods
reported
deﬁnition
7.1
constraint
constraint
inequality
equality
linear
combination
boolean
literals
cid:88
aili
called
bound
constant
integers
literals
i=1
least
two
clear
beneﬁts
solving
constraints
encoding
cnf
first
high-performance
sat
solvers
enhanced
continuously
since
take
standard
input
format
always
selection
good
solvers
make
use
second
solving
problems
involving
boolean
combinations
constraints
straightforward
approach
particularly
attractive
problems
naturally
represented
relatively
small
number
constraints
like
knapsack
problem
together
large
number
purely
boolean
constraints
7.2
encoding
method
consider
without
loss
generality
constraints
form
cid:80
paper
present
method
bailleux
boufkhad
roussel
i=1
aili
···
type
constraint
denoted
triple
cid:104
cid:105
bound
triple
cid:104
cid:105
represents
constraint
aili
a2l2
···
aili
tuples
ﬁxed
triple
cid:104
cid:105
representing
constraint
deﬁned
ambiguity
integer
bound
cid:104
cid:105
new
variable
introduced
new
variable
represents
satisfaction
constraint
cid:104
cid:105
i.e.
rue
cid:104
cid:105
satisﬁed
variable
represents
cid:104
cid:105
correctness
encoding
conditioned
fact
assignment
satisﬁes
cid:104
cid:105
satisﬁes
encoded
cnf
formula
ﬁxes
rue
variables
cid:80
j=1
called
terminal
variables
encoding
starts
set
variables
containing
original
variables
con-
straint
variable
variables
marked
step
unmarked
variable
considered
terminal
two
variables
di−1
di−1
b−ai
added
set
variables
already
following
four
clauses
added
¬di−1
b−ai
di−1
di−1
b−ai
di−1
case
terminal
variable
deﬁnition
either
cid:80
next
marked
considered
j=1
ﬁxed
follows
cid:40
alse
rue
clause
¬di
added
formula
j=1
clause
added
formula
cid:80
alse
every
variable
constraint
must
set
alse
achieve
every
clauses
di,0∨lj
added
together
clause
l1∨l2∨···∨di,0
procedure
stops
unmarked
variables
example
7.1.
example
illustrates
encoding
constraint
2x1+3x2+4x3
formula
¬d2,2
d3,6
¬d3,6
¬x3
d2,2
¬d2,6
d3,6
d2,6
¬d1
−1∨d2,2
¬d2,2∨d1,2
¬d2,2∨¬x2∨d1
¬d1,2∨x2∨d2,2
d1,2
¬d1
thus
d3,6
rue
least
one
alse
correctness
complexity
encoding
discussed
paper
7.3
complexity
encoding
complexity
encoding
measured
terms
number
variables
number
clauses
produced
related
constant
factor
number
variables
cases
previous
procedure
produces
polynomial
others
produce
exponential
number
variables
7.3.1
polynomial
cases
encoding
seems
generate
exponential
number
variables
step
non-
terminal
variable
creates
two
variables
turn
create
two
variables
however
true
terminal
variables
variables
already
considered
procedure
terminal
variable
met
said
cut
procedure
variable
already
set
variables
met
said
merged
procedure
cuts
merges
size
encodings
polynomial
cases
two
restrictions
constraint
polynomial-size
encoding
least
equal
cid:80
diﬀerent
values
take
cid:80
integers
bounded
polynomial
case
potential
number
variables
2n−i
merges
number
reduces
polynomial
since
variables
j=0
an−j
take
j=0
diﬀerent
values
bounded
since
diﬀerent
possible
values
total
number
variables
bounded
polynomial
figure
shows
example
case
terminal
variable
true
cid:80
cid:80
i−1
weights
case
every
non
terminal
variable
considered
procedure
least
one
variables
di−1
di−1
j=0
either
j=0
di−1
terminal
variable
case
di−1
b−αi
terminal
variable
thus
cut
time
variable
considered
procedure
figure
shows
example
case
figure
variables
introduced
encode
3x1
+3x2
+3x3
+3x4
figure
variables
introduced
encode
2x1
4x2
8x3
16x4
figure
totalizer
encoding
constraint
···
7.3.2
exponential
cases
2n+1
possible
sequences
give
tree
branches
length
possible
merge
nodes
implies
tree
size
idea
simply
combine
constant
sequence
geometric
sequence
let
length
constraint
let
bn+2
key
point
i=0
simplicity
choose
note
case
2n+2
bounded
polynomial
fix
geometric
term
must
negligible
compared
constant
term
cid:80
terminal
node
reached
get
term
cid:80
equal
cid:80
j=1
cid:80
sponds
cid:80
j=1
ajxj
cid:80
binary
representation
cid:80
j=1
constant
term
predominant
ﬁrst
condition
met
earliest
case
second
condition
satisﬁed
remains
j=1
therefore
means
earliest
case
second
condition
met
conclude
branch
least
length
addition
encoding
node
tree
holds
term
corre-
j∈s
1..n
one
key
point
j∈s
least
signiﬁcant
bits
directly
correspond
indices
therefore
least
signiﬁcant
bits
right
term
necessarily
diﬀerent
one
node
another
reason
node
merged
size
tree
least
since
branches
length
least
equal
encoding
particular
constraint
exponential
size
j=1
cid:80
7.4
encoding
techniques
incremental
approaches
allow
constraint
solver
retain
knowledge
previous
iterations
may
used
upcoming
iterations
goal
retain
inner
state
constraint
solver
well
learned
clauses
discovered
solving
process
previous
iterations
iteration
maxsat
algorithms
create
new
instance
constraint
solver
rebuild
formula
losing
knowledge
could
derived
previous
iterations
experimental
investigation
conducted
experimental
investigation
order
compare
performance
diﬀer-
ent
wpmaxsat
solvers
branch
bound
solvers
number
benchmarks
instances
experimental
evaluations
maxsat
solvers
gained
great
interest
among
sat
maxsat
researchers
due
fact
solvers
becoming
eﬃcient
adequate
handle
wpmaxsat
instances
coming
real-life
applications
thus
carrying
investigation
comparing
eﬃciency
diﬀerent
solvers
critical
knowing
solving
technique
suitable
category
inputs
fact
annual
event
called
maxsat
evaluations
scheduled
purpose
ﬁrst
maxsat
evaluation
held
2006.
objective
maxsat
evaluation
comparing
performance
state
art
weighted
partial
maxsat
solvers
number
benchmarks
declaring
winner
benchmark
category
solvers
investigate
participated
maxsat
evaluations
2013
2014.
number
solvers
available
online
contact
authors
get
copy
benchmarks
used
participated
2013
maxsat
evaluation
wpmaxsat
instances
three
categories
random
crafted
industrial
solvers
run
machine
intel
cid:114
coretm
cpu
clocked
2.4ghz
5.7gb
ram
running
elementary
linux
timeout
set
1000
seconds
running
solvers
benchmarks
took
roughly
three
months
picked
elemen-
taryos
consume
many
resources
run
thus
giving
enough
room
solvers
run
addition
elementaryos
compatible
popular
ubuntu
distribution
makes
compatible
repositories
packages
8.1
solvers
descriptions
solvers
experimented
wmifumax
unsatisﬁability-based
wpmaxsat
solver
based
tech-
nique
malik
algorithm
manquinho
marques-silva
planes
works
identifying
unsatisﬁable
sub-formulae
mifumax
placed
third
wpmaxsat
industrial
category
2013
maxsat
evaluation
solver
source
code
available
online
gnu
general
public
license
sat
solver
used
called
minisat
author
mikol´aˇs
janota
qwmaxsat
weighted
version
qmaxsat
developed
koshimura
zhang
fujita
hasegawa
available
freely
online
solver
satisﬁability-
based
solver
built
top
version
2.0
sat
solver
minisat
authors
qmaxsat
modiﬁed
top-level
part
minisat
manipulate
cardinal-
ity
constraints
parts
remain
unchanged
despite
originally
pmaxsat
solver
authors
developed
version
solver
wpmaxsat
2014.
authors
miyuki
koshimura
miyuki
koshimura
hiroshi
fujita
ryuzo
hasegawa
sat4j
satisﬁability-based
wpmaxsat
solver
developed
berre
par-
rain
solver
works
translating
wpmaxsat
instances
pseudo-boolean
optimization
ones
idea
add
blocking
variable
per
weighted
soft
clause
represents
clause
violated
translate
maximization
tion
min
cid:80
problem
weighted
soft
clauses
minimization
problem
linear
func-
tion
variables
given
wpmaxsat
instance
sat4j
translates
cid:48
plus
objective
func-
i=1
wibi
sat4j
avoids
adding
blocking
variables
hard
unit
clauses
sat4j
framework
includes
pseudo-boolean
solver
sat4j-pb-res
used
solve
encoded
wpmaxsat
problem
authors
daniel
berre
emmanuel
lonca
msuncore
unsatisﬁability-based
wpmaxsat
solver
built
top
sat
solver
picosat
solver
implements
number
algorithms
capable
solving
maxsat
pmaxsat
maxsat
msuncore
uses
picosat
iterative
identiﬁcation
unsatisﬁable
cores
larger
weights
although
ideally
minimal
core
would
preferred
unsatisﬁable
core
considered
clauses
identiﬁed
core
relaxed
adding
relaxation
variable
clause
cardinality
constraints
encoded
using
several
encodings
pairwise
bitwise
encodings
ladder
encoding
sequential
counters
sorting
networks
binary
decision
diagrams
bdds
authors
ant´onio
morgado
joao
marques-silva
federico
heras
maxsatz2013f
successful
branch
bound
solver
placed
ﬁrst
wpmaxsat
random
category
2013
maxsat
evaluation
based
earlier
solver
called
maxsatz
incorporates
technique
developed
famous
sat
solver
satz
node
transforms
instance
equivalent
one
applying
eﬃcient
reﬁnements
unit
resolution
yield
replaces
¬x∨¬y
cid:3
x∨y
¬x∨y
¬x∨
¬y∨¬z
cid:3
¬x∨y∨z
x∨¬y∨¬z
also
implements
lower
bound
method
enhanced
failed
literal
detection
increments
lower
bound
one
every
disjoint
inconsistent
subset
detected
unit
propagation
variable
selection
heuristics
takes
account
number
positive
negative
occurrences
binary
ternary
clauses
maxsatz2013f
available
freely
online
authors
chu
min
yanli
liu
felip
many
zhu
zhu
kun
wmaxsatz-2009
wmaxsatz+
branch
bound
solvers
use
transformation
rules
implemented
eﬃciently
by-product
unit
propagation
failed
literal
detection
means
transformation
rules
applied
node
search
tree
authors
josep
argelich
chu
min
jordi
planes
felip
many
isac+
instance-speciﬁc
algorithm
conﬁguration
portfolio
algorithm
given
wpmaxsat
instance
selects
solver
better
suited
in-
stance
regression
function
trained
predict
performance
every
solver
given
set
solvers
based
features
instance
faced
new
instance
solver
best
predicted
runtime
run
given
instance
isac+
uses
number
branch
bound
solvers
well
sat-based
including
qmaxsat
wmaxsatz-2009
wmaxsatz+
authors
carlos
ans´otegui
joel
gabas
yuri
malitsky
meinolf
sellmann
technique
satisﬁability-based
branch
bound
portfolio
summary
solver
name
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
sub-technique
sat-based
sat-based
sat-based
unsat-based
8.2
benchmarks
descriptions
benchmarks
used
wpmaxsat
instances
2013
maxsat
evaluation
divided
three
categories
random
category
consists
wpmax-2-sat
wpmax-3-sat
instances
generated
uniformly
random
wpmax-2-sat
instances
divided
for-
mulae
low
medium
high
numbers
variables
clauses
wpmax-3-sat
instances
contain
three
literals
per
clause
high
num-
ber
variables
clauses
crafted
instances
speciﬁcally
designed
give
hard
time
solver
award
smallest
instance
solved
solver
industrial
consists
instances
come
various
applications
practical
interest
model
checking
planning
encryption
bio-informatics
etc
encoded
maxsat
category
intended
provide
snapshot
current
strength
solvers
engines
sat-based
applications
maxsat
evaluations
ﬁrst
second
third
place
winners
declared
three
categories
8.3
results
section
results
obtained
presented
discussed
category
present
constituting
sets
instances
sizes
number
instances
solved
solver
amount
time
took
solver
work
set
instances
8.3.1
random
category
three
sets
instances
random
category
name
wpmax2sat-lo
wpmax2sat-me
wpmax2sat-hi
wpmax3sat-hi
abbreviation
instances
3hi
solver
mifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
3hi
table
number
instances
solved
random
category
solver
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
total
3hi
100
100
96.7
100
99.2
100
100
96.7
100
99.2
100
100
96.7
100
99.2
96.7
26.7
3.3
33.3
table
percentages
instances
solved
random
category
figure
time
results
random
category
branch
bound
solvers
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
per-
formed
considerably
better
sat-based
solvers
random
category
par-
ticular
maxsatz2013f
ﬁnished
four
benchmarks
minutes
wmifumax
msuncore
sat4j
timedout
instances
maxsatz2013f
placed
ﬁrst
ran-
dom
category
2013
maxsat
evaluation
see
http
//www.maxsat.udl.cat/13/results/
index.html
wpms-random-pc
top
non
branch
bound
solver
isac+
placed
third
random
category
2014
see
http
//www.maxsat.udl.cat/14/results/index.html
wpms-random-pc
8.3.2
crafted
category
seven
sets
instances
crafted
category
name
auctions/auc-paths
auctions/auc-scheduling
csg
min-enc/planning
min-enc/warehouses
pseudo/miplib
random-net
abbreviation
instances
auc/paths
auc/sch
csg
planning
warehouses
miplib
rnd-net
solver
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
auc/paths
auc/sch
csg
planning
warehouses
miplib
rnd-net
table
number
instances
solved
solver
rnd-net
total
30.1
38.7
49.7
45.6
76.3
10.8
1.4
1.4
74.3
solver
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
auc/paths
auc/sch
2.3
52.3
31.4
16.3
100
100
100
100
100
100
65.5
100
96.4
79.8
78.6
100
csg
100
100
planning
warehouses
miplib
41.1
100
100
94.6
73.2
80.4
80.4
94.6
11.1
5.6
33.3
33.3
33.3
100
8.3
33.3
33.3
33.3
16.7
table
percentages
instances
solved
crafted
category
figure
time
results
crafted
category
noticed
results
isac+
winner
crafted
cate-
indeed
winner
category
2014
maxsat
evaluation
isac+
gory
see
http
//www.maxsat.udl.cat/14/results/index.html
wpms-crafted
2013
evalua-
tion
placed
second
see
http
//www.maxsat.udl.cat/13/results/index.html
wpms-crafted-pc
generally
sat-based
branch
bound
solvers
perform
nearly
equally
crafted
instances
8.3.3
industrial
category
seven
sets
instance
industrial
category
name
wcsp/spot5/dir
wcsp/spot5/log
haplotyping-pedigrees
upgradeability-problem
preference
planning
packup-wpms
timetabling
abbreviation
instances
100
100
wcsp-dir
wcsp-log
pwpms
solver
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
wcsp-dir
wcsp-log
pwpms
100
100
100
table
number
instances
solved
industrial
category
solver
wmifumax
qwmaxsat
sat4j
msuncore
maxsatz2013f
wmaxsatz-2009
wmaxsatz+
isac+
wcsp-dir
wcsp-log
pwpms
28.6
66.7
14.3
66.7
28.6
61.9
14.3
66.7
14.3
14.3
33.3
100
15.2
38.7
100
34.5
6.9
6.9
100
12.4
100
total
43.3
30.8
34.5
30.8
21.7
34.6
53.8
table
percentages
instances
solved
industrial
category
figure
time
results
industrial
category
clear
sat-based
solvers
outperform
branch
bound
ones
industrial
instances
winner
solver
category
2013
maxsat
evaluation
isac+
see
http
//www.maxsat.udl.cat/13/results/index.html
wpms-industrial
solver
placed
second
2014
evaluation
see
http
//www.maxsat.udl.cat/14/results/index.html
wpms-industrial-pc
generally
notice
industrial
instances
sat-based
solvers
performed
considerably
better
branch
bound
solvers
performed
poorly
hand
branch
bound
solvers
outperformed
sat-based
ones
random
instances
acknowledgments
paper
made
possible
help
support
dr.
hassan
aly
depart-
ment
mathematics
cairo
university
egypt
dr.
rasha
shaheen
department
mathematics
cairo
university
egypt
would
also
like
thank
dr.
carlos
ans´otegui
university
lleida
spain
advice
include
section
translating
pseudo
boolean
constraints
encouraging
review
work
references
amir
aavani
translating
pseudo-boolean
constraints
cnf
theory
applica-
tions
satisﬁability
testing-sat
2011
pages
357–359
2011
amir
aavani
david
mitchell
eugenia
ternovska
new
encoding
translating
pseudo-boolean
constraints
sat
sara
2013
xuanye
miyuki
koshimura
hiroshi
fujita
ryuzo
hasegawa
qmaxsat
ver-
sion
0.3
0.4.
proceedings
international
workshop
first-order
theorem
proving
ftp
pages
7–15
2011
carlos
ans´otegui
mar´ıa
bonet
jordi
levy
solving
weighted
partial
maxsat
satisﬁability
testing
theory
applications
satisﬁability
testing-sat
2009
pages
427–440
2009
carlos
ans´otegui
maria
luisa
bonet
joel
gab
jordi
levy
improving
sat-
based
weighted
maxsat
solvers
principles
practice
constraint
programming
pages
86–101
springer
2012
carlos
ans´otegui
maria
luisa
bonet
joel
gab
jordi
levy
improving
wpm2
weighted
partial
maxsat
principles
practice
constraint
programming
pages
117–132
springer
2013
carlos
ans´otegui
maria
luisa
bonet
jordi
levy
new
algorithm
weighted
partial
maxsat
2010
carlos
ans´otegui
maria
luisa
bonet
jordi
levy
sat-based
maxsat
algorithms
artiﬁcial
intelligence
196:77–105
2013
carlos
ans´otegui
yuri
malitsky
meinolf
sellmann
maxsat
improved
instance-speciﬁc
algorithm
conﬁguration
2014
josep
argelich
chu
min
felip
manya
jordi
planes
ﬁrst
second
max-sat
evaluations
jsat
2-4
:251–278
2008
roberto
as´ın
ach´a
robert
nieuwenhuis
curriculum-based
course
timetabling
sat
maxsat
annals
operations
research
pages
1–21
2012
olivier
bailleux
yacine
boufkhad
eﬃcient
cnf
encoding
boolean
cardinality
constraints
principles
practice
constraint
programming–cp
2003
pages
108–122
springer
2003
olivier
bailleux
yacine
boufkhad
olivier
roussel
translation
pseudo-
boolean
constraints
sat
journal
satisﬁability
boolean
modeling
compu-
tation
2:191–200
2006
armin
biere
picosat
essentials
jsat
2-4
:75–97
2008
jessica
davies
fahiem
bacchus
postponing
optimization
speed
maxsat
solv-
ing
principles
practice
constraint
programming
pages
247–262
springer
2013
niklas
een
niklas
s¨orensson
minisat
sat
solver
conﬂict-clause
mini-
mization
sat
2005
niklas
e´en
niklas
s¨orensson
translating
pseudo-boolean
constraints
sat
jsat
1-4
:1–26
2006
zhaohui
sharad
malik
solving
partial
max-sat
problem
theory
applications
satisﬁability
testing-sat
2006
pages
252–265
2006
ian
gent
arc
consistency
sat
ecai
volume
pages
121–125
2002
ian
gent
peter
nightingale
new
encoding
alldiﬀerent
sat
proc
3rd
international
workshop
modelling
reformulating
constraint
satisfaction
problems
pages
95–110
2004
federico
heras
joao
marques-silva
read-once
resolution
unsatisﬁability-
based
max-sat
algorithms
proceedings
twenty-second
international
joint
conference
artiﬁcial
intelligence-volume
volume
one
pages
572–577
aaai
press
2011
federico
heras
antonio
morgado
joao
marques-silva
core-guided
binary
search
algorithms
maximum
satisﬁability
proceedings
aaai
national
confer-
ence
aaai
2011
kazuo
iwama
eiji
miyano
intractability
read-once
resolution
structure
complexity
theory
conference
1995.
proceedings
tenth
annual
ieee
pages
29–36
ieee
1995
mikol´aˇs
janota
inˆes
lynce
vasco
manquinho
joao
marques-silva
packup
tools
package
upgradability
solving
system
description
journal
satisﬁability
boolean
modeling
computation
8:89–94
2012
miyuki
koshimura
tong
zhang
hiroshi
fujita
ryuzo
hasegawa
qmaxsat
partial
max-sat
solver
system
description
journal
satisﬁability
boolean
modeling
computation
8:95–100
2012
javier
larrosa
federico
heras
simon
givry
logical
approach
eﬃcient
max-sat
solving
artiﬁcial
intelligence
172
:204–233
2008
daniel
berre
anne
parrain
sat4j
library
release
2.2
system
description
journal
satisﬁability
boolean
modeling
computation
7:59–64
2010
chu
felip
many
nouredine
mohamedou
jordi
planes
exploiting
cycle
structures
max-sat
theory
applications
satisﬁability
testing-sat
2009
pages
467–480
2009
chu
min
anbulagan
anbulagan
heuristics
based
unit
propagation
satisﬁability
problems
proceedings
15th
international
joint
conference
artiﬁcal
intelligence-volume
pages
366–371
morgan
kaufmann
publishers
inc.
1997
chu
min
felip
many
nouredine
ould
mohamedou
jordi
planes
resolution-
based
lower
bounds
maxsat
constraints
:456–484
2010
chu
min
felip
many
jordi
planes
new
inference
rules
max-sat
journal
artiﬁcial
intelligence
research
:321–359
2007
vasco
manquinho
joao
marques-silva
jordi
planes
algorithms
weighted
boolean
optimization
theory
applications
satisﬁability
testing-sat
2009
pages
495–508
2009
norbert
manthey
tobias
philipp
peter
steinke
compact
translation
pseudo-boolean
constraints
cnf
generalized
arc
consistency
main-
tained
2014
advances
artiﬁcial
intelligence
pages
123–134
springer
2014
filip
maric
timetabling
based
sat
encoding
case
study
2008
joao
marques-silva
msuncore
maxsat
solver
sat
2009
competitive
events
booklet
preliminary
version
page
151
2009
joao
marques-silva
inˆes
lynce
towards
robust
cnf
encodings
cardinality
constraints
principles
practice
constraint
programming–cp
2007
pages
483–
497
2007
joao
marques-silva
jordi
planes
using
unsatisﬁability
solving
maximum
satisﬁability
arxiv
preprint
arxiv:0712.1097
2007
joao
marques-silva
jordi
planes
algorithms
maximum
satisﬁability
using
unsatisﬁable
cores
proceedings
conference
design
automation
test
europe
pages
408–413
acm
2008
ruben
martins
saurabh
joshi
vasco
manquinho
inˆes
lynce
incremental
cardi-
nality
constraints
maxsat
principles
practice
constraint
programming
pages
531–548
springer
2014
paulo
matos
jordi
planes
florian
letombe
joao
marques-silva
max-sat
algorithm
portfolio1
2008
elizabeth
montero
mar´ıa-cristina
riﬀ
leopoldo
altamirano
pso
algorithm
solve
real
course+
exam
timetabling
problem
international
conference
swarm
intelligence
pages
24–1
2001
antonio
morgado
carmine
dodaro
joao
marques-silva
core-guided
maxsat
soft
cardinality
constraints
principles
practice
constraint
program-
ming
pages
564–573
springer
2014
antonio
morgado
federico
heras
mark
liﬃton
jordi
planes
joao
marques-
iterative
core-guided
maxsat
solving
survey
assessment
con-
silva
straints
:478–534
2013
matthew
moskewicz
conor
madigan
ying
zhao
lintao
zhang
sharad
malik
chaﬀ
engineering
eﬃcient
sat
solver
proceedings
38th
annual
design
automation
conference
pages
530–535
acm
2001
fahima
nader
mouloud
koudil
karima
benatchba
lotﬁ
admane
said
gharout
nacer
hamani
application
satisﬁability
algorithms
time-
table
problems
rapport
interne
lmcs
ini
2004
g-j
nam
fadi
aloul
karem
sakallah
rob
rutenbar
comparative
study
two
boolean
formulations
fpga
detailed
routing
constraints
computers
ieee
transactions
:688–696
2004
nina
narodytska
fahiem
bacchus
maximum
satisﬁability
using
core-guided
maxsat
resolution
aaai
pages
2717–2723
2014
steven
prestwich
variable
dependency
local
search
prevention
better
cure
theory
applications
satisﬁability
testing–sat
2007
pages
107–120
springer
2007
steven
david
prestwich
cnf
encodings
handbook
satisﬁability
185:75–97
2009
wayne
pullan
protein
structure
alignment
using
maximum
cliques
local
search
2007
advances
artiﬁcial
intelligence
pages
776–780
springer
2007
sean
safarpour
hratch
mangassarian
andreas
veneris
mark
liﬃton
karem
sakallah
improved
design
debugging
using
maximum
satisﬁability
formal
methods
computer
aided
design
2007.
fmcad
pages
13–19
ieee
2007
tian
sang
paul
beame
henry
kautz
dynamic
approach
mpe
weighted
max-sat
proceedings
20th
international
joint
conference
artiﬁcal
intel-
ligence
pages
173–179
morgan
kaufmann
publishers
inc.
2007
carsten
sinz
towards
optimal
cnf
encoding
boolean
cardinality
constraints
principles
practice
constraint
programming-cp
2005
pages
827–831
2005
niklas
sorensson
niklas
een
minisat
13-a
sat
solver
conﬂict-clause
minimization
sat
2005:53
2005
peter
steinke
norbert
manthey
pbliba
c++
toolkit
encoding
pseudo–boolean
constraints
cnf
dresden
dresden
germany
technical
report
1:2014
2014
michel
vasquez
jin-kao
hao
logic-constrained
knapsack
formulation
tabu
algorithm
daily
photograph
scheduling
earth
observation
satellite
computational
optimization
applications
:137–157
2001
joost
warners
linear-time
transformation
linear
inequalities
conjunctive
normal
form
information
processing
letters
:63–69
1998
hui
rob
rutenbar
karem
sakallah
sub-sat
formulation
relaxed
boolean
satisﬁability
applications
routing
computer-aided
design
inte-
grated
circuits
systems
ieee
transactions
:814–820
2003
lin
frank
hutter
holger
hoos
kevin
leyton-brown
satzilla
portfolio-
based
algorithm
selection
sat
journal
artiﬁcial
intelligence
research
pages
565–606
2008
