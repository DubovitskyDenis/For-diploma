extending
consequence-based
reasoning
sriq
andrew
bate
boris
motik
bernardo
cuenca
grau
frantiˇsek
simanˇc´ık
ian
horrocks
department
computer
science
university
oxford
oxford
united
kingdom
ﬁrstname.lastname
cs.ox.ac.uk
abstract
consequence-based
calculi
family
reasoning
algo-
rithms
description
logics
dls
combine
hyper-
tableau
resolution
way
often
achieves
excellent
performance
practice
however
pro-
posed
either
horn
dls
support
disjunc-
tion
dls
without
counting
quantiﬁers
paper
present
novel
consequence-based
calculus
sriq—
rich
supports
features
extension
non-
trivial
since
intermediate
consequences
need
derived
reasoning
captured
using
dls
them-
selves
results
preliminary
performance
evaluation
suggest
feasibility
approach
practice
introduction
description
logics
dls
baader
2003
family
knowledge
representation
formalisms
numerous
appli-
cations
practice
dl-based
applications
model
domain
interest
means
ontology
key
notions
domain
described
using
concepts
i.e.
unary
predi-
cates
relationships
concepts
described
using
roles
i.e.
binary
predicates
subsumption
prob-
lem
determining
whether
instance
concept
also
instance
concept
models
ontology
fundamental
reasoning
problem
applications
dls
expressive
dls
problem
high
worst-case
complexity
ranging
exptime
n2exptime
despite
discouraging
complexity
bounds
highly
op-
timised
reasoners
fact++
tsarkov
horrocks
2006
pellet
sirin
2007
hermit
glimm
2014
konclude
steigmiller
liebig
glimm
2014
proved
successful
practice
systems
typically
based
hyper
tableau
calculi
construct
ﬁnite
rep-
resentation
canonical
model
ontology
disproving
postulated
subsumption
calculi
handle
many
ontologies
cases
construct
large
model
representations
source
performance
problems
exacerbated
large
number
subsumption
tests
often
required
classify
ontology
recent
breakthrough
reasoning
came
form
consequence-based
calculi
reasoning
algorithm
baader
brandt
lutz
2005
lightweight
logic
seen
ﬁrst
calculus
later
extended
expressive
dls
horn-shiq
kazakov
2009
horn-sroiq
ortiz
rudolph
simkus
2010
—dls
support
counting
quantiﬁers
disjunctions
be-
tween
concepts
consequence-based
calculi
also
devel-
oped
alch
simanˇc´ık
kazakov
horrocks
2011
alci
simanˇc´ık
motik
horrocks
2014
support
concept
disjunction
counting
quantiﬁers
calculi
seen
combining
resolution
hy-
pertableau
see
section
details
resolution
describe
ontology
models
systematically
deriving
rele-
vant
consequences
hyper
tableau
goal-
directed
avoid
drawing
unnecessary
consequences
ad-
ditionally
refutationally
complete
also
dis
prove
relevant
subsumptions
single
run
greatly
reduce
overall
computational
work
finally
unlike
implemented
hyper
tableau
reason-
ers
worst-case
optimal
logic
support
steigmiller
glimm
liebig
2014
presented
way
combining
consequence-based
calculus
traditional
tableau-based
prover
combination
seems
perform
well
practice
saturation
rules
known
complete
ontologies
overall
approach
worst-case
optimal
sriq
existing
consequence-based
algorithms
handle
dls
alchiq
provide
disjunctions
counting
quantiﬁers
argue
section
extending
algorithms
handle
dls
challenging
count-
ing
quantiﬁers
require
equality
reasoning
together
disjunctions
impose
complex
constraints
ontol-
ogy
models
unlike
existing
consequence-based
calculi
constraints
captured
using
dls
makes
reasoning
process
much
involved
section
present
consequence-based
calculus
alchiq
using
encoding
role
chains
kazakov
2008
calculus
also
handle
sriq
covers
owl
except
nominals
reﬂexive
roles
datatypes
borrowing
ideas
resolution
theorem
prov-
ing
encode
calculus
consequences
ﬁrst-order
clauses
speciﬁc
form
handle
equality
using
variant
ordered
paramodulation
nieuwenhuis
ru-
bio
1995
state
art
calculus
equational
theorem
proving
used
modern
theorem
provers
schulz
2002
vampire
riazanov
voronkov
2002
further-
carefully
constrained
inference
rules
calculus
mimics
existing
calculi
elh
ontolo-
gies
ensures
robust
performance
calculus
mostly-elh
ontologies
implemented
prototype
system
compared
performance
well-established
reasoners
results
section
suggest
system
signiﬁcantly
outperform
fact++
pellet
hermit
often
exhibits
comparable
performance
konclude
preliminaries
first-order
logic
usual
equational
theorem
prov-
ing
encode
atomic
formulas
terms
use
multi-
sorted
signature
prevents
considering
mal-
formed
terms
thus
partition
signature
set
predicate
symbols
set
function
symbols
more-
assume
special
constant
term
constructed
usual
using
variables
signature
sym-
bols
restriction
predicate
symbols
allowed
occur
outermost
level
latter
terms
called
p-terms
terms
f-terms
exam-
ple
predicate
function
symbol
malformed
well-formed
term
well-formed
f-terms
term
f-successor
f-predecessor
equality
formula
form
either
p-terms
equality
form
cid:126
called
atom
written
cid:126
when-
ever
clear
context
expression
denotes
formula
p-term
inequality
negation
equality
written
cid:54
assume
cid:54
implicitly
symmetric—that
cid:46
cid:47
cid:46
cid:47
identical
cid:46
cid:47
cid:54
literal
equality
inequality
clause
formula
form
cid:126
conjunction
atoms
called
body
disjunction
literals
called
head
cid:126
contains
variables
oc-
curring
clause
quantiﬁer
cid:126
usually
omitted
understood
implicitly
often
treat
conjunctions
dis-
junctions
sets
i.e.
unordered
without
repe-
tition
use
standard
set
operations
write
empty
conjunction
disjunction
cid:62
term
literal
clause
set
thereof
say
ground
contain
variable
result
applying
substitution
often
write
substitutions
cid:55
cid:55
use
standard
notion
subterm
positions
s|p
subterm
position
po-
sition
proper
term
t|p
cid:54
term
obtained
replacing
subterm
position
herbrand
equality
interpretation
set
ground
equalities
satisfying
usual
congruence
properties
satis-
faction
ground
conjunction
ground
disjunction
necessarily
ground
clause
interpretation
writ-
ten
well
entailment
clause
set
clauses
written
deﬁned
usual
note
ground
disjunction
literals
may
contain
in-
equalities
necessarily
imply
cid:54
unless
otherwise
stated
possibly
indexed
letters
denote
variables
denote
terms
denotes
atom
p-term
depending
context
denotes
literal
denote
function
symbols
denotes
unary
predicate
symbol
denotes
binary
predicate
symbol
orders
strict
order
cid:31
universe
irreﬂex-
ive
asymmetric
transitive
relation
cid:23
non-strict
order
induced
cid:31
order
cid:31
total
cid:31
cid:31
given
cid:31
cid:23
element
subset
no-
tation
abbreviates
multiset
ex-
tension
cid:31
mul
cid:31
compares
multisets
cid:31
mul
cid:54
exists
cid:31
multiset
difference
operator
term
order
cid:31
strict
order
set
terms
extend
cid:31
literals
identifying
cid:54
multiset
multiset
comparing
result
using
multiset
extension
cid:31
reuse
symbol
cid:31
induced
literal
order
since
intended
meaning
clear
context
dl-clauses
calculus
takes
input
set
dl-
clauses—that
clauses
restricted
following
form
let
countable
sets
unary
binary
predicate
symbols
let
countable
set
unary
function
sym-
bols
dl-clauses
written
using
central
variable
variables
dl-f-term
form
dl-p-term
form
dl-term
dl-f-term
dl-p-term
dl-atom
form
dl-p-term
dl-literal
dl-atom
form
cid:46
cid:47
cid:46
cid:47
cid:46
cid:47
cid:46
cid:47
cid:54
dl-clause
contains
dl-atoms
form
body
dl-literals
head
variable
occurring
head
also
occurs
body
ontology
ﬁnite
set
dl-clauses
query
clause
dl-clause
literals
form
given
ontology
query
clause
calculus
decides
whether
holds
sriq
ontologies
written
using
dl-style
syntax
transformed
dl-clauses
without
affecting
query
clause
entailment
first
normalise
axioms
form
shown
left-hand
side
table
transform
away
role
chains
replace
complex
concepts
fresh
atomic
ones
process
well
understood
kaza-
kov
2009
2008
simanˇc´ık
motik
horrocks
2014
omit
details
second
using
well-known
corre-
spondence
dls
ﬁrst-order
logic
baader
2003
translate
normalised
axioms
dl-clauses
shown
right-hand
side
table
standard
trans-
lation
cid:118
cid:54
s.b2
requires
atoms
clause
bodies
allowed
setting
address
issue
introducing
fresh
role
sb2
axiomatise
sb2
turn
allows
clausify
original
axiom
cid:118
cid:54
sb2
elh
ontology
contains
dl-clauses
type
dl1
dl2
dl3
dl5
motivation
motivation
work
section
3.1
discuss
drawbacks
existing
reasoning
calculi
sec-
tion
3.2
discuss
existing
consequence-based
calculi
cid:100
1≤i≤n
cid:118
n+1≤i≤m
table
translating
normalised
alchiq
ontologies
dl-clauses
cid:87
cid:70
cid:86
cid:32
cid:118
cid:62
s.b2
∃s.b1
cid:118
cid:118
cid:54
s.b2
cid:118
cid:118
cid:32
cid:32
cid:32
cid:32
cid:32
1≤i≤n
n+1≤i≤m
cid:54
cid:86
cid:87
sb2
sb2
1≤i
j≤n+1
1≤i≤n+1
fresh
sb2
dl1
dl2
dl3
dl4
dl5
dl6
fi+1
cid:118
∃sj.bi+1
cid:32
bi+1
fi+1
cid:118
cid:32
cid:32
ci+1
∃sj.ci+1
cid:118
ontology
vb0
succ
6+7
f1,1
succ
6+7
f1,2
vb1
cid:27
···
vbn
initialisation
cid:62
hyper
1+5
cid:62
hyper
2+5
cid:62
pred
cid:62
cid:62
succ
6+7
cid:62
succ
6+7
cid:62
hyper
1+11
cid:62
hyper
2+11
cid:62
pred
hyper
4+10+18
cid:62
succ
succ
hyper
3+15
hyper
4+14+16
cid:62
cn−1
cid:62
cid:62
cid:62
figure
example
motivating
consequence-based
calculi
address
problems
separating
clauses
contexts
way
considerably
reduces
number
inferences
next
section
3.3
discuss
main
contribution
paper
lies
extending
consequence-based
framework
disjunctions
number
restric-
tions
handling
latter
requires
equality
reasoning
requires
involved
calculus
completeness
proof
3.1
consequence-based
calculi
consider
ontology
figure
one
read-
ily
check
holds
prove
using
hyper
tableau
calcu-
lus
start
apply
forward-
chaining
manner
since
contains
constructs
tree-shaped
model
depth
fanout
two
nodes
depth
labelled
forward
chaining
ensures
reasoning
goal-oriented
however
nodes
labelled
type
share
properties
reveals
weak-
ness
hyper
tableau
calculi
constructed
models
large
exponential
example
highly
redundant
apart
causing
problems
practice
often
prevents
hyper
tableau
calculi
worst-case
optimal
tech-
niques
caching
gor´e
nguyen
2007
any-
blocking
motik
shearer
horrocks
2009
constrain
model
construction
effectiveness
often
depends
order
rule
applications
thus
model
size
key
limiting
factor
hyper
tableau-based
reasoners
motik
shearer
horrocks
2009
contrast
resolution
describes
models
using
univer-
sally
quantiﬁed
clauses
summarise
model
eliminates
redundancy
ensures
worst-case
optimality
many
resolution
decision
procedures
many
resolution
vari-
ants
proposed
bachmair
ganzinger
2001
restricting
inferences
speciﬁc
way
however
ensure
termination
decision
procedure
dls
aware
perform
inferences
deepest
cov-
ering
clause
atoms
resolve
obtain
2n2
clauses
form
ck+1
fi+1
2n2
clauses
relevant
proving
goal
extend
additional
clauses
contain
2n2
clauses
participate
inferences
give
rise
irrelevant
clauses
problem
particularly
pronounced
satisﬁ-
able
since
must
produce
consequences
3.2
basic
notions
consequence-based
calculi
combine
summarisation
res-
olution
goal-directed
search
hyper
tableau
calculi
simanˇc´ık
motik
horrocks
2014
presented
frame-
work
alci
capturing
key
elements
related
calculi
baader
brandt
lutz
2005
kazakov
2009
ortiz
rudolph
simkus
2010
simanˇc´ık
kazakov
horrocks
2011
extending
framework
alchiq
section
next
informally
recapitulate
basic
notions
however
make
paper
easier
follow
use
notation
terminology
section
consequence-based
calculus
constructs
directed
graph
cid:104
core
cid:31
cid:105
called
context
structure
vertices
called
contexts
let
herbrand
model
hence
domain
contains
ground
terms
instead
representing
ground
term
separately
hy-
per
tableau
calculi
represent
properties
sev-
eral
terms
single
context
context
as-
sociated
possibly
empty
conjunction
corev
core
atoms
must
hold
ground
terms
represents
thus
corev
determines
kind
context
moreover
associated
set
clauses
capture
con-
straints
terms
must
satisfy
partitioning
clauses
sets
allows
restrict
inferences
clause
sets
thus
eliminate
certain
irrelevant
inferences
clauses
relative
corev
corev
∆—that
include
corev
clause
bodies
since
corev
holds
implicitly
function
cid:31
pro-
vides
context
concept
order
cid:31
re-
stricts
resolution
inferences
presence
disjunctions
contexts
connected
directed
edges
labelled
function
symbols
connected
via
f-labelled
edge
f-successor
ground
term
represented
represented
conversely
con-
nected
f-edge
ground
term
represented
f-successor
ground
term
represented
inference
ever
needed
consequence-based
calculi
complete
refu-
tation
derive
required
consequences
figure
demonstrates
cores
clauses
shown
respectively
con-
text
clause
numbers
correspond
derivation
or-
der
prove
introduce
context
vb0
core
add
clause
latter
says
holds
analogous
initialising
hy-
per
tableau
calculus
calculus
applies
rules
table
derive
new
clauses
and/or
extend
hyper
standard
hyperresolution
rule
restricted
single
context
time
thus
derive
hyperresolution
resolves
body
atoms
makes
resolvent
relevant
context
prevents
derivation
irrelevant
clauses
context
vb0
contains
atoms
function
symbols
f1,1
f1,2
succ
rule
must
ensure
f1,1-
f1,2-successors
ground
terms
represented
vb0
adequately
represented
control
context
in-
troduction
via
parameter
called
expansion
strategy—a
function
determines
whether
reuse
existing
con-
cid:108
cid:118
cid:71
text
introduce
fresh
one
latter
case
also
deter-
mines
initialise
context
core
discuss
possi-
ble
strategies
section
4.1
rest
example
use
so-called
cautious
strategy
succ
rule
in-
troduces
context
vb1
initialises
note
represents
two
clauses
sat-
isfy
separate
applications
succ
rule
using
vb1
construct
contexts
vb2
vbn
analogously
derive
hyperresolving
de-
rive
hyperresolving
clause
imposes
constraint
predecessor
context
propagate
using
pred
rule
deriving
since
clauses
vb0
relative
core
vb0
clause
represents
query
clause
required
3.3
extending
framework
alchiq
consequence-based
calculi
presented
thus
far
con-
straints
ground
terms
represented
context
must
satisfy
represented
using
standard
dl-style
ax-
ioms
example
alci
simanˇc´ık
motik
hor-
rocks
2014
represented
relevant
consequences
using
axioms
following
form
cid:116
cid:71
∃sk.bk
cid:116
cid:71
cid:96
cid:96
alchiq
provides
counting
quantiﬁers
dis-
junctions
interplay
may
impose
constraints
represented
alchiq
let
figure
see
holds
construct
herbrand
interpretation
derive
derive
due
de-
rive
finally
derive
following
clause
disjunct
satisﬁed
due
regardless
whether
choose
satisfy
derive
calculus
must
able
capture
constraint
consequences
standard
axioms
explic-
itly
refer
speciﬁc
successors
predecessors
instead
capture
consequences
using
context
clauses—clauses
terms
variable
represents
ground
terms
context
stands
represents
fi-
successors
represents
predecessor
thus
identify
predecessor
successors
name
allowing
capture
constraint
based
idea
adapted
rules
simanˇc´ık
motik
horrocks
2014
handle
context
clauses
correctly
added
rules
capture
consequences
equality
resulting
set
rules
shown
table
figure
shows
verify
us-
ing
calculus
maximal
literal
clause
shown
right
next
discuss
inferences
detail
ontology
cid:118
∃s−.b1
cid:32
cid:118
∃s.bi
cid:32
cid:118
cid:32
cid:117
cid:118
cid:32
cid:118
≤2.s
cid:32
cid:86
1≤i≤3
cid:87
1≤j
k≤3
cid:41
succ
30+31
succ
35+36+40
initialisation
cid:62
hyper
22+29
cid:62
hyper
23+29
cid:62
cid:62
pred
hyper
27+52
cid:62
hyper
27+53
cid:62
succ
37+38
cid:62
succ
35+36+40
cid:62
succ
35+36+40
succ
35+36+40
hyper
24+43+44
succ
37+38
cid:62
succ
37+38
cid:62
succ
30+31
succ
30+31
hyper
25+34
hyper
26+34
hyper
25+34
hyper
26+34
hyper
28+33+34+35+37
cid:62
38+39
pred
40+45
38+49
36+50
cid:62
cid:62
cid:62
cid:62
cid:62
cid:62
cid:62
cid:62
cid:62
cid:62
figure
challenges
extending
consequence-based
framework
alchiq
ﬁrst
create
context
initialise
ensures
interpretation
represented
con-
text
structure
contains
ground
term
holds
next
derive
using
hyperresolution
point
could
hyperresolve
obtain
cid:62
however
could
easily
lead
nontermination
calculus
due
increased
term
nest-
ing
therefore
require
hyperresolution
map
variable
dl-clauses
variable
context
clauses
thus
hyperresolution
derives
context
consequences
prevents
redundant
derivations
succ
rule
next
handles
function
symbol
clauses
determine
information
propa-
gate
successor
deﬁnition
section
introduces
set
successor
triggers
example
dl-clause
contains
atoms
body
mapped
predecessor
successor
thus
context
hyperresolution
applied
interested
information
predecessors
reﬂect
adding
exam-
ple
use
so-called
eager
strategy
see
section
4.1
succ
rule
introduces
context
sets
core
initialises
context
next
introduce
using
hyperresolution
point
sufﬁcient
information
apply
hyper-
resolution
derive
please
note
pres-
ence
crucial
inference
use
paramodulation
deal
equality
clause
common
resolution-based
theorem
proving
order
literals
clause
apply
inferences
maximal
literals
thus
derive
clauses
contain
function
symbol
succ
rule
introduces
context
due
clause
holds
ground
terms
represents
thus
add
corev2
contrast
atom
occurs
clause
disjunction
means
may
hold
hence
add
body
clause
latter
clause
allows
derive
using
hyperresolution
clause
essentially
says
hold
predecessor
pred
rule
propagates
clause
one
understand
inference
hyperres-
olution
observing
term
context
represented
variable
context
two
paramodulation
steps
derive
clause
essentially
says
predecessor
must
satisfy
set
predecessor
triggers
def-
inition
identiﬁes
relevant
dl-clauses
contain
bodies
rep-
resented
hence
contains
allowing
pred
rule
derive
two
steps
ﬁnally
derive
target
clause
could
maximal
thus
require
atoms
head
goal
clause
smallest
similar
observation
applies
maximal
would
derive
propa-
gate
thus
atoms
must
smallest
formalising
algorithm
section
ﬁrst
present
consequence-based
algo-
rithm
alchiq
formally
present
out-
line
completeness
proof
full
proofs
given
appendix
4.1
deﬁnitions
calculus
manipulates
context
clauses
con-
structed
context
terms
context
literals
described
deﬁnition
unlike
general
resolution
restrict
con-
text
clauses
contain
variables
special
meaning
setting
variable
represents
ground
term
herbrand
model
represents
pre-
decessor
naming
convention
important
rules
calculus
contrast
dl-clauses
ontology
contain
variables
refer
either
predecessor
successor
deﬁnition
context
f-term
term
form
context
p-term
term
form
context
term
f-term
p-term
context
literal
literal
form
called
context
atom
cid:46
cid:47
cid:46
cid:47
cid:46
cid:47
context
p-term
cid:46
cid:47
cid:54
context
clause
clause
function-free
context
atoms
body
context
literals
head
deﬁnition
introduces
sets
iden-
tify
information
must
exchanged
adja-
cent
contexts
intuitively
contains
atoms
interest
context
successor
guides
succ
rule
whereas
contains
atoms
interest
con-
text
predecessor
guides
pred
rule
deﬁnition
set
successor
triggers
on-
tology
smallest
set
atoms
clause
implies
implies
implies
set
predecessor
triggers
deﬁned
cid:55
cid:55
occurs
resolution
restrict
inferences
using
term
order
cid:31
deﬁnition
speciﬁes
conditions
or-
der
must
satisfy
conditions
ensure
f-terms
compared
uniformly
across
contexts
however
p-terms
compared
different
ways
different
contexts
con-
ditions
ensure
ground
order
mapping
term
predecessor
obtain
simpliﬁcation
order
baader
nipkow
1998
kind
term
order
commonly
used
equational
theorem
proving
finally
condition
ensures
atoms
might
propagated
context
predecessor
via
pred
rule
smallest
important
completeness
deﬁnition
let
cid:109
total
well-founded
order
func-
tion
symbols
context
term
order
cid:31
order
context
terms
satisfying
following
conditions
cid:31
cid:31
cid:109
cid:31
terms
position
cid:31
cid:31
cid:31
s|p
cid:54
cid:54
cid:31
term
proper
position
atom
context
term
term
order
extended
literal
order
also
written
cid:31
described
section
lexicographic
path
order
lpo
baader
nipkow
1998
context
f-terms
context
p-terms
treated
constants
cid:31
satisﬁes
conditions
furthermore
contains
atoms
form
always
make
smallest
ordering
thus
condition
contradict
conditions
hence
lpo
relaxed
condition
satisﬁes
deﬁnition
thus
given
cid:109
least
one
context
term
order
exists
apart
orders
effective
redundancy
elimination
tech-
niques
critical
efﬁciency
resolution
calculi
deﬁni-
tion
deﬁnes
notion
compatible
setting
deﬁnition
set
clauses
contains
clause
redundancy
written
cid:48
cid:54
cid:48
terms
cid:48
cid:48
clause
cid:48
cid:48
cid:48
intuitively
contains
redundancy
adding
modify
constraints
represents
either
tautology
con-
tains
stronger
clause
note
tautologies
form
redundant
setting
used
initialise
contexts
however
whenever
calculus
derives
clause
cid:48
set
clauses
ini-
tialised
makes
former
clause
redun-
dant
condition
deﬁnition
moreover
clause
heads
subjected
usual
tautology
elimination
rules
thus
clauses
cid:54
eliminated
proposition
shows
remove
clause
contained
redun-
dancy
elim
uses
support
clause
subsumption
proposition
set
clauses
cid:48
clauses
cid:48
cid:48
ﬁnally
ready
formalise
notion
context
structure
well
notion
context
structure
soundness
latter
captures
fact
context
clauses
set
contain
corev
bodies
shall
later
show
inference
rules
preserve
context
structure
sound-
ness
essentially
proves
clauses
derived
calculus
indeed
conclusions
ontology
question
deﬁnition
context
structure
ontology
tu-
ple
cid:104
core
cid:31
cid:105
ﬁnite
set
con-
texts
ﬁnite
set
edges
labelled
function
symbol
function
core
assigns
con-
text
conjunction
corev
atoms
p-terms
function
assigns
context
ﬁnite
set
context
clauses
function
cid:31
assigns
context
context
term
order
cid:31
context
structure
sound
following
conditions
hold
context
clause
edge
cid:104
cid:105
corev
coreu
corev
cid:55
cid:55
deﬁnition
introduces
expansion
strategy—a
param-
eter
calculus
determines
reuse
contexts
order
satisfy
existential
restrictions
deﬁnition
expansion
strategy
function
strategy
takes
function
symbol
set
atoms
context
structure
cid:104
core
cid:31
cid:105
result
strategy
computable
polynomial
time
triple
cid:104
core
cid:48
cid:31
cid:48
cid:105
core
cid:48
subset
either
fresh
context
existing
context
corev
core
cid:48
cid:31
cid:48
context
term
order
simanˇc´ık
motik
horrocks
2014
presented
two
ba-
sic
strategies
adapt
setting
follows
eager
strategy
returns
context
vk1
core
kind
ground
terms
vk1
repre-
sents
speciﬁc
set
svk1
likely
smaller
number
contexts
exponential
cautious
strategy
examines
function
symbol
occurs
exactly
one
atom
form
result
context
core
otherwise
result
trivial
con-
text
cid:62
empty
core
context
less
constrained
number
contexts
linear
simanˇc´ık
motik
horrocks
2014
discuss
extensively
differences
relative
merits
two
strategies
although
discussion
deals
alci
conclusions
apply
sriq
well
ready
show
soundness
completeness
theorem
soundness
expansion
strategy
ap-
plying
inference
rule
table
ontology
context
structure
sound
produces
context
structure
sound
theorem
completeness
let
ontology
let
cid:104
core
cid:31
cid:105
context
structure
inference
rule
table
applicable
holds
query
clause
context
satisfy
conditions
c1–c3
atom
context
term
conditions
satisﬁed
appropriately
initialising
corresponding
context
hence
theorems
show
following
algorithm
sound
com-
plete
deciding
create
empty
context
structure
select
ex-
cid:54
cid:31
pansion
strategy
table
rules
consequence-based
calculus
core
rule
corev
cid:62
add
cid:62
cid:86
i=1
cid:86
substitution
add
cid:86
aiσ
s.t
cid:54
cid:23
aiσ
i=1
cid:54
i=1
i=1
cid:87
i=1
cid:87
hyper
rule
rule
cid:31
cid:54
cid:23
cid:46
cid:47
cid:46
cid:47
cid:54
cid:31
cid:54
cid:23
cid:46
cid:47
s2|p
cid:46
cid:47
cid:54
add
cid:46
cid:47
ineq
rule
cid:54
cid:54
add
factor
rule
cid:48
cid:54
cid:23
cid:48
cid:31
cid:48
cid:54
cid:48
cid:48
cid:54
add
cid:54
cid:48
cid:48
elim
rule
remove
pred
rule
i=l+1
cid:104
cid:105
aiσ
s.t
cid:54
cid:23
aiσ
cid:86
i=1
cid:87
l+n
cid:86
i=1
cid:87
add
cid:86
i=1
cid:87
i=1
cid:87
l+n
i=1
cid:87
l+n
i=l+1
aiσ
cid:54
i=l+1
aiσ
cid:55
cid:55
succ
rule
s.t
cid:54
cid:23
contains
cid:48
corev
edge
cid:104
cid:105
exists
cid:48
cid:48
let
cid:104
core
cid:48
cid:31
cid:48
cid:105
strategy
let
cid:31
cid:31
cid:31
cid:48
otherwise
let
cid:31
cid:31
cid:48
add
edge
cid:104
cid:105
add
cid:48
cid:48
cid:48
corev
cid:48
cid:62
cid:48
cid:48
cid:48
cid:48
cid:48
cid:55
cid:55
corev
core
cid:48
cid:48
cid:54
cid:23
cid:48
introduce
context
set
coreq
add
cid:62
satisfy
condition
initialise
cid:31
way
satisﬁes
condition
apply
inference
rules
table
holds
propositions
show
calculus
worst-case
optimal
alchiq
elh
proposition
expansion
strategy
introduces
exponentially
many
contexts
algorithm
a1–a4
runs
worst-case
exponential
time
proposition
elh
ontologies
queries
form
algorithm
a1–a4
runs
polynomial
time
either
cautious
eager
strategy
cautious
strategy
hyper
rule
applied
eagerly
inferences
step
correspond
directly
inferences
elh
calculus
baader
brandt
lutz
2005
4.2
outline
completeness
proof
prove
theorem
ontology
context
struc-
ture
query
clause
context
properties
theorem
satisﬁed
cid:54
holds
construct
herbrand
inter-
pretation
satisﬁes
refutes
reuse
techniques
equational
theorem
proving
nieuwenhuis
rubio
1995
represent
interpretation
rewrite
system
r—a
ﬁnite
set
rules
form
intuitively
rule
says
two
terms
form
equal
prove
equality
one
step
rewriting
i.e.
replacing
rewrite
system
in-
duces
herbrand
equality
interpretation
contains
equality
veriﬁed
using
ﬁnite
number
rewrite
steps
uni-
verse
consists
p-terms
constructed
using
symbols
special
constant
conve-
nience
let
set
f-terms
universe
obtain
unfolding
context
structure
starting
context
map
f-term
context
use
clauses
sxt
construct
model
fragment
rt—the
part
satisﬁes
dl-clauses
mapped
key
issue
ensure
com-
patibility
adjacent
model
fragments
moving
predecessor
term
cid:48
successor
term
cid:48
must
ensure
adding
cid:48
affect
truth
dl-clauses
term
cid:48
words
model
fragment
constructed
must
respect
choices
made
cid:48
represent
choices
ground
clause
conjunction
contains
atoms
inherited
cid:48
must
hold
disjunction
contains
atoms
must
hold
cid:48
relies
absence
model
fragment
construction
takes
parameters
term
context
clause
let
set
ground
clauses
obtained
mapping
predecessor
exists
whose
body
contained
moreover
let
sut
prt
obtained
mapping
predecessor
one
exists
thus
sut
contains
ground
atoms
interest
successors
prt
contains
ground
atoms
interest
predecessor
model
fragment
constructed
properties
l1–l3
hold
cid:54
cid:54
prt
construction
produces
rewrite
system
cid:54
∆t—that
none
hold
model
fragment
compatible
inherited
constraints
construct
rewrite
system
adapting
techniques
paramodulation-based
theorem
proving
first
or-
der
clauses
sequence
compatible
context
ordering
cid:31
particular
way
next
initialise
examine
clause
sequence
hold
model
constructed
thus
far
make
clause
true
adding
prove
condition
assume
sake
contradiction
clause
smallest
cid:54
show
application
exists
ineq
factor
rule
necessarily
produces
cid:54
conditions
clause
allow
satisfy
condition
due
condi-
tion
condition
deﬁnition
order
clauses
sequence
clause
capable
producing
atom
comes
clause
sequence
use
condition
show
clause
actually
exists
moreover
condition
ensures
atoms
actually
produced
obtain
inductively
unfold
step
apply
model
fragment
construction
appropriate
parameters
base
case
map
constant
context
deﬁne
con-
ditions
hold
deﬁnition
condition
holds
property
theorem
induction
step
as-
sume
already
mapped
term
cid:48
context
cid:48
consider
term
cid:48
occur
atom
cid:48
let
thus
make
equal
term
thus
interpreted
exactly
way
stop
unfolding
cid:48
contains
rule
equal
interpret
exactly
hence
stop
unfolding
cases
succ
rule
ensures
con-
tains
edge
cid:104
cid:105
satisﬁes
precon-
ditions
rule
deﬁne
moreover
cid:48
sut
set
atoms
hold
cid:48
let
relevant
let
prt
cid:48
set
atoms
hold
cid:48
relevant
ﬁnally
show
satisfy
condition
otherwise
pred
rule
derives
clause
cid:48
true
cid:48
processing
relevant
terms
let
union
construction
show
sat-
isﬁes
consider
dl-clause
sub-
stitution
makes
clause
ground
w.l.o.g
hermit
pellet
fact++
konclude
sequoia
105
104
103
102
100
200
300
400
500
600
700
figure
classiﬁcation
times
ontologies
easy
category
medium
category
hard
category
100
proﬁle
horn
equality
equality
figure
percentage
easy
medium
hard
ontologies
per
ontology
group
hermit
pellet
fact++
konclude
sequoia
assume
irreducible
r—that
con-
tain
terms
rewritten
using
rules
since
model
fragment
satisﬁes
condition
evalu-
ate
instead
moreover
show
holds
case
hyper
rule
derives
clause
violates
condi-
tion
finally
show
holds
query
clause
completes
proof
evaluation
implemented
calculus
prototype
system
called
sequoia
calculus
implemented
exactly
presented
paper
optimisation
suitable
indexing
scheme
clauses
system
written
scala
used
via
command
line
owl
api
currently
handles
sriq
subset
owl
i.e.
support
datatypes
nominals
reﬂex-
ive
roles
supports
ontology
classiﬁcation
concept
satisﬁability
standard
services
abox
realisation
currently
supported
evaluated
system
using
methodology
steigmiller
liebig
glimm
2014
comparing
se-
quoia
hermit
1.3.8
pellet
2.3.1
fact++
1.6.4
konclude
1.6.1.
used
reasoners
single-threaded
mode
order
compare
underlying
calculi
moreover
sequoia
conﬁgured
use
cautious
strategy
sys-
tems
ontologies
test
results
available
online.1
used
oxford
ontology
repository2
excluded
ontologies
irregular
rboxes
since
sequoia
support
datatypes
nominals
systemati-
cally
replaced
datatypes
nominals
fresh
classes
data
properties
object
properties
removed
abox
assertions
thus
obtained
corpus
777
ontolo-
gies
tested
reasoners
run
experiments
dell
workstation
two
intel
xeon
e5-2643
3.4
ghz
processors
cores
per
processor
128
ram
running
windows
server
2012
used
java
update
heap
memory
allocated
java
reasoner
maximum
private
working
set
size
reasoner
native
code
test
measured
wall-clock
classiﬁcation
time
excludes
parsing
time
reasoners
based
owl
api
i.e.
hermit
pellet
fact++
sequoia
test
given
timeout
minutes
report
average
time
three
runs
unless
exception
timeout
occurred
one
three
runs
case
report
failure
figure
shows
overview
classiﬁcation
times
entire
corpus
y-axis
shows
classiﬁcation
times
logarithmic
scale
timeouts
shown
inﬁnity
number
x-axis
represents
n-th
easiest
ontology
reasoner
ontologies
sorted
reasoner
ascending
order
classiﬁcation
time
example
point
100
reasoner
curve
means
50th
easiest
ontology
reasoner
took
100
classify
sequoia
could
process
ontologies
733
784
10s
consistent
reasoners
system
fairly
robust
failing
ontologies
contrast
hermit
failed
pellet
138
fact++
132
konclude
ontologies
moreover
sequoia
suc-
ceeded
ontologies
hermit
pellet
fact++
failed
finally
one
ontology
se-
quoia
succeeded
reasoners
failed
hard
version
fma
00285
uses
disjunctions
number
restrictions
figure
shows
overview
reasoner
per-
formed
type
ontology
partitioned
ontolo-
gies
following
four
groups
within
proﬁle
owl
i.e.
captured
owl
horn
proﬁle
disjunctive
without
number
restrictions
disjunctive
number
restrictions
used
owl
api
determine
proﬁle
membership
identiﬁed
remaining
three
groups
structural
transformation
addition
reasoner
categorise
ontology
either
easy
10s
medium
10s
5min
hard
timeout
exception
ﬁgure
depicts
bar
rea-
soner
group
bar
divided
blocks
rep-
resenting
percentage
ontologies
afore-
mentioned
categories
difﬁculty
sequoia
1http
//krr-nas.cs.ox.ac.uk/2015/kr/cr/
2http
//www.cs.ox.ac.uk/isg/ontologies/
proﬁle
ontologies
out-of-proﬁle
horn
on-
tologies
easy
remainder
medium
dif-
ﬁculty
sequoia
timed
largely
ontologies
containing
disjunctions
equality
even
case
konclude
timed
fewer
cases
summary
although
early
prototype
sequoia
competitive
reasoner
comfortably
outperforms
her-
mit
pellet
fact++
exhibits
nice
pay-
as-you-go
behaviour
furthermore
problematic
ontologies
seem
mostly
contain
complex
rboxes
large
numbers
cardinality
restrictions
suggests
promising
direc-
tions
future
optimisation
conclusion
future
work
presented
ﬁrst
consequence
based
calculus
sriq—a
includes
disjunction
counting
quantiﬁers
calculus
combines
ideas
state
art
resolution
hyper
tableau
calculi
including
use
ordered
paramodulation
equality
reasoning
despite
increased
complexity
calculus
mimics
existing
cal-
culi
elh
ontologies
although
early
prototype
plenty
room
optimisation
system
sequoia
competitive
well-established
reasoners
exhibits
nice
pay-as-you-go
behaviour
practice
future
work
conﬁdent
extend
calculus
support
role
reﬂexivity
datatypes
thus
handling
owl
except
nominals
contrast
handling
nominals
seems
much
involved
fact
adding
nominals
alchiq
raises
complexity
reasoning
nexptime
worst-case
optimal
calcu-
lus
must
nondeterministic
quite
different
consequence-based
calculi
aware
moreover
challenge
modify
calculus
effectively
deal
large
numbers
number
restrictions
references
baader
nipkow
1998.
term
rewriting
cambridge
university
press
baader
calvanese
mcguinness
nardi
patel-schneider
eds
2003.
description
logic
handbook
theory
implementation
applications
cam-
bridge
university
press
baader
brandt
lutz
2005.
pushing
envelope
kaelbling
safﬁotti
eds.
proc
19th
int
joint
conference
artiﬁcial
intelligence
ijcai
2005
364–369
edinburgh
morgan
kaufmann
publishers
bachmair
ganzinger
2001.
resolution
theorem
robinson
voronkov
eds.
hand-
proving
book
automated
reasoning
volume
elsevier
science
chapter
19–99
glimm
horrocks
motik
stoilos
wang
2014.
hermit
owl
reasoner
journal
auto-
mated
reasoning
:245–269
gor´e
nguyen
2007.
exptime
tableaux
global
caching
description
logics
transi-
tive
roles
inverse
roles
role
hierarchies
olivetti
ed.
proc
16th
int
conf
automated
reason-
ing
tableaux
related
methods
tableaux
2007
volume
4548
lncs
133–148
aix
provence
france
springer
kazakov
2008.
riq
sroiq
harder
shoiq
brewka
lang
eds.
proc
11th
int
joint
conf
principles
knowledge
represen-
tation
reasoning
2008
274–284
sydney
nsw
australia
aaai
press
kazakov
2009.
consequence-driven
reasoning
horn
shiq
ontologies
boutilier
ed.
proc
21st
int
joint
conf
artiﬁcial
intelligence
ijcai
2009
2040–
2045.
motik
shearer
horrocks
2009.
hypertableau
reasoning
description
logics
journal
artiﬁcial
in-
telligence
research
36:165–228
nieuwenhuis
rubio
1995.
theorem
proving
ordering
equality
constrained
clauses
journal
symbolic
computation
:312–351
ortiz
rudolph
simkus
2010.
worst-case
optimal
reasoning
horn-dl
fragments
owl
lin
sattler
truszczynski
eds.
proc
12th
int
conf
knowledge
representation
reasoning
2010
269–279
toronto
canada
aaai
press
riazanov
voronkov
2002.
design
imple-
mentation
vampire
communications
2–3
:91–
110.
schulz
2002.
e—a
brainiac
theorem
prover
com-
munications
2–3
:111–126
simanˇc´ık
kazakov
horrocks
2011.
conse-
quence-based
reasoning
beyond
horn
ontologies
walsh
ed.
proc
22nd
int
joint
conf
artiﬁ-
cial
intelligence
ijcai
2011
1093–1098
simanˇc´ık
motik
horrocks
2014.
conse-
quence-based
fixed-parameter
tractable
reasoning
description
logics
artiﬁcial
intelligence
209:29–77
sirin
parsia
cuenca
grau
kalyanpur
katz
2007.
pellet
practical
owl-dl
reasoner
jour-
nal
web
semantics
:51–53
steigmiller
glimm
liebig
2014.
coupling
tableau
algorithms
expressive
description
logics
completion-based
saturation
procedures
demri
ka-
pur
weidenbach
eds.
proc
7th
int
joint
conf
automated
reasoning
ijcar
2014
volume
8562
lncs
449–463
vienna
austria
springer
steigmiller
liebig
glimm
2014.
konclude
system
description
journal
web
semantics
27:78–85
tsarkov
horrocks
2006.
fact++
description
logic
reasoner
system
description
proc
3rd
int
joint
conf
automated
reasoning
ijcar
2006
volume
4130
lnai
292–297
seattle
usa
springer
proof
theorem
chapter
show
calculus
sound
stated
theorem
proof
analogous
soundness
proof
ordered
superposition
nieuwenhuis
rubio
1995
theorem
soundness
expansion
strategy
applying
inference
rule
table
ontology
context
structure
sound
produces
context
structure
sound
proof
let
ontology
let
cid:104
core
cid:31
cid:105
context
structure
sound
consider
application
inference
rule
table
show
clause
produced
rule
context
clause
satisﬁes
conditions
deﬁnition
condition
holds
obviously
rules
different
hyper
pred
condition
rely
soundness
hyperresolution
arbitrary
formulas
cid:94
cid:91
j=1
1≤i≤n
cid:94
cid:95
i=1
i=1
corev
cid:86
prove
claim
consider
rule
table
assume
rule
applied
clauses
contexts
edges
shown
table
show
clause
produced
rule
satisﬁes
condition
deﬁnition
moreover
succ
rule
show
addition
edge
introduced
rule
satisﬁes
condition
core
corev
clearly
corev
hyper
since
sound
corev
aiσ
i=1
moreover
substitution
satisﬁes
premises
context
clauses
contains
dl-clauses
thus
inference
rule
match
atom
ontology
clause
atoms
context
clause
either
thus
result
context
clause
since
sound
properties
hold
moreover
clause
logical
consequence
clauses
property
holds
required
i=1
cid:87
corev
corev
cid:46
cid:47
corev
cid:46
cid:47
finally
term
always
form
term
form
term
form
thus
context
term
result
context
clause
ineq
since
sound
corev
cid:54
clearly
corev
required
factor
since
sound
property
holds
moreover
clause
logical
consequence
clause
property
holds
required
corev
cid:48
corev
cid:54
cid:48
cid:48
elim
resulting
context
structure
contains
subset
clauses
clearly
sound
pred
let
cid:55
cid:55
since
sound
properties
hold
clause
instance
clause
property
holds
properties
imply
property
finally
properties
imply
property
required
coreu
aiσ
coreu
corevσ
i=1
cid:87
m+n
corev
cid:86
i=1
aiσ
cid:87
m+n
corevσ
cid:86
corevσ
corev
cid:86
coreu
cid:86
i=1
cid:87
m+n
form
deﬁnition
ensures
aiσ
context
atom
required
i=1
cid:87
m+n
j=m+1
ajσ
j=m+1
ajσ
j=m+1
ajσ
j=m+1
succ
let
cid:55
cid:55
clause
added
clearly
corev
required
condition
deﬁnition
moreover
assume
inference
rule
adds
edge
cid:104
cid:105
since
sound
deﬁnition
corev
coreu
coreu
corevσ
property
holds
required
condition
deﬁnition
preliminaries
rewrite
systems
proof
theorem
construct
model
ontology
common
equational
theorem
proving
represent
using
ground
rewrite
system
next
recapitulate
deﬁnitions
rewrite
systems
following
presentation
baader
nipkow
1998
let
set
ground
terms
constructed
using
distinguished
constant
sort
function
symbols
predicate
symbols
ground
rewrite
system
binary
relation
pair
called
rewrite
rule
commonly
written
rewrite
relation
smallest
binary
relation
∗→r
terms
necessarily
proper
position
moreover
∗↔r
reﬂexive–symmetric–transitive
closure
term
irreducible
reﬂexive–transitive
closure
term
exists
literal
clause
substitution
irreducible
term
occurring
∗↔r
irreducible
consider
following
irreducible
moreover
term
normal
form
w.r.t
properties
rewrite
systems
terminating
inﬁnite
sequence
terms
exists
si+1
left-reduced
term
irreducible
church-rosser
terms
terminating
left-reduced
church-rosser
baader
nipkow
1998
theorem
2.1.5
exercise
6.7
∗→r
holds
herbrand
interpretation
induced
church-rosser
term
unique
normal
form
church-rosser
system
set
term
orders
used
prove
termination
rewrite
systems
term
order
cid:31
simpliﬁcation
order
following
∗↔r
term
exists
∗→r
conditions
hold
terms
positions
substitutions
cid:31
implies
s1σ
cid:31
s2σ
term
proper
position
cid:31
s|p
given
rewrite
system
simpliﬁcation
order
cid:31
exists
implies
cid:31
terminating
baader
nipkow
1998
theorems
5.2.3
5.4.8
implies
cid:31
∗→r
∗↔r
proof
theorem
theorem
completeness
let
ontology
let
cid:104
core
cid:31
cid:105
context
structure
inference
rule
table
applicable
holds
query
clause
context
satisfy
conditions
c1–c3
atom
context
term
cid:54
cid:31
section
ontology
context
structure
cid:104
core
cid:31
cid:105
context
query
clause
conditions
theorem
satisﬁed
show
contrapositive
condition
cid:54
cid:54
end
construct
rewrite
system
induced
herbrand
model
satisﬁes
clauses
construct
model
using
distinguished
constant
unary
function
symbols
unary
binary
predicate
symbols
respectively
let
term
form
predecessor
successor
deﬁnitions
con-
stant
predecessor
f-neighbourhood
set
f-terms
containing
predecessor
cid:48
one
exists
p-neighbourhood
contains
p-terms
predecessor
cid:48
also
p-terms
cid:48
cid:48
cid:48
let
substitution
predecessor
cid:48
cid:48
finally
term
deﬁne
sets
atoms
prt
sut
follows
sut
aσt
aσt
ground
prt
aσt
aσt
ground
c.1
constructing
model
fragment
section
show
given
term
generate
part
model
covers
neighbourhood
rest
appendix
c.1
following
parameters
model
fragment
generation
process
ground
f-term
context
conjunction
atoms
disjunction
atoms
let
set
ground
clauses
obtained
follows
γσt
∆σt
γσt
∆σt
ground
γσt
assume
following
conditions
hold
cid:54
cid:54
prt
cid:54
holds
throughout
appendix
c.1
treat
next
construct
rewrite
system
terms
f-neighbourhood
constants
thus
even
though
rewrite
system
contain
terms
consider
terms
nesting
c.1.1
grounding
context
order
construct
need
order
terms
neighbourhood
compatible
cid:31
end
let
total
strict
simpliﬁcation
order
set
ground
terms
constructed
using
f-neighbourhood
predicate
symbols
satisﬁes
following
conditions
context
terms
s1σt
s2σt
ground
cid:48
predecessor
exists
cid:31
implies
s1σt
s2σt
s1σt
s1σt
s2σt
s2σt
cid:54
cid:48
imply
s2σt
condition
theorem
condition
deﬁnition
ensure
order
cid:31
nonground
context
terms
grounded
way
compatible
condition
moreover
since
section
treat
f-terms
constants
make
p-terms
form
cid:48
cid:48
cid:48
smaller
p-terms
i.e.
need
worry
deﬁning
order
predecessor
cid:48
ancestors
thus
least
one
order
exists
rest
section
arbitrary
order
extend
ground
literals
also
written
identifying
cid:54
multiset
multiset
comparing
result
using
multiset
extension
term
order
deﬁned
section
finally
extend
disjunctions
ground
literals
also
written
i=1
multiset
comparing
result
using
multiset
extension
identifying
disjunction
cid:87
literal
order
c.1.2
constructing
rewrite
system
arrange
clauses
sequence
since
body
subset
contain
head
would
contradict
condition
thus
assume
form
literal
form
cid:46
cid:47
cid:46
cid:47
cid:54
rest
appendix
c.1
reserve
referring
parts
clauses
sequence
finally
assume
induc-
deﬁning
rewrite
systems
setting
form
tively
follows
next
deﬁne
sequence
ri−1
cid:54
ri−1
irreducible
ri−1
cid:54
ri−1
ri−1
cases
finally
let
ﬁrst
condition
construction
called
generative
clause
said
generate
rule
call
model
fragment
clause
satisﬁes
c.1.3
properties
model
fragment
lemma
rewrite
system
church-rosser
proof
see
terminating
simply
note
rule
condition
ensures
simpliﬁcation
order
see
left-reduced
consider
arbitrary
rule
added
step
clause
sequence
condition
irreducible
consider
arbitrary
rule
cid:48
cid:48
added
step
construction
deﬁnition
clause
order
implies
cid:48
cid:48
since
cid:48
cid:48
condition
deﬁnition
literal
order
cid:48
since
rj−1
condition
ensures
cid:54
cid:48
cid:48
consequently
cid:48
subterm
thus
irreducible
lemma
cid:54
ri−1
proof
consider
arbitrary
clause
arbitrary
inequality
cid:54
ri−1
required
assume
cid:54
ri−1
implies
ri−1
let
cid:48
cid:48
consider
arbitrary
generated
normal
forms
respectively
w.r.t
ri−1
cid:54
deﬁnition
literal
order
implies
cid:48
cid:48
since
simpliﬁcation
order
subterm
neither
cid:48
cid:48
thus
cid:48
cid:48
normal
forms
respectively
w.r.t
cid:48
cid:48
cid:54
lemma
generative
clause
proof
consider
generative
clause
literal
condition
ensures
ri−1
next
show
ri−1
cid:54
assume
form
cid:54
since
cid:54
lemma
assume
form
show
induction
∗|=
cid:54
required
required
cid:54
cid:54
cid:54
cid:54
generational
rj−1
cid:54
cid:54
thus
assume
end
assume
rj−1
generational
consider
following
two
cases
following
two
subcases
cid:48
cid:48
cid:48
cid:54
ri−1
condition
ensures
cid:54
ri−1
let
cid:48
cid:48
cid:48
normal
forms
respectively
w.r.t
moreover
cid:48
cid:48
cid:48
hold
since
simpliﬁcation
order
ri−1
subterm
neither
cid:48
cid:48
cid:48
therefore
cid:48
cid:48
cid:48
normal
forms
respectively
w.r.t
therefore
cid:48
cid:48
cid:48
cid:54
cid:54
finally
since
irreducible
rj−1
rj−1
implies
furthermore
contradicts
condition
term
cid:48
cid:48
normal
form
w.r.t
generational
let
cid:48
cid:48
normal
forms
respectively
w.r.t
rj−1
holds
cid:48
cid:48
since
simpliﬁcation
order
subterm
neither
cid:48
cid:48
thus
cid:48
cid:48
normal
forms
respectively
w.r.t
hence
cid:54
cid:48
cid:48
cid:54
holds
exists
lemma
let
clause
i.e.
index
clause
proof
assume
holds
satisﬁes
condition
deﬁnition
clearly
assume
satisﬁes
condition
deﬁnition
due
clause
hold
latter
clearly
implies
let
integer
satisfying
lemma
assumption
clearly
otherwise
implies
also
lemma
assumption
lemma
clause
γσt
hold
γσt
∆σt
proof
assume
holds
satisﬁes
condition
deﬁnition
terms
cid:48
exist
cid:48
cid:54
cid:48
sσt
cid:48
∆σt
sσt
cid:48
sσt
cid:54
cid:48
∆σt
γσt
∆σt
holds
furthermore
satisﬁes
condition
deﬁnition
clause
cid:48
cid:48
exists
cid:48
cid:48
due
cid:48
γσt
cid:48
cid:48
holds
γσt
∆σt
holds
well
lemma
implies
required
proof
sake
contraction
choose
clause
sequence
clauses
appendix
c.1.2
cid:54
please
recall
cid:46
cid:47
cid:46
cid:47
cid:54
due
smallest
choice
condition
lemma
holds
deﬁnition
clause
exists
γσt
∆σt
lσt
cid:54
cid:23
next
prove
claim
lemma
considering
possible
forms
cid:54
ri−1
contradicts
assumption
assume
assume
literal
form
lσt
rσt
deﬁnition
cid:31
ﬁrst
show
ri−1
cid:54
holds
towards
goal
note
equality
cid:54
inequality
cid:54
lemma
properties
cid:54
cid:54
imply
ri−1
cid:54
clause
generational
thus
either
condition
condition
satisﬁed
next
consider
possibilities
condition
hold—that
reducible
ri−1
cid:54
cid:54
thus
clause
satisﬁes
conditions
however
since
deﬁnition
reducibility
position
clause
generating
rule
exist
li|p
due
together
lemma
ensures
cid:54
deﬁnition
ensures
clause
cid:48
cid:48
cid:48
cid:48
exists
imply
ri−1
cid:54
cid:48
cid:48
cid:54
cid:23
cid:48
cid:48
cid:48
cid:48
cid:48
assumption
theorem
rule
applicable
cid:48
cid:48
cid:48
let
cid:48
cid:48
clearly
γσt
cid:48
lemma
ensures
cid:48
cid:48
holds
set
congruence
cid:54
cid:54
cid:48
cid:48
holds
finally
simpliﬁcation
order
ensures
together
cid:48
cid:48
lemma
cid:48
cid:48
contradiction
implies
condition
hold
term
exists
ri−1
cid:54
cid:54
furthermore
form
cid:48
cid:48
cid:48
holds
therefore
due
ri−1
cid:48
cid:31
cid:48
cid:48
cid:48
rσt
lσt
clearly
cid:48
assumption
theorem
factor
rule
applicable
cid:48
cid:54
cid:48
cid:48
cid:48
let
cid:48
cid:48
cid:48
cid:54
γσt
lemma
en-
cid:54
cid:48
cid:48
moreover
imply
sure
cid:48
cid:48
holds
previous
observations
thus
cid:48
cid:48
holds
lemma
implies
assume
cid:54
literal
form
cid:54
lσt
cid:54
rσt
cid:54
implies
assumption
theorem
ineq
rule
applicable
clause
since
γσt
lemma
clearly
cid:54
lemma
implies
contradiction
cid:48
cid:48
contradiction
cid:54
cid:54
hence
reducible
ri−1
assume
cid:54
lemma
ensures
ri−1
def-
inition
reducibility
position
generative
clause
exist
li|p
due
cid:54
lemma
ensures
cid:54
deﬁnition
ensures
clause
cid:48
cid:48
cid:48
cid:48
exists
satisfying
ﬁrst
case
assumption
theorem
rule
applica-
ble
clauses
cid:48
cid:48
cid:48
cid:54
holds
let
cid:48
cid:48
cid:54
clearly
γσt
cid:48
lemma
cid:48
cid:48
since
cid:54
cid:54
cid:54
cid:48
cid:48
holds
finally
simpliﬁcation
order
cid:54
together
therefore
cid:48
cid:48
lemma
implies
lemma
clause
proof
apply
lemma
lemma
lemma
generative
clause
disjunction
contain
literal
form
cid:54
proof
sake
contradiction
let
assume
clause
generative
cid:54
holds
term
deﬁnition
clause
cid:48
cid:48
cid:48
cid:54
cid:48
cid:48
cid:48
exists
cid:48
cid:48
contradiction
congruence
cid:48
cid:48
cid:48
cid:54
cid:48
cid:48
cid:48
cid:48
ri−1
lemma
∗|=
contradiction
cid:54
moreover
condition
ri−1
∗|=
since
argument
ri−1
cid:54
note
condition
ensures
lemma
ensures
cid:54
assume
sake
contradiction
atom
exists
assumption
theorem
ineq
rule
applicable
clause
cid:48
cid:48
cid:48
cid:48
thus
cid:48
holds
cid:40
cid:54
however
lemma
lemma
implies
let
index
clause
sequence
clauses
appendix
c.1.2
due
∗|=
implies
ri−1
lemma
atom
proof
generative
clause
position
exist
a|p
let
since
simpliﬁcation
order
since
next
consider
arbitrary
literal
cid:46
cid:47
cid:46
cid:47
cid:54
observations
made
thus
far
cid:46
cid:47
holds
condition
one
following
holds
cid:48
moreover
since
cid:46
cid:47
obtained
grounding
context
literal
form
cid:48
together
cid:48
cid:46
cid:47
cid:48
cid:48
clause
generative
due
condition
hence
remaining
possibility
cid:46
cid:47
form
cid:48
cid:54
cid:48
clause
generative
lemma
consequently
either
case
get
contradiction
thus
second
point
holds
arbitrary
cid:46
cid:47
therefore
implies
holds
contradicts
condition
c.2
combine
rewrite
systems
constructed
appendix
c.1
single
rewrite
system
show
satisﬁes
r∗|=
cid:54
interpreting
ontology
c.2.1
unfolding
context
structure
construct
partial
induction
terms
deﬁne
several
partial
functions
function
maps
term
context
functions
assign
term
conjunction
disjunction
respectively
atoms
function
maps
term
model
fragment
base
case
consider
constant
γqσc
∆qσc
model
fragment
inductive
step
assume
cid:48
already
deﬁned
consider
arbitrary
function
symbol
cid:48
irreducible
cid:48
let
cid:48
cid:48
two
possibilities
m2.a
term
occurs
cid:48
term
cid:48
generated
cid:48
ground
clause
cid:48
cid:48
occurs
deﬁnition
clause
cid:48
cid:48
cid:48
cid:48
exists
cid:48
cid:48
cid:48
contains
moreover
cid:48
implies
cid:48
cid:54
cid:23
cid:48
succ
core
rules
applicable
choose
context
cid:104
cid:105
succ
rule
deﬁne
following
cid:48
sut
prt
cid:48
model
fragment
m2.b
term
occur
cid:48
let
deﬁne
functions
finally
let
rewrite
system
deﬁned
cid:83
lemma
10.
model
fragments
constructed
lines
satisfy
conditions
ap-
pendix
c.1
proof
proof
induction
structure
terms
dom
conditions
hold
directly
conditions
theorem
next
assume
lemma
holds
term
cid:48
dom
consider
arbitrary
term
form
cid:48
let
cid:48
condition
holds
prt
cid:48
due
hence
prt
proceeding
note
terms
cid:48
irreducible
cid:48
due
condition
since
cid:48
holds
atom
cid:48
generated
clause
satisfying
subscript
necessarily
indicate
position
clause
sequence
clauses
appendix
c.1.2
deﬁnition
cid:48
exists
clause
satisfying
cid:48
cid:48
cid:48
cid:48
cid:48
condition
consider
arbitrary
atom
let
clause
generates
cid:48
let
substitution
succ
rule
speciﬁed
succ
rule
condition
m2.a
chose
succ
rule
satisﬁed
prove
condition
holds
well
assume
sake
contradiction
holds
prt
corresponding
nonground
clause
since
sut
atom
cid:48
cid:48
cid:48
therefore
cid:48
cid:48
required
condition
since
cid:48
cid:48
form
cid:48
cid:48
iσt
cid:48
cid:48
iσt
cid:48
cid:48
cid:48
cid:48
cid:54
cid:23
cid:48
cid:48
iσt
cid:48
due
therefore
due
condition
deﬁnition
set
contains
clause
prt
cid:94
i=1
m+n
cid:95
m+n
cid:95
i=m+1
cid:48
cid:94
i=1
i=m+1
deﬁnition
set
contains
clause
cid:48
cid:48
iσt
cid:48
generated
ground
clause
latter
obtained
corresponding
nonground
clause
pred
rule
applicable
holds
together
lemma
ensures
cid:94
cid:94
i=1
cid:48
cid:95
cid:95
i=1
m+n
cid:95
m+n
cid:95
i=m+1
cid:48
cid:48
cid:48
cid:55
cid:55
lemma
contradicts
lemma
cid:48
cid:54
ensures
cid:48
cid:54
cid:48
cid:54
however
i=1
i=1
i=m+1
c.2.2
termination
conﬂuence
compatibility
lemma
11.
rewrite
system
church-rosser
proof
show
terminating
left-reduced
thus
church-rosser
proof
former
use
total
simpliﬁcation
order
cid:66
ground
p-terms
deﬁned
follows
extend
precedence
cid:109
deﬁnition
p-symbols
arbitrary
way
ensuring
constant
smallest
order
let
cid:66
lexicographic
path
order
baader
nipkow
1998
cid:109
well
known
cid:66
simpliﬁcation
order
satisﬁes
following
properties
f-term
predecessor
cid:48
one
exists
function
symbols
p-term
cid:66
cid:66
cid:48
cid:109
implies
cid:66
cid:66
thus
conditions
deﬁnition
manner
context
orders
grounded
appendix
c.1.1
clearly
ensure
f-term
dom
terms
f-neighbourhood
cid:66
next
show
terminating
arguing
rule
embedded
cid:66
end
consider
arbitrary
rule
clearly
term
dom
exists
rule
obtained
head
clause
condition
deﬁnition
ensures
moreover
obtained
grounding
context
literal
following
possible
forms
terms
f-neighbourhood
implies
cid:66
p-term
cid:66
since
smallest
cid:109
next
show
left-reduced
sake
contradiction
assume
rule
exists
reducible
cid:48
let
deepest
position
rule
cid:48
reduces
i.e.
rule
cid:48
reduces
position
let
cid:48
cid:48
cid:48
rule
reduces
position
thus
cid:48
l|p
deﬁnition
cid:48
cid:48
follows
term
handled
condition
m2.a
cid:48
cid:48
generated
equality
cid:48
cid:48
head
generative
clause
term
handled
condition
m2.b
cid:48
moreover
cid:48
contain
construction
contradicts
cid:48
form
thus
reducible
contradicts
condition
construction
assumption
cid:48
cid:48
cid:48
cid:48
assume
assume
sake
contradiction
cid:54
cid:54
lemma
12.
term
atom
sut
prf
f-terms
irreducible
proof
let
term
let
function
symbol
let
sut
prf
atom
f-terms
irreducible
latter
ensures
next
consider
possible
forms
assume
sut
deﬁnition
sut
fact
contains
atoms
form
atom
form
cid:48
cid:48
cid:48
predecessor
one
exists
form
cid:48
due
sut
deﬁnition
generative
clauses
clearly
lemma
ensures
assume
prf
deﬁnition
prf
fact
contains
atoms
form
atom
form
form
generative
clauses
clearly
due
prf
deﬁnition
due
lemma
contradiction
lemma
13.
let
dl-terms
let
substitution
irreducible
s1τ
s2τ
ground
deﬁned
f-neighbourhood
cid:46
cid:47
cid:54
proof
let
stated
let
let
cid:48
predecessor
one
exists
since
irreducible
rewrite
system
deﬁned
appendix
c.2.1
next
consider
possible
forms
cid:46
cid:47
assume
cid:46
cid:47
assume
cid:46
cid:47
cid:54
let
cid:48
normal
forms
s1τ
s2τ
respectively
w.r.t
due
shape
dl-literals
form
therefore
s1τ
s2τ
form
cid:48
term
irreducible
thus
cid:48
irreducible
well
furthermore
due
shape
context
terms
rewrite
system
could
occur
left-hand
side
rewrite
rule
consequently
irreducible
well
cid:48
normal
forms
s1τ
s2τ
respectively
w.r.t
thus
r∗|=
cid:48
cid:48
thus
r∗|=
s1τ
cid:54
s2τ
holds
required
cid:54
therefore
cid:54
s1τ
cid:46
cid:47
s2τ
r∗|=
s1τ
cid:46
cid:47
s2τ
s1τ
s2τ
imply
r∗|=
s1τ
s2τ
required
cid:48
cid:54
cid:48
c.2.3
completeness
claim
lemma
14.
dl-clause
r∗|=
proof
consider
arbitrary
dl-clause
following
form
cid:86
i=1
let
cid:48
arbitrary
substitution
cid:48
cid:48
ground
let
substitution
obtained
cid:48
replac-
ing
ground
term
normal
form
w.r.t
since
congruence
r∗|=
cid:48
cid:48
r∗|=
next
assume
r∗|=
show
r∗|=
holds
well
consider
arbitrary
atom
deﬁnition
dl-clauses
form
substitu-
tion
irreducible
f-terms
aiτ
irreducible
aiτ
clearly
implies
aiτ
rule
obtained
generative
clause
aiτ
form
cid:48
cid:48
cid:48
predecessor
exists
next
prove
aiτ
sut
prf
holds
considering
possible
forms
aiτ
implies
sut
holds
aiτ
form
cid:48
implies
cid:48
sut
holds
moreover
implies
prf
holds
aiτ
form
cid:48
implies
cid:48
sut
holds
moreover
implies
prf
holds
lemma
implies
aiτ
contains
generative
clause
form
let
deﬁnition
set
contains
clause
form
hyper
rule
applicable
therefore
holds
substitution
obtained
replacing
occurrence
possibly
nested
another
term
finally
lemma
ensures
holds
well
cid:48
cid:48
iσt
cid:48
cid:48
cid:48
cid:48
iσt
cid:48
iσt
cid:48
cid:54
cid:15
cid:48
cid:94
cid:94
i=1
lemma
implies
cid:95
cid:95
cid:48
i=1
i=1
i=1
i=1
cid:87
lemma
imply
lemma
ensures
r∗|=
required
lemma
15.
cid:54
proof
claim
clearly
follows
cid:54
note
lemma
ensures
cid:54
former
observation
lemma
ensure
r∗|=
holds
moreover
atom
deﬁ-
nition
ensures
thus
prf
contrapositive
lemma
ensures
cid:54
thus
cid:54
holds
required
cid:54
therefore
cid:54
thus
finally
proof
proposition
proposition
expansion
strategy
introduces
exponentially
many
contexts
algorithm
a1–a4
runs
worst-case
exponential
time
proof
number
context
clauses
generated
using
symbols
exponential
size
number
clauses
participating
inference
linear
size
hence
contexts
number
inferences
bounded
exponential
size
number
inferences
exponential
well
thus
exponentially
many
contexts
introduced
algorithm
runs
exponential
time
proof
proposition
proposition
elh
ontologies
queries
form
algorithm
a1–a4
runs
polynomial
time
either
cautious
eager
strategy
cautious
strategy
hyper
rule
applied
eagerly
inferences
step
correspond
directly
inferences
elh
calculus
baader
brandt
lutz
2005
proof
consider
elh
ontology
transformed
set
dl-clauses
speciﬁed
section
consider
query
form
due
form
query
core
initialised
ﬁrst
consider
applying
algorithm
a1–a4
cautious
strategy
eager
application
hyper
rule
induction
application
rules
table
next
show
context
clause
derived
rules
form
101
core
context
form
cid:62
cid:62
cid:62
100
101
particular
step
perform
following
inferences
speciﬁed
correspondence
completion
rules
cr1–cr4
cr10
baader
brandt
lutz
2005
core
context
form
core
rule
introduces
clause
form
form
corresponds
hyper
rule
applied
dl-clause
type
dl1
clauses
participating
inference
form
way
baader
brandt
lutz
2005
initialise
mappings
result
form
inference
corresponds
completion
rules
cr1
cr2
hyper
rule
applied
dl-clause
type
dl2
clause
participating
inference
form
result
form
moreover
function
symbol
occurs
exactly
one
pair
clauses
dl2
hyper
rule
applied
eagerly
thus
whenever
occurs
context
clause
form
also
occurs
clause
form
succ
rule
applied
function
symbol
case
cautious
strategy
thus
returns
context
whose
core
form
inferences
correspond
completion
rule
cr3
hyper
rule
applied
dl-clause
type
dl3
two
clauses
participating
inference
form
100
result
form
100
pred
rule
applied
latter
clause
producing
clause
form
pair
inferences
corresponds
completion
rule
cr4
hyper
rule
applied
dl-clause
type
dl5
clause
participating
inference
form
100
result
form
100
well
pred
rule
applied
latter
clause
producing
clause
form
pair
inferences
corresponds
completion
rule
cr10
one
show
analogous
way
inference
calculus
baader
brandt
lutz
2005
corresponds
one
inferences
calculus
furthermore
clear
algorithm
runs
polynomial
time
next
consider
applying
algorithm
a1–a4
eager
strategy
one
show
core
context
form
context
contain
clauses
form
103
cid:62
cid:62
102
103
proof
analogous
case
cautions
strategy
without
correspondence
completion
rules
omit
details
sake
brevity
minor
difference
application
pred
contexts
introduces
clause
form
succ
rule
become
applicable
since
precondition
succ
rule
still
satisﬁed
thus
succ
rule
never
introduces
contexts
whose
cores
contain
conjunctions
binary
atoms
thus
contains
unary
binary
predicates
number
contexts
bounded
context
contain
clauses
rules
applied
polynomial
time
algorithm
runs
polynomial
time
