probabilistic
extension
concurrent
constraint
factor
oracle
model
music
improvisation
mauricio
toro
universidad
eafit
abstract
program
real-time
music
improvisation
system
c++
without
formal
semantic
model
process
calculi
non-deterministic
timed
concurrent
constraint
ntcc
calculus
concurrent
constraints
factor
oracle
model
music
improvisation
ccfomi
improvisation
model
specified
ntcc
since
ccfomi
improvises
non-deterministically
control
choices
therefore
little
control
sequence
variation
improvisation
avoid
extended
ccfomi
using
probabilistic
non-deterministic
timed
concurrent
constraint
calculus
extension
ccfomi
change
time
space
complexity
building
thus
making
extension
compatible
however
ntcc
interpreter
capable
execute
ccfomi
developed
ntccrt
capable
interpreter
ntcc–
executed
ccfomi
ntccrt
future
plan
extend
ntccrt
execute
extension
ccfomi
keywords
factor
oracle
concurrent
constraints
programming
ccp
machine
learning
machine
improvisation
ccfomi
gecode
ntcc
pntcc
real-time
introduction
two
different
approaches
develop
multimedia
interaction
systems
e.g.
machine
improvisation
one
may
think
order
implement
real-time
capable
systems
systems
written
directly
c++
efficiency
contrast
one
may
argue
multimedia
interaction
systems
–inherently
concurrent–
written
directly
c++
formalism
reason
concurrency
c++
argue
systems
modeled
using
process
calculus
formal
semantics
verification
procedures
execute
models
real-
time
capable
interpreter
definition
real-time
rest
document
garavel
explains
models
based
process
calculi
widespread
many
calculi
many
variants
calculus
difficult
choose
appropriate
addition
difficult
express
explicit
notion
time
real-time
requirements
process
calculi
finally
argues
existing
tools
process
calculi
user-friendly
1.1
motivation
defending
calculi
approach
rueda
explain
using
semantics
logic
underlying
non-deterministic
timed
concurrent
constraint
ntcc
calculus
possible
prove
properties
ntcc
models
executing
execute
models
ntcc
interpreter
define
soft
real-
time
multimedia
interaction
means
system
reacts
fast
enough
interact
human
players
without
letting
notice
delays
one
may
disagree
rueda
al.
arguing
although
several
interpreters
ntcc
lman
rueda
interpreter
generic
interpreter
run
ntcc
models
real-time
agree
rueda
way
develop
systems
also
argue
currently
ntcc
interpreters
capable
real-time
argue
agreement
rueda
al.
argument
models
based
ntcc
concurrent
constraints
factor
oracle
model
music
improvisation
ccfomi
good
alternative
model
multimedia
interaction
synchronization
presented
declaratively
means
variable
sharing
among
concurrent
agents
reasoning
information
contained
global
store
however
due
non-
deterministic
choices
improvisation
ccfomi
repetitive
i.e.
produces
loops
without
control
addition
since
ccfomi
change
intensity
learned
notes
ccfomi
may
produce
sharp
difference
relative
loudness
musician
plays
improviser
plays
process
calculi
applied
modeling
interactive
music
systems
ecological
systems
main
objective
extending
ccfomi
model
probabilistic
choice
musical
sequences
also
want
show
ntcc
model
interact
human
player
soft
real-time
using
ntcc
interpreter
reason
developed
ntccrt
generic
real-time
interpreter
ntcc
rest
introduction
organized
follows
first
section
gives
definition
music
improvisation
second
section
explains
machine
improvisation
third
section
gives
brief
introduction
ntcc
presents
systems
modeled
ntcc
explaining
intuitions
music
improvisation
machine
improvisation
ntcc
explain
solution
extend
ccfomi
section
fourth
section
fifth
section
explains
contributions
thesis
work
finally
sixth
section
explains
organization
following
chapters
1.2
music
improvisation
musical
improvisation
spontaneous
creative
process
making
music
performed
use
linguistic
analogy
improvisation
like
speaking
conversation
opposed
reciting
written
text
among
jazz
musicians
adage
improvisation
composition
speeded
vice
versa
composition
improvisation
slowed
down.
improvisation
exists
almost
music
generel
however
improvisation
frequently
associated
melodic
improvisation
found
jazz
however
spontaneous
real-time
variation
performance
tempo
dynamics
within
classical
performance
may
also
considered
improvisation
reader
may
see
example
music
improvisation
musician
alberto
riascos
improvised
colombian
music
genre
guabina1
explained
1.3
machine
improvisation
machine
improvisation
simulation
music
improvisation
computer
process
builds
representation
music
either
explicit
coding
rules
applying
machine
learning
methods
real-time
machine
improvisation
necessary
perform
two
phases
concurrently
stylistic
learning
stylistic
guabina
colombian
traditional
music
common
regions
antioquia
santander
boyacá
cundinamarca
tolima
huila
simulation
addition
perform
phases
concurrently
system
must
able
interact
real-time
human
players
rueda
define
stylistic
learning
process
applying
methods
musical
sequences
order
capture
important
musical
features
organize
features
model
stylistic
simulation
process
producing
musical
sequences
stylistically
consistent
learned
style
example
system
running
concurrently
phases
ccfomi
system
using
factor
oracle
store
information
learned
sequences
ntcc
calculus
synchronize
phases
improvisation
1.4
introduction
ntcc
ntcc
calculus
mathematic
formalism
used
represent
reactive
systems
synchronous
asynchronous
and/or
non-deterministic
behavior
formalism
extensions
used
model
systems
musical
improvisation
systems
audio
processing
framework
interactive
scores
ntcc
useful
multimedia
semantic
interaction
also
used
fields
modeling
molecular
biology
analyzing
biological
systems
security
protocols
fields
also
include
study
complex
interactions
want
observe
certain
properties
showing
model
answer
system
modeling
molecular
biology
security
protocols
multimedia
semantic
interaction
using
process
calculi
base
project
robust
theories
emerging
applications
concurrency
theory
react2
novelty
approach
specification
synchronization
declarative
way
opposed
programming
languages
c++
programmer
specify
multiple
steps
guarantee
correct
synchronization
safe
access
shared
resources
explanation
ntcc
model
musical
processes
ntcc
presented
chapter
1.5
solution
avoid
repetitive
improvisation
extend
ccfomi
probabilistic
non-
deterministic
timed
concurrent
constraint
pntcc
calculus
decrease
probability
choosing
sequence
previously
improvised
idea
based
probabilistic
ccfomi
model
developed
pérez
rueda
model
chooses
improvised
sequences
probabilistically
based
probability
distribution
unfortunately
probabilistic
ccfomi
give
information
probability
distribution
built
change
time
according
user
computer
interaction
model
first
pntcc
model
far
know
probability
distributions
change
time-unit
another
instance
consider
system
play
certain
moment
pitches
i.e.
frecuency
notes
equal
probability
outputs
sequence
aaba
going
choose
another
pitch
choosing
pitch
greater
probability
chosen
greater
probability
chosen
played
three
times
last
sequence
using
probabilistic
extension
avoid
multiple
cycles
improvisation
happen
without
control
ccfomi
hand
coherent
relative
loudness
user
currently
playing
change
intensity
improvised
notes
idea
based
interviews
musicians
riascos
juan
manuel
collazos
thesis
partially
funded
react
project
sponsored
colciencias
argue
technique
use
improvising
improves
quality
improvisation
two
persons
improvise
time
instance
computer
plays
five
notes
intensities
measured
127
user
plays
time
four
notes
intensities
incoherence
results
user
playing
low
computer
playing
loud
reason
system
multiplies
intensities
factor
0.29
relation
average
sequences
changing
intensities
computer
output
1.6
contributions
gecol
first
approach
provide
interface
gecode
common
lisp
extend
gecol
work
gecode
using
gecol
wrote
several
prototypes
ntcc
interpreter
examples
sources
binaries
found
http
//common-lisp.net/project/gecol/
ntccrt
real-time
capable
interpreter
ntcc
using
ntccrt
executed
ccfomi
examples
sources
binaries
found
http
//ntccrt.sourceforge.net
article
ntccrt
published
year
gelisp
new
graphical
constraint
solving
library
openmusic
plan
use
future
closer
integration
ntccrt
openmusic
examples
sources
binaries
found
http
//gelisp.sourceforge.net
article
gelisp
publish
year
original
version
gelisp
developed
rueda
common
lisp
technical
report
report
including
implementation
details
ntccrt
graphical
interface
gelisp
gecol
applications
ntccrt
previous
attempts
develop
real-time
ntcc
interpreter
1.7
organization
structure
thesis
following
chapter
explain
background
concepts
chapter
focuses
modeling
ccfomi
allow
probabilistic
choice
musical
sequences
chapter
explains
modifications
ccfomi
allow
variation
intensity
learned
notes
style
simulation
phase
chapter
describes
model
pntcc
chapter
explains
design
implementation
ntccrt
real-time
interpreter
ntcc
chapter
shows
results
tests
made
interpreter
finally
chapter
present
summary
thesis
concluding
remarks
propose
future
work
background
2.1
concurrent
constraint
programming
ccp
concurrent
constraint
programming
ccp
model
concurrent
systems
ccp
concurrent
system
modeled
terms
constraints
system
variables
terms
agents
interacting
partial
information
obtained
variables
constraint
formula
representing
partial
information
values
system
variables
programming
languages
based
ccp
model
provide
propagator
user-defined
constraint
propagators
seen
operators
reducing
set
possible
values
variables
instance
system
variables
taking
musical
instrument
digital
interface
midi
values
constraint
specifies
possible
values
least
one
tone
higher
midi
notation
midi
pitch
unit
represents
semi-tone
ccp
model
includes
set
constraints
relation
know
constraint
deduced
others
named
entailment
relation
relation
gives
way
deducing
constraint
information
supplied
constraints
idea
ccp
model
accumulate
information
store
information
store
increase
decrease
concurrent
processes
interact
store
either
adding
information
asking
constraint
deduced
current
store
constraint
deduced
process
blocks
enough
information
deduce
constraint
consider
instance
four
agents
interacting
concurrently
fig
processes
tell
tell
add
new
information
store
processes
ask
ask
launch
process
process
respectively
condition
entailed
store
execution
tell
processes
process
ask
launches
process
process
ask
suspended
condition
entailed
store
0.6
0.6
figure
process
interaction
ccp
formally
ccp
model
based
idea
constraint
system
var
countable
set
primitive
constraint
system
structure
constraints
tokens
⊢∈d×d
inference
relation
logical
entailment
relates
tokens
tokens
var
infinite
set
variables
non
primitive
constraint
composed
primitive
constraints
formal
definition
ccp
specify
types
constraints
used
thus
constraint
system
adapted
particular
need
depending
set
instance
finite
domain
constraint
system
provides
primitive
constraints
also
called
basic
constraints
x∈r
set
ranges
integers
hand
finite
set
constraint
system
provides
primitive
constraints
y∈s
set
variables
variable
constraints
systems
may
also
include
expressions
trees
graphs
sets
valencia
rueda
argue
ccp
model
posses
difficulties
modeling
reactive
systems
information
given
variable
changes
depending
interactions
system
environment
problem
arises
information
added
store
deleted
changed
2.2
non-deterministic
timed
concurrent
constraint
ntcc
ntcc
introduces
notion
discrete
time
sequence
time-units
time-
unit
starts
store
possibly
empty
supplied
environment
ntcc
executes
processes
scheduled
time-unit
contrast
ccp
ntcc
variables
changing
values
along
time
modeled
ntcc
variable
taking
different
values
along
time-units
model
ccp
would
create
new
variable
time
change
value
following
give
examples
computational
agents
ntcc
used
operational
semantic
ntcc
agents
found
appendix
9.5
summary
found
table
using
tell
agent
constraint
system
possible
add
constraints
meaning
must
equal
meaning
integer
100
agent
used
describe
system
reacts
different
events
instance
tell
cmayor=true
process
reacting
soon
pitch
sequence
represented
midi
notation
played
adding
constraint
cmayor=true
store
current
time-unit
agent
tell
local
next
unless
next
meaning
adds
constraint
current
store
holds
run
runs
local
variable
parallel
composition
runs
next
time-unit
unless
inferred
run
non
deterministically
chooses
s.t
holds
delays
indefinitely
forever
executes
time-unit
table
ntcc
agents
parallel
composition
allows
represent
concurrent
processes
instance
tell
tell
instrument=1
process
telling
store
concurrently
reacts
octave
assigning
instrument
fig
number
one
represents
acoustic
piano
midi
notation
next
agent
useful
want
model
variables
changing
time
instance
next
tell
means
equal
current
time-unit
different
next
time-unit
0.6
figure
tell
parallel
agents
ntcc
unless
agent
useful
model
systems
reacting
condition
satisfied
deduced
store
instance
unless
next
tell
lastpitch
reacts
false
deduced
store
i.e.
played
current
time-unit
telling
store
next
time-unit
lastpitch
fig
0.6
figure
unless
agent
ntcc
agent
may
used
music
delay
end
music
process
indefinitely
forever
i.e.
know
process
executed
know
instance
*tell
end=true
agent
executes
certain
process
every
time-unit
execution
instance
tell
playsong=true
agent
used
model
non-deterministic
choices
instance
true
tell
pitch=i
models
system
time-unit
note
chosen
major
chord
represented
midi
numbers
48,52
played
fig
agents
presented
table
derived
basic
operators
agent
non-deterministically
chooses
execute
either
persistent
assignation
process
changes
value
current
value
following
time-units
similar
way
agents
table
used
model
cells
cells
variables
value
re-assigned
terms
previous
value
creates
new
cell
initial
value
changes
value
cell
different
changes
value
exchanges
value
cell
true
tell
pitch=i
expressed
tell
pitch=48
tell
pitch=52
tell
pitch=55
0.6
figure
execution
non-deterministic
process
ntcc
agent
meaning
true
i=1
i=2
local
t=v
next
tell
x=v
table
derived
ntcc
agents
agent
meaning
tell
x=z
unless
change
next
local
x=v
tell
change
next
local
t=v
tell
change
tell
change
next
table
definition
cells
finally
basic
recursion
defined
ntcc
form
process
name
restricted
call
call
must
within
scope
next
reason
using
next
want
infinite
recursion
within
time-unit
recursion
used
model
iteration
recursive
definitions
instance
using
basic
recursion
possible
write
function
compute
factorial
function
information
recursion
ntcc
found
2.3
generic
constraint
development
environment
gecode
gecode
constraint
solving
library
written
c++
gecode
based
constraints
propagation
agents
cpa
according
cpa
system
provides
multiple
propagators
transform
non-primitive
constraint
primitive
constraints
supplying
information
finite
domain
constraint
system
primitive
constraints
form
a..b
instance
store
containing
propagator
would
add
constraints
reader
may
notice
similarity
cpa
ntcc
based
concurrent
agents
working
constraint
store
chapter
explain
encode
ntcc
agents
propagators
gecode
works
different
operating
systems
currently
used
constraint
library
alice
soon
used
mozart-oz
therefore
maintained
long
time
furthermore
provides
extensible
api
allowing
create
new
propagators
finally
conjecture
gecode
performance
better
constraints
solving
tool-kits
used
sicstus
prolog
mozart-oz
based
gecode
benchmarks4
2.4
factor
oracle
factor
oracle
finite
automaton
built
linear
time
space
incremental
fashion
recognizes
least
sub-sequences
factors
given
sequence
recognizes
sequences
factors
states
considered
accepting
states
sequence
symbols
learned
automaton
states
0,1,2
...
always
transition
arrow
called
factor
link
state
i−1
state
transition
arrows
directed
backwards
going
state
called
suffix
links
suffix
links
opposed
factor
links
labeled
instance
automaton
presented
figure
black
headed
arrows
represent
factor
links
white
headed
arrows
represent
suffix
links
0.6
benchmarks
presented
http
//www.gecode.org
figure
automaton
s=ab
built
on-line
authors
proved
algorithm
linear
complexity
time
space
new
entering
symbol
new
state
added
arrow
i−1
created
label
starting
i−1
suffix
links
iteratively
followed
backward
state
reached
factor
link
label
going
state
suffix
links
follow
state
met
iteration
new
factor
link
labeled
added
state
finally
suffix
link
added
state
state
depending
condition
terminated
iteration
formal
definitions
proof
complexity
found
on-line
construction
algorithm
presented
detail
appendix
9.1
since
linear
complexity
time
space
found
appropriate
machine
improvisation
addition
attribute
values
music
event
kept
object
attached
corresponding
node
since
actual
information
structure
given
configuration
arrows
factor
suffix
links
therefore
tuple
pitch
frecuency
note
duration
amount
time
note
played
intensity
volume
note
played
related
arrow
according
2.5
concurrent
constraint
factor
oracle
model
music
improvisation
concurrent
constraint
factor
oracle
model
music
improvisation
ccfomi
defined
following
present
briefly
explanation
model
taken
ccfomi
three
kinds
variables
represent
partially
built
automaton
variables
set
labels
currently
existing
factor
links
going
forward
variables
suffix
links
state
variable
give
state
reached
following
factor
link
labeled
instance
figure
represented
although
stated
explicitly
ccfomi
variables
modeled
infinite
rational
trees
unary
branching
allowing
add
elements
time-unit
infinite
rational
trees
infinite
size
however
contain
finite
number
distinct
sub-trees
reason
subjects
multiple
axiomatizations
construct
constraint
system
based
instance
posting
constraints
cons
nil
cons
cons
model
list
three
elements
ccfomi
divided
three
subsystems
learning
add
improvisation
choice
playing
player
running
concurrently
addition
synchronization
process
sync
takes
care
synchronization
add
process
charge
building
process
models
learning
phase
creating
factor
links
suffix
links
note
process
add
calls
loop
process
tell
process
adds
needed
factor
links
labeled
state
states
reached
i−1
suffix
links
computes
suffix
link
k≥0
unless
next
tell
tell
k=−1
tell
tell
musician
modeled
player
process
playing
note
every
player
process
non-deterministically
chooses
playing
note
postponing
decision
next
time-unit
true
tell
tell
go=j
next
tell
go=j−1
next
learning
simulation
phase
must
work
concurrently
order
achieve
required
simulation
phase
takes
place
sub-graph
completely
built
process
charge
synchronization
simulation
learning
phase
preserve
property
synchronizing
phases
greatly
simplified
used
constraints
variable
value
processes
depending
blocked
therefore
process
waiting
greater
equal
one
means
process
played
note
process
add
new
symbol
condition
first
suffix
link
equal
followed
simulation
phase
next
unless
next
improvisation
process
uses
distribution
function
process
starts
state
stochastically
chooses
according
probability
whether
output
symbol
follow
backward
link
next
tell
tell
next
tell
unless
next
tell
out=σ
whole
system
represented
process
initializations
launching
processes
corresponding
improvisation
starts
symbols
created
player
process
tell
q=p
tell
go=n
choice
2.6
probabilistic
non-deterministic
timed
concurrent
constraint
pntcc
one
possible
critique
ccp
generic
representing
certain
complex
systems
even
counting
partial
information
extremely
valuable
find
properly
taking
account
certain
phenomena
remains
difficult
severely
affects
modeling
verification
particularly
challenging
case
uncertain
behavior
indeed
uncertainty
underlying
concurrent
interactions
areas
computer
music
goes
way
beyond
modeled
using
partial
information
only.
first
attempt
extend
ntcc
work
probabilities
stochastic
non-deterministic
timed
concurrent
constraint
sntcc
calculus
sntcc
using
however
using
provides
operator
decide
whether
execute
process
certain
sntcc
ccfomi
models
action
choosing
suffix
probability
sntcc
link
factor
link
probability
possible
use
probability
distribution
choose
among
factor
links
following
state
probability
distribution
describes
range
possible
values
random
variable
take
pntcc
overcomes
problem
provides
new
agent
calculus
probabilistic
choice
probabilistic
choice
operator
following
syntax
finite
set
indexes
every
intuition
operator
follows
associated
represents
probability
selected
execution
hence
collection
represents
probability
distribution
guards
entailed
current
store
determine
subset
enabled
processes
used
determine
eventual
normalization
current
time
interval
summation
probabilistically
chooses
one
enabled
process
according
distribution
defined
possibly
normalized
chosen
alternative
precludes
others
choice
possible
summation
precluded.
using
probabilistic
choice
model
process
choosing
factor
link
probability
distribution
tell
output=σ
operational
semantic
agent
formal
definitions
pntcc
found
appendix
9.5
probabilistic
choice
musical
sequences
modeling
machine
improvisation
want
choose
certain
music
sequence
based
history
user
computer
interaction
instance
traversing
factor
oracle
simulation
phase
want
information
choose
among
factor
links
suffix
link
following
certain
state
achieve
propose
assign
integers
links
using
integers
calculate
probabilities
choose
link
based
probability
distribution
recall
introduction
main
objective
extending
ccfomi
model
probabilistic
choice
musical
sequences
beginning
thesis
work
developed
probabilistic
model
changes
complexity
time
building
quadratic
see
appendix
9.2.1
idea
behind
changing
probabilities
factor
links
coming
state
modifying
factor
link
leaving
state
idea
discarded
compatible
soft
real-time
consider
soft
real-time
defined
introduction
probabilistic
model
chose
based
simple
yet
powerful
concept
using
system
parameters
probability
choosing
factor
link
simulation
phase
decrease
time
factor
link
chosen
additionally
calculate
length
common
suffix
context
associated
suffix
link
using
context
reward
suffix
links
information
context
found
represent
system
four
kind
variables
used
represent
states
transitions
musical
information
attached
probabilistic
information
information
change
musical
attributes
notes
based
user
style
addition
variables
described
system
information
parametrized
user
constant
recombination
factor
representing
proportion
new
sequences
desired
represents
factor
decreasing
importance
factor
link
chosen
simulation
phase
represents
importance
new
factor
link
relation
factor
links
coming
state
described
chapter
parameter
changing
musical
attributes
notes
finally
parameter
representing
number
notes
must
learned
starting
simulation
phase
chapter
describe
use
synchronize
improvisation
phases
label
factor
link
pitch
moreover
outside
definition
create
tuple
three
integers
factor
link
pitch
duration
intensity
three
characteristics
represented
integers
pitch
intensity
represented
integers
127
duration
represented
milliseconds5
way
build
pitch
i.e.
symbols
pitches
associating
musical
information
time
build
also
create
three
integer
arrays
sum
integer
every
factor
link
every
suffix
link
every
state
note
would
represent
probability
choosing
factor
link
suffix
links
considered
context
next
show
learning
simulation
phases
probabilistic
extension
present
simple
examples
explaining
probabilities
calculated
learning
phase
used
simulation
phase
finally
present
concluding
remarks
improvisation
models
related
model
3.1
stylistic
learning
phase
learning
phase
store
integer
factor
link
going
labelled
also
store
integer
state
automaton
initial
value
fig
system
parameter
representing
importance
new
sequence
relation
sequences
already
learned
factor
link
labeled
first
factor
link
leaving
assign
constant
want
big
integer
allowing
precision
reasoning
reader
may
notice
approach
gives
certain
importance
new
factor
link
leaving
labeled
without
changing
value
quantities
leaving
furthermore
preserve
sum
values
variable
state
system
exhibits
important
property
state
sum
probabilities
associated
factor
links
coming
state
equal
one
property
preserved
changing
values
improvisation
phases
pitch
duration
intensity
represented
according
midi
1.0
standard
0.7
figure
adding
factor
link
hand
give
rewards
suffix
link
using
context
calculate
context
lefebvre
lecroq
modified
construction
algorithm
conserving
linear
complexity
time
space
approach
successfully
used
cont
assayag
dubnov
anticipatory
improvisation
model
figure
simple
example
integer
arrays
presented
previously
first
present
score
fragment
happy
birthday
song
present
sequence
possible
tuples
pitch
duration
intensity
fragment
finally
probabilistic
information
0.8
score
fragment
375,80
125,60
500,100
500,90
500,100
1000,60
fragment
happy
birthday
song
represented
tuples
0.7
factor
oracle
probabilistic
information
figure
factor
oracle
used
represent
happy
birthday
fragment
3.2
stylistic
simulation
phase
simulation
phase
use
information
calculated
learning
phase
choose
notes
probabilistically
factor
links
chosen
phase
decrease
importance
proportionally
addition
probability
choosing
secondary
factor
links
proportional
consider
primary
factor
links
going
state
i+1
others
secondary
hand
suffix
links
rewarded
context
calculated
on-line
learning
phase
suffix
links
would
choose
factor
link
leaving
state
later
explain
probability
distribution
extend
concept
work
suffix
links
rewarded
context
however
concept
decreasing
probability
factor
link
chosen
remains
invariant
system
chooses
certain
factor
link
leaving
labeled
value
decremented
multiplying
subsequently
update
new
value
subtracting
fig
way
preserve
property
state
note
adding
constant
time
operations
making
model
compatible
soft
real-time
0.7
figure
choosing
factor
link
labelled
following
factor
links
obtain
factor
subsequences
original
sequence
causes
two
problems
first
always
follow
factor
links
soon
get
last
state
automaton
second
improvise
subsequences
information
learned
user
without
sequence
variation
would
make
improvisation
repetitive
following
suffix
link
achieve
sequence
variation
combine
different
suffixes
prefixes
sequences
learned
instance
omax
model
music
improvisation
processing
real-time
audio
video–
called
recombination
parametrized
recombination
factor
rueda
approaches
problem
ccfomi
creating
probability
distribution
parameterized
value
probability
choosing
factor
link
given
probability
choosing
suffix
link
given
1−α
drawback
approach
since
reward
suffix
links
context
length
common
suffix
system
may
choose
multiple
times
row
suffix
links
going
back
one
two
states
creating
repetitive
sequences
approach
based
rewarding
suffix
links
context
intuition
choosing
factor
links
leaving
state
factor
links
leaving
state
reached
following
current
state
suffix
link
rewarding
last
ones
product
recombination
factor
context
consider
function
returning
state
suffix
link
leads
state
consider
factor
links
would
two
probability
distributions
way
relate
using
context
create
probability
distribution
ranking
factor
links
leaving
state
product
sorry
ignored
\begin
cases
...
\end
cases
using
system
able
choose
symbol
state
advantage
probability
distribution
one
presented
ccfomi
takes
account
context
well
recombination
factor
exemplify
build
probability
distribution
consider
probabilistic
information
figure
example
correspond
s=ab
random
values
integer
arrays
described
chapter
table
shows
build
probability
distribution
figure
note
states
zero
two
table
probabilities
calculated
happens
first
state
suffix
link
backwards
last
state
factor
links
forward
hand
probabilities
calculated
state
one
combine
probability
choosing
factor
link
following
state
choosing
suffix
link
choosing
factor
link
state
zero
0.7
figure
factor
oracle
including
probabilities
sequence
s=ab
3/4
1/4
3/4
1/4
table
probability
distribution
figure
3.3
summary
chapter
explained
model
music
improvisation
using
probabilities
extending
notion
non-deterministic
choice
described
ccfomi
intuition
decreasing
probability
choosing
factor
link
time
chosen
rewarding
suffix
link
based
context
furthermore
explained
parameters
allow
parameterize
computation
probabilities
procedure
simple
enough
probabilities
computed
constant
time
built
preserving
linear
complexity
time
space
on-line
construction
algorithm
additionally
using
probabilities
allows
generate
different
sequences
without
repeating
sequence
multiple
times
row
like
ccfomi
3.4
related
work
omax
assayag
blonch
recently
proposed
new
way
traverse
oracle
based
heuristics
argue
traversing
oracle
using
suffix
links
using
factor
links
produces
interesting
sequences
extension
ccfomi
using
pntcc
use
pntcc
makes
possible
choose
sequences
simulation
phase
based
probability
distribution
although
perez
rueda
modeled
probabilistic
choice
sequences
using
provide
description
probabilities
calculated
learning
phase
changing
musical
attributes
notes
according
conklin
music-generation
systems
aim
create
music
based
predefined
rules
corpus
i.e.
collection
musical
pieces
certain
music
style
learned
previously
systems
create
new
musical
material
based
style
corpus
learned
unfortunately
use
algorithms
high
complexity
time
space
making
inappropriate
music
interaction
according
hand
interactive
systems
music
improvisation
e.g.
ccfomi
usually
based
recombination
sequences
learned
user
although
recombination
creates
new
sequences
based
user
style
create
new
notes
fact
even
change
single
characteristic
note
solve
problem
one
objectives
thesis
work
changing
least
one
musical
attribute
notes
generated
style
simulation
beginning
work
tried
develop
algorithm
creating
new
notes
based
learned
style
idea
calculating
probability
certain
music
scale
based
probability
choose
random
pitch
scale
music
scale
ascending
descending
series
notes
pitches
also
developed
algorithm
calculate
duration
new
notes
see
appendix
9.2.5
include
ideas
thesis
work
first
choosing
pitch
based
supposition
scale
generalized
music
based
scales
addition
procedure
calculating
probability
certain
scale
accurate
found
tests
finally
algorithm
generate
new
durations
compatible
soft
real-time
approach
chose
change
musical
attribute
based
simple
powerful
concept
store
average
intensity
musical
attributes
changed
model
reasons
mentioned
notes
currently
played
current
dynamics
computer
also
store
current
dynamics
user
compare
change
current
dynamics
computer
necessary
making
similar
user
current
dynamics
idea
behind
intensity
variation
originally
proposed
musicians
riascos
collazos
based
concept
usually
apply
improvising
musicians
order
formalize
concept
calculate
learning
phase
current
dynamics
last
system
parameter
notes
played
user
computer
separately
concurrently
simulation
phase
compare
two
current
dynamics
equal
multiply
intensity
current
note
played
computer
factor
proportional
relation
user
computer
current
dynamics
follows
explain
detail
calculate
current
dynamics
learning
phase
change
intensity
notes
generated
simulation
phase
4.1
stylistic
learning
phase
intensity
music
represents
two
different
things
time
analyzing
intensity
single
note
sequence
reason
intensity
musical
accent
meaning
importance
certain
notes
defining
rhythms
hand
reason
average
intensity
sequence
notes
dynamics
sequence
notes
accents
may
written
explicitly
score
symbol
bellow
note
dynamics
relative
loudness
may
written
explicitly
score
piano
forte
fortissimo
etc
capture
two
concepts
learning
phase
store
intensity
tuple
pitch
duration
intensity
addition
store
current
dynamics
last
notes
played
user
computer
calculate
current
dynamic
propose
calculate-current-dynamics
algorithm
idea
algorithm
storing
last
intensities
queue
algorithm
receives
sequence
intensities
value
reference
queue
current
dynamic
invariant
algorithm
always
average
queue
data
variable
sum
variable
intensitysum
append
9.1.3
gives
example
operation
algorithm
calculate-current-dynamics
new
queue
intensitysum
queuesize
queuesize
intensitysum
else
intensitysum
intensitysum
.push
intensitysum/queuesize
4.2
stylistic
simulation
phase
phase
traverse
using
probabilistic
distribution
proposed
chapter
remember
intensity
duration
associated
pitch
play
intensities
value
learned
could
problem
coherence
current
dynamics
user
current
dynamics
sequences
producing
give
example
problem
consider
happy
birthday
fragment
presented
figure
current
dynamics
fragment
98.
suppose
computer
current
dynamics
30.
poses
problem
user
expecting
computer
improvise
dynamics
according
interviews
riascos
collazos
solution
propose
multiplying
factor
intensity
every
note
generated
computer
previous
example
next
note
generated
computer
would
multiplied
factor
30/98
4.3
summary
explained
change
intensity
notes
generated
improvisation
idea
maintain
current
dynamics
notes
generated
computer
similar
current
dynamics
notes
generated
user
corresponds
formalizing
improvisation
technique
used
two
musicians
interviewed
thesis
work
kind
variation
intensity
something
new
machine
improvisation
systems
far
know
believe
kind
approach
simple
variations
made
preserving
style
learned
user
compatible
real-time
topic
investigation
future
works
4.4
related
work
solve
problem
creating
new
notes
changing
attributes
notes
improvisation
omax
model
parameter
called
innovation
rate
indicating
amount
new
material
desired
furthermore
omax
calculates
rhythmic
quality
function
compare
density
number
events
overall
duration
current
state
place
link
leading
using
rhythmic
quality
function
improvisation
jump
abruptly
different
rhythmic
patterns
therefore
omax
improvisation
rhythmically
coherent
within
however
generating
new
rhythms
coherent
user
style
machine
improvisation
still
open
problem
anticipatory
model
developed
cont
presents
results
sequences
produced
improvisation
different
pitches
compared
original
sequence
achieve
improvise
pitch
intervals
learning
intervals
pitches
played
user
allowing
calculate
new
pitches
using
pitch
intervals
attribute
improvise
neither
ccfomi
probabilistic
extension
provides
way
change
musical
attributes
notes
creating
new
material
based
user
style
modeling
system
pntcc
ntcc
used
large
variety
situations
synchronizing
musical
processes
introduction
chapter
recall
models
interactive
scores
audio
processing
formalizing
musical
processes
music
improvisation
models
synchronization
made
declaratively
means
ntcc
hides
details
processes
synchronized
shared
resources
store
accessed
one
objective
work
modeling
improvisation
system
ntcc
far
presented
modifications
improvisation
phases
allowing
probabilistic
choice
musical
sequences
changing
musical
attributes
simulation
phase
since
choosing
sequences
probabilistically
use
pntcc
probabilistic
extension
ntcc
modeling
improvisation
system
order
synchronize
improvisation
phases
learning
phase
must
take
place
beginning
however
simulation
phase
launched
learning
phase
learned
notes
phases
run
concurrently
synchronization
must
provided
improvisation
phase
must
work
partially
built
graphs
improvise
fragment
graph
represents
additionally
simulation
phase
work
state
value
current
dynamics
context
probabilistic
distribution
calculated
state
approach
synchronize
improvisation
phases
similar
one
used
ccfomi
remember
ccfomi
synchronizes
improvisation
phases
using
variable
variables
player
process
post
constraints
variables
processes
building
add
loop
activated
deduce
certain
information
variables
extend
concept
using
new
variables
introduced
model
addition
variables
used
ccfomi
model
variables
represent
probabilistic
choice
musical
sequences
represent
musical
attributes
associated
pitch
represent
intensity
variation
variables
represented
rational
trees
variables
change
value
time-unit
another
variables
represented
cells
cells
defined
chapter
chapter
explain
write
sequential
algorithm
learning
phase
combining
algorithm
building
on-line
calculating
context
calculating
probabilistic
distribution
current
dynamics
show
phases
modeled
pntcc
finally
give
concluding
remarks
present
related
work
5.1
modeling
stylistic
learning
phase
learning
phase
easily
integrated
on-line
algorithm
builds
calculates
context
original
algorithms
presented
appendix
9.1
learning
phase
represented
functions
ext_oracle_on-line
ext_add_letter
calculate
context
use
length_repeated_suffix
function
proposed
lefevre
length_repeated_suffix
calculates
context
finds
length
repeated
suffix
1..i+1
linear
time
space
complexity
ext_add_letter
function
charge
adding
new
pitches
also
creates
tuple
pitch
duration
intensity
updates
values
calculates
current
dynamics
user
context
state
i+1
function
receives
states
pitch
duration
intensity
system
parameters
intensity
queue
execution
uses
constant
function
temporal
variable
big
integer
constant
function
returning
suffix
link
state
temporal
variable
used
calculate
context
ext_add_letter
oracle
1..i
duration
intensity
create
new
state
i+1
queuesize
intensitysum
intensitysum+intensity
else
intensitysum
intensity
.push
intensitysum/queuesize
duration
intensity
undefined
k=−1
else
return
oracle
1..i
ext_oracle_on-line
function
sequential
algorithm
representing
learning
phase
receives
three
vectors
pitches
durations
intensities
addition
takes
system
parameter
ranking
importance
new
note
added
system
parameter
representing
number
notes
taken
account
calculate
current
dynamics
figure
presents
execution
function
three
first
symbols
happy
birthday
fragment
presented
figure
ext_oracle_on_line
1..m
1..m
1..m
create
oracle
one
single
state
=−1
new
queue
intensitysum
oracle
1..i
ext_add_letter
oracle
1..i−1
0.8
figure
executing
ext
oracle
on-line
algorithm
τ=2
learning
phase
modeled
pntcc
processes
phi
add
loop
player
context
process
phi
calculates
values
probability
distribution
used
choose
factor
link
leaving
state
labeled
symbol
recombination
factor
parameterized
process
represents
act
adding
fresh
variable
infinite
rational
tree
described
chapter
use
infinite
rational
trees
represent
variable
represents
transitions
phi
tell
|when
tell
process
add
one
charge
adding
new
pitches
addition
process
updates
values
cells
variable
calling
function
phi
tell
next
loop
process
represents
loop
ext_add_letter
function
process
adds
new
factor
link
points
new
state
greater
transition
labeled
values
depends
suffix
links
addition
calculates
values
context
probabilistic
information
k≥0
tell
|unless
next
next
tell
tell
|when
k=−1
tell
context
process
reader
may
notice
use
a≠b
instead
unless
a≠b
next
know
always
value
values
used
calculate
efficiently
context
according
lefevre
al.
algorithm
context
s=0
tell
|when
s≠0
tell
|when
tell
|when
next
process
calculates
value
current
dynamics
addition
updates
sum
based
parameter
index≥τ
|when
index
finally
player
stores
values
pitch
duration
intensity
received
environment
note
played
user
furthermore
updates
current
dynamics
0∧d
0∧i
next
tell
tell
tell
tell
tell
go=i
|unless
0∧d
0∧i
next
tell
go=j−1
5.2
modeling
style
simulation
phase
phase
use
agent
defined
pntcc
model
probabilistic
choice
model
extension
model
presented
model
improv
process
chooses
link
according
probability
distribution
furthermore
updates
values
sum
sets-up
outputs
updates
computer
current
dynamics
order
ask
constraint
a∧b
a∨b
deduced
store
use
reification
instance
process
a=b∧c=d
codified
process
constraints
improv
next
tell
tell
tell
tell
next
improv
k+1
unless
next
unless
next
improv
k+1
unless
next
improv
5.3
synchronizing
improvisation
phases
synchronizing
phases
greatly
simplified
used
constraints
variable
value
processes
depending
blocked
therefore
process
waiting
greater
equal
one
means
process
played
note
process
add
new
symbol
condition
first
suffix
link
equal
suffix
link
followed
simulation
phase
addition
sync
process
also
waiting
current
dynamics
take
value
greater
equal
next
||unless
next
process
necessary
wait
symbols
learned
launch
improv
process
wait
go=n
next
improv
unless
go=n
next
wait
system
modeled
player
sync
process
running
parallel
process
waiting
symbols
played
start
improv
process
reader
remeber
recombination
factor
representing
proportion
new
sequences
desired
represents
factor
decreasing
importance
factor
link
chosen
simulation
phase
represents
importance
new
factor
link
relation
factor
links
coming
state
parameter
changing
musical
attributes
notes
finally
parameter
representing
number
notes
must
learned
starting
simulation
phase
system
tell
wait
5.4
summary
modeled
concepts
described
previous
chapters
using
pntcc
although
synchronization
probabilistic
choice
modeled
declaratively
matching
time-units
easy
task
value
cell
changed
following
time-unit
change
value
cell
scope
unless
process
need
aware
value
changed
two
time-units
5.5
related
work
omax
model
uses
instead
using
ntcc
uses
shared
state
concurrency
synchronizing
improvisation
phases
message
passing
concurrency
synchronizing
openmusic
max/msp
although
remarkable
model
believe
ntcc
provide
easier
way
synchronize
processes
reason
correctness
implementation
obviously
easier
synchronize
declaratively
constraints
provide
much
powerful
way
express
declaratively
complex
synchronizing
patterns
since
ntcc
model
logical
counterpart
possible
prove
properties
model
instance
fact
always
never
sometimes
chooses
longest
context
repetitions
given
subsequence
avoided
probabilistic
ccofmi
fixes
problems
synchronization
extends
notion
probabilistic
choice
improvisation
phase
giving
clear
concise
semantic
however
model
probabilistic
distributions
may
change
time-unit
another
based
user
computer
interaction
implementation
ntcc
interpreter
program
takes
ntcc
models
creates
program
interacts
environment
simulating
behavior
ntcc
models
ntcc
interpreters
including
interpreter
designed
simulate
finite
ntcc
model
means
simulate
finite
number
time-units
last
decade
three
interpreters
ntcc
developed
lman
hurtado
muñoz
2003
ntccsim
http
//avispa.puj.edu.co
avispa
research
group
2006
rueda
sim
2006.
intended
simulate
ntcc
models
made
real-time
interaction
recall
introduction
soft
real-time
interaction
means
user
experience
noticeable
delays
interaction
designing
ntcc
interpreter
need
constraint
solving
library
programming
language
allowing
check
stability
i.e.
know
time-unit
check
entailment
i.e.
know
constraint
deduced
store
post
constraints
synchronize
concurrent
access
store
tasks
must
performed
efficiently
achieve
good
performance
authors
ntcc
model
interactive
scores
proposed
use
gecode
constraint
solving
library
future
ntcc
interpreters
create
interface
gecode
openmusic
specify
multimedia
interaction
applications
furthermore
proposed
extend
lman
work
mac
using
gecode
one
objective
thesis
develop
prototype
ntcc
interpreter
real-
time
capable
followed
advise
authors
interactive
scores
model
tried
several
alternatives
develop
interpreter
using
gecode
first
attempt
using
thread
represent
ntcc
process
simulation
however
found
using
threads
adds
overhead
performance
interpreter
context-switch
among
threads
even
using
lightweight
threads
tried
using
event-driven
programming
performance
better
compared
threaded
implementations
however
time
process
asks
condition
entailed
need
check
stability
thus
adding
unnecessary
overhead
reader
may
find
information
previous
attempts
appendix
9.3
performance
results
chapter
implementation
ntccrt
based
simple
powerful
concept
processes
encoded
propagators
gecode
way
gecode
manages
concurrency
required
interpreter
gecode
calls
continuation
process
process
condition
assigned
true
hand
tell
processes
trivially
codified
existing
gecode
propagators
timed
agents
i.e
unless
next
managed
providing
different
process
queues
time-unit
simulation
interpreter
works
two
modes
developing
mode
interaction
mode
developing
mode
users
may
specify
ntcc
system
want
simulate
interpreter
interaction
mode
users
execute
models
interact
chapter
design
implementation
ntccrt
explain
encode
ntcc
processes
also
explain
execution
model
interpreter
show
run
ccfomi
interpreter
addition
describe
made
interface
openmusic
generate
binary
plugins
data-flow
programming
languages
pure
data
max/msp
midi
audio
video
inputs/outputs
interact
ntccrt
binary
finally
give
conclusions
future
work
short
description
existing
interpreters
detailed
description
ntccrt
generation
binary
plugins
pure
data
max/msp
previous
ntccrt
prototypes
found
previous
publication
6.1
design
ntccrt
first
version
ntccrt
allowed
specify
ntcc
models
c++
execute
stand-alone
programs
current
version
offers
possibility
specify
ntcc
model
either
lisp
openmusic
c++
addition
currently
possible
execute
ntcc
models
stand-alone
program
external
object
i.e.
binary
plugin
max
6.1.1
developing
mode
order
write
ntcc
model
ntccrt
user
may
write
directly
c++
use
parser
takes
common
lisp
macros
input
defining
graphical
patch
openmusic
using
either
representations
possible
generate
stand-
alone
program
external
object
fig
0.6
figure
ntccrt
developing
mode
make
interface
openmusic
first
developed
lisp
parser
using
common
lisp
macros
write
ntcc
model
lisp
syntax
translate
c++
code
lisp
macros
extend
lisp
syntax
give
special
meaning
characters
reserved
users
purpose
executing
macros
automatically
compile
ntcc
program
success
lisp
macros
created
openmusic
methods
represent
ntcc
processes
openmusic
methods
graphical
representation
using
common
lisp
object
system
clos
graphical
objects
placed
graphical
patch
executing
patch
generates
ntccrt
c++
program
6.1.2
execution
mode
execute
ntccrt
program
proceed
two
different
ways
create
stand-alone
program
interact
midishare
library
create
external
object
either
max
advantage
compiling
ntcc
model
external
object
lies
using
control
signals
message
passing
api
provided
max
synchronize
graphical
object
ntccrt
external
0.6
figure
ntccrt
interaction
mode
handle
midi
streams
e.g.
midi
files
midi
instruments
midi
streams
programs
use
predefined
functions
max
process
midi
connect
output
functions
ntccrt
binary
plugin
also
provide
interface
midishare
useful
running
stand-alone
programs
fig
6.2
implementation
ntccrt
ntccrt
first
ntcc
interpreter
written
c++
using
gecode
section
focus
describing
data
structures
required
represent
ntcc
agent
explain
interpreter
makes
simulation
ntcc
model
ntcc
agents
represented
classes
avoid
confusions
write
agents
bold
font
e.g.
classes
italic
font
e.g.
class
6.2.1
data
structures
represent
constraint
systems
need
provide
new
data
types
gecode
variables
work
particular
store
therefore
need
abstraction
represent
ntcc
variables
present
multiple
stores
variable
object
boolean
variables
represented
boolv
class
variables
intv
class
variables
setv
class
infinite
rational
trees
unary
branching
setvarray
boolvarray
intvarray
classes
encoding
constraint
systems
defined
way
represent
process
classes
inheriting
askbody
askbody
class
defining
execute
method
called
another
object
nested
represent
tell
agent
defined
super
class
tell
prototype
provide
three
subclasses
represent
processes
tell
a=b
tell
a∈b
tell
kind
tell
agents
easily
defined
inheriting
tell
superclass
declaring
execute
method
agent
made
propagator
class
calling
propagator
process
represented
two
propagators
reified
propagator
constraint
else
skip
propagator
propagator
checks
value
value
true
calls
execute
method
otherwise
take
action
figure
shows
encode
process
a=c
using
propagator
0.7
0.7
figure
example
propagator
represent
agent
i.e
non-deterministic
choice
made
parallel
conditional
propagator
propagator
receives
sequence
tuples
gecode
boolean
variable
representing
condition
reified
propagator
e.g.
pointer
askbody
object
process
executed
assigned
true
propagator
executes
process
associated
first
guard
assigned
true
means
work
variables
assigned
false
work
propagator
based
idea
parallel
conditional
combinator
proposed
schulte
curious
reader
might
ask
obtain
non-
deterministic
behavior
order
make
non-deterministic
choice
pass
parameters
propagator
random
order
way
propagator
always
chooses
first
process
condition
true
since
processes
conditions
given
random
order
simulate
non-deterministic
choice
figure
shows
encode
process
tell
using
parallel
conditional
propagator
process
explained
appendix
9.4
0.7
0.7
figure
example
parallel
conditional
propagator
local
variables
easily
represented
instruction
allowing
user
create
new
variable
beginning
procedure
new
variable
persists
following
time-units
simulated
implementation
local
variables
useful
process
contains
local
variables
variables
declared
beginning
simulation
timed
agents
represented
timedprocess
class
timedprocess
abstract
class
providing
pointer
current
time-unit
queue
used
unless
processes
queue
used
persistent
assignation
processes
queue
used
processes
continuation
process
subclass
defines
different
execute
method
instance
execute
method
star
class
randomly
chooses
time-unit
place
continuation
askbody
object
corresponding
process
queue
unless
class
persistent
assignation
class
different
execute
method
unless
objects
persistent
assignation
objects
called
calculating
fixpoint
common
processes
process
queue
formally
propagator
seen
function
receiving
store
returning
store
fixpoint
propagator
store
gecode
calculates
store
fixpoint
propagators
said
store
stable
calculating
fixpoint
condition
unless
deduced
stable
store
continuation
executed
next
time-unit
hand
persistent
assignation
copies
domain
variable
assigned
store
stable
assigns
variable
following
time-units
creating
tell
object
following
time-unit
also
procedure
class
used
model
ntcc
simple
definitions
e.g.
tell
a=2
ntcc
recursive
definitions
e.g.
i+1
invocated
using
call
class
ntcc
recursive
definitions
create
local
variables
simulating
call-by-value
specified
formalism
recursion
ntcc
restricted
parameters
variables
store
make
recursive
call
recursive
procedure
however
ntccrt
check
conditions
left
user
implements
general
recursion
6.2.2
execution
model
order
execute
simulation
users
write
ntcc
mdel
ntccrt
compile
call
compiled
program
number
units
simulated
parameters
main
ntcc
definition
time-unit
interpreter
executes
following
steps
first
creates
new
store
new
variables
store
processes
input
e.g.
midi
data
coming
max
simulating
first
time-unit
calls
main
ntcc
definition
arguments
given
user
moves
unless
processes
unless
queue
moves
persistent
assignation
processes
persistent
assignation
queue
executes
remaining
processes
process
queue
calculates
fixpoint
note
calculate
one
fixpoint
time-unit
opposed
previous
prototypes
calculating
fixpoint
executes
unless
processes
unless
queue
executes
persistent
assignations
persistent
assignation
queue
calls
output
processing
method
e.g.
sending
variable
values
standard
output
midi
port
finally
deletes
current
store
figure
illustrates
execution
model
0.5
figure
execution
model
ntcc
interpreter
6.3
implementation
ccfomi
rueda
ran
ccfomi
interpreter
wrote
lisp
macros
extend
lisp
syntax
definition
ntcc
processes
provide
similar
interface
write
ntcc
processes
lisp
furthermore
write
ccfomi
definitions
ntccrt
intuitive
way
using
openmusic
instance
process
presented
chapter
charge
synchronization
processes
represented
boxes
one
parallel
processes
one
condition
one
condition
one
unless
processes
fig
0.4
figure
writing
process
openmusic
successfully
ran
ccfomi
stand-alone
program
using
midishare
present
results
tests
stand-alone
program
chapter
error
reference
source
found
also
ran
plugin
generated
ntccrt
plugin
connected
midi-input
midi-output
clock
used
changing
time-unit
simplicity
generate
clock
pulse
note
played
user
fig
way
could
connect
metronome
object
metronome
object
creates
clock
pulse
fixed
interval
time
0.5
figure
running
ccfomi
pure
data
6.4
summary
developing
interpreter
developed
interface
openmusic
write
ntcc
models
ntccrt
although
openmusic
interface
generates
code
ntccrt
able
embed
lisp
code
interpreter
addition
current
version
interpreter
support
probabilistic
choice
cells
required
run
model
acceptable
objective
develop
ntcc
interpreter
prototype
reason
still
support
pntcc
cells
basic
operators
ntcc
following
describe
possibilities
limitations
interpreter
possible
solutions
future
work
additionally
since
encoded
processes
gecode
propagators
able
use
search
ntcc
models
without
using
agent
possible
encoding
processes
lightweight
threads
threads
threads
managed
inside
gecode
search
engines
models
using
non-
deterministic
choices
incompatible
recomputation
used
search
engines
ntccrt
simulate
processes
leading
store
false
instance
false
next
tell
fail=true
|tell
a=2
|tell
a=3
since
agent
represented
propagator
propagation
achieves
fail
state
propagators
called
time-unit
causing
inconsistencies
rest
simulation
fortunately
processes
reasoning
false
store
rewritten
different
way
avoiding
kind
situations
instance
process
rewritten
state=false
next
tell
fail=true
|tell
a=2
|tell
a=3
|tell
state=false
although
many
applications
want
continue
store
fails
time-unit
failed
store
like
exception
programming
language
e.g.
division
zero
addition
ntccrt
restricts
domains
different
constraint
systems
domain
variables
set
tree
rational
trees
variables
elements6
limitation
due
gecode
uses
c++
integer
data
type
representing
variables
another
problem
arises
want
call
lisp
functions
interpreter
usefull
make
computer
music
programs
written
lisp
interact
ntccrt
currently
using
lisp
generate
c++
code
however
possible
embed
lisp
code
interpreter
e.g.
calling
lisp
function
continuation
process
fix
inconvenient
propose
using
gelisp
writing
new
interpreter
taking
advantage
call-back
functions
provided
foreign
function
interface
ffi
call
lisp
functions
c++
way
propagator
able
call
lisp
function
although
could
negative
impact
performance
correctness
system
e.g.
lisp
function
end
implementation
cells
still
experimental
yet
usable
idea
real-time
capable
implementation
cells
extending
implementation
persistent
assignation
cells
way
persistent
assignation
require
pass
domain
variable
current
time-unit
future
time-unit
however
persistent
assignation
usually
involves
simple
equality
relations
hand
cells
assignation
may
involve
mathematical
function
e.g
probabilistic
choice
yet
possible
neither
achieving
propose
extending
idea
used
non-deterministic
choice
agent
model
enough
determining
first
condition
deduced
activate
process
associated
probabilistic
choice
need
check
conditions
calculating
fixpoint
need
know
conditions
entailed
calculating
probabilistic
distribution
multiple
probabilistic
choice
operators
nested
need
calculate
fixpoint
nested
level
implementing
cells
probabilistic
choice
would
easy
implement
model
proposed
work
valencia
proposed
develop
model
checking
tools
ntcc
future
propose
using
model
checking
tools
verifying
properties
complex
systems
one
bit
used
sign
addition
pérez
rueda
proposed
exploring
automatic
generation
models
probabilistic
model
checker
prism
reader
aware
prism
used
successfully
check
properties
real-time
systems
believe
approach
used
verify
properties
system
finally
found
time-units
ntccrt
represent
uniform
time-
units
stand-alone
simulation
different
durations
problem
synchronizing
ntcc
program
programs
fix
made
duration
time-unit
take
fixed
time
easily
using
clock
provided
max
providing
clock
input
ntccrt
plugins
way
start
simulating
new
time-unit
receive
clock
pulse
hand
fixing
duration
time-unit
two
problems
first
fixed
time
less
time
required
compute
processes
time-unit
makes
simulation
incoherent
second
makes
simulation
last
longer
fixed
time
upper
limit
time-unit
duration
6.5
related
work
lman
developed
framework
program
rcx
lego
robots
composed
three
parts
abstract
machine
compiler
visual
language
borrowed
interpreter
idea
several
queues
storing
ntcc
processes
instead
using
threads
regrettably
since
lman
supports
finite
domain
constraints
ntccsim
used
simulate
biological
models
developed
mozart-
able
work
finite
domains
constraint
system
reason
real
numbers
conjecture
proved
using
mozart-oz
writing
ntcc
interpreter
efficient
using
gecode
based
results
obtained
benchmarks
gecode
gecode
performs
better
mozart-
constraint
solving
rueda
sim
developed
framework
simulate
multimedia
semantic
interaction
applications
interpreter
first
one
representing
rational
trees
finite
domain
finite
domain
sets
constraint
systems
one
drawback
interpreter
use
screamer
represent
constraint
systems
screamer
framework
constraint
logic
programming
written
common
lisp
unfortunately
screamer
designed
high
performance
makes
execution
ntcc
models
rueda
sim
suitable
real-time
interaction
tests
results
since
creation
lman
performance
correctness
main
issues
evaluate
ntcc
interpreter
lman
great
success
history
ntcc
interpreters
using
lman
possible
program
lego
robots
formally
predict
behavior
robots
years
later
rueda
sim
capable
model
multimedia
interaction
systems
although
beyond
scope
research
evaluate
whether
interpreters
faster
ntccrt
whether
able
interact
real-time
human
player
conjecture
appropriate
real-time
interaction
simulating
hundreds
time-units
complex
models
ccfomi
based
results
presented
authors
chapter
want
evaluate
performance
ntcc
interpreter
prototypes
also
evaluate
behavior
ntccrt
order
achieve
goals
performed
different
tests
ntccrt
previous
implementations
ntcc
first
tried
develop
generic
implementation
lightweight
threads
could
used
lispworks
purpose
use
threads
manage
concurrency
ntcc
interpreters
compared
lisp
processes
medium-weight
threads
implementation
threads
based
continuations
implementation
threads
based
event-driven
programming
found
continuations
efficient
lispworks
also
found
event-driven
implementation
threads
faster
using
lisp
processes
continuations
however
difficult
express
instructions
go-to
jumps
exceptions
local
variable
definition
event-driven
programming
tried
using
lisp
processes
event-driven
threads
implement
ntcc
interpreters
explained
appendix
9.3
found
context-
switch
threads
fact
checks
stability
constantly
adds
overhead
performance
ntcc
interpreter
reasons
discarded
using
threads
ntcc
interpreter
also
found
encoding
ntcc
processes
gecode
propagators
outperforms
threaded
implementations
interpreter
test
presented
chapter
taken
sample
100
essays
time
measured
using
time
command
provided
mac
time
macro
provided
common
lisp
tests
performed
mac
10.5.2
using
imac
intel
core
duo
2.8
ghz
lispworks
professional
5.02.
graph
bars
present
average
samples
vertical
axe
measure
seconds
graphs
present
standard
deviation
statistical
information
differences
performances
one
implementation
another
considerable
high
reason
performance
implementations
sometimes
present
bars
graph
fit
scale
graph
7.1
testing
ntccrt
performance
order
test
ntccrt
performance
made
two
tests
first
compared
ntcc
specification
find
paths
graph
three
implementations
second
tested
ccfomi
using
ntccrt
recall
beginning
chapter
test
taken
sample
100
essays
time
measured
using
time
command
provided
mac
time
macro
provided
common
lisp
tests
performed
mac
10.5.2
using
imac
intel
core
duo
2.8
ghz
lispworks
professional
5.02
7.2
test
comparing
implementations
ntcc
interpreters
compared
execution
times
simulating
specification
presented
find
paths
graph
concurrently
explained
detail
appendix
9.4
running
event-driven
lisp
interpreter
ntccrt
also
compared
concurrent
constraint
implementation
mozart/oz
recursive
implementation
lisp
fig
0.8
figure
comparing
implementation
find
paths
graph
7.3
test
executing
ccfomi
ccfomi
able
receive
one
note
time-unit
reasonable
measure
performance
average
duration
ntcc
time-unit
simulation
ran
ccfomi
ntccrt
player
interpretating
first
300
notes
j.s
bach
two-part
invention
studied
player
chooses
non-
deterministically
play
note
postpone
decision
next
time-unit
took
average
milliseconds
per
time-unit
scheduling
around
880
processes
per
time-unit
simulating
300
time-units
simulated
experiment
100
times
detailed
results
found
appendix
9.6.
present
musical
results
since
scope
work
conclude
whether
ccfomi
produces
improvisation
appealing
ear
interested
performance
tests
pachet
argues
improvisation
system
able
learn
produce
sequences
less
30ms
appropriate
real-time
interaction
since
ccfomi
response
time
20ms
average
300
time-units
simulation
conclude
capable
real-time
interaction
according
pachet
research
7.4
summary
ntccrt
ntcc
interpreter
based
encoding
ntcc
processes
gecode
propagators
outperforms
threaded
event-driven
implementations
ntcc
since
learning
producing
sequences
response
time
lower
milliseconds
according
authors
continuator
system
fast
enough
interact
musician
7.5
related
work
lman
developers
ran
specification
play
midi
pitch
fixed
duration
time-unit
tests
made
using
pentium
iii
930
mhz
256
ram
linux
debian
woody
3.0
rcx
2.0
lego
robot
running
brickos
2.6.1.
made
simulation
100
time-units
simple
process
takes
average
281.25
run
time-unit
using
lman
unfortunately
suitable
real-time
interaction
music
even
would
run
modern
computers
hand
rueda
interpreter
ran
ccfomi
1.67
ghz
apple
powerbook
using
digitool
mcl
version
common
lisp
taking
average
milliseconds
per
time-unit
scheduling
around
concurrent
processes
also
made
simulation
100
time-units
unfortunately
rueda
implementation
uses
mcl
functions
defined
common
lisp
standard
able
run
interpreter
mac
intel
compare
ntccrt
hand
lman
designed
linux
longer
maintained
current
versions
linux
tcl/tk
conclusions
chapter
present
summary
thesis
concluding
remarks
propose
future
work
thoughts
8.1
summary
explained
model
music
improvisation
using
probabilities
extending
notion
non-deterministic
choice
described
ccfomi
although
idea
simple
probabilities
computed
constant
time
space
built
managed
preserve
linear
complexity
time
space
on-line
construction
algorithm
calculating
probability
certain
scale
makes
model
appropriate
certain
music
genres
requires
calculate
multiple
constants
vary
according
genre
tonal
music
user
improvising
reason
discarded
explained
change
intensity
notes
generated
improvisation
kind
variation
intensity
something
new
machine
improvisation
systems
far
know
believe
kind
approach
simple
variations
made
preserving
style
learned
user
compatible
real-time
implementations
topic
investigation
future
work
used
cells
represent
variables
changing
time-unit
another
using
cells
modeled
probabilistic
distribution
changes
according
user
computer
interaction
far
know
first
pntcc
model
probabilistic
distributions
change
time-units
unfortunately
current
version
ntccrt
support
cells
probabilistic
choice
ran
ccfomi
ntccrt
taking
average
milliseconds
per
time-unit
see
chapter
since
learning
producing
sequences
response
time
less
milliseconds
according
authors
continuator
system
fast
enough
interact
musician
although
gecode
designed
solving
combinatory
problems
using
constraints
found
using
gecode
ntccrt
give
outstanding
results
writing
ntcc
interpreter
unfortunately
interpreter
able
execute
processes
leading
store
false
however
processes
reasoning
false
store
rewritten
different
way
avoiding
kind
situations
8.2
concluding
remarks
show
make
probabilistic
extension
ccfomi
using
factor
oracle
extension
three
main
features
first
preserves
linear
time
space
complexity
on-line
factor
oracle
algorithm
factor
oracle
chosen
data
structure
capture
user
style
ccfomi
linear
complexity
extension
would
worth
changed
complexity
factor
oracle
on-line
construction
algorithm
order
add
probabilistic
information
model
making
incompatible
real-time
second
using
pntcc
probabilistic
extension
ntcc
model
advantage
pntcc
need
model
processes
new
calculus
extend
ccfomi
instead
use
pntcc
agents
defined
ntcc
except
agent
used
work
new
agent
probabilistic
choice
adding
probabilistic
choice
ccofmi
avoid
loops
without
control
improvisation
may
happen
without
control
ccfomi
due
non-deterministic
nature
addition
changing
probability
distribution
could
favor
repetitions
improvisation
desired
third
variation
intensity
improvisation
far
know
first
model
considering
kind
variation
generating
variations
intensity
improvisation
avoid
sharp
differences
user
computer
intensity
making
improvisation
appealing
ear
according
musicians
interviewed
variations
musical
attributes
well-known
decades
computer
assisted
composition
interactive
systems
machine
improvisation
variations
still
open
subject
part
due
real-
time
requirements
interactive
systems
reader
consider
relevant
using
process
calculi
pntcc
model
verify
execute
real-time
music
improvisation
system
pose
reader
following
questions
reader
developed
real-time
improvisation
system
programming
language
mixing
non-deterministic
probabilistic
choices
try
verifying
system
formally
easy
task
would
reader
able
write
system
lines
code
using
pntcc
model
systems
using
pntcc
process
calculi
well-
known
theory
concurrency
past
two
decades
used
real-life
applications
garavel
argues
models
based
process
calculi
widespread
many
calculi
many
variants
calculus
difficult
choose
appropriate
addition
difficult
express
explicit
notion
time
real-time
requirements
process
calculi
finally
argues
existing
tools
process
calculi
user-friendly
want
make
process
calculi
widespread
real-life
applications
left
task
representing
real-time
process
calculi
choosing
appropriate
variant
calculus
application
senior
researchers
work
focuses
developing
real-life
application
pntcc
showing
interpreter
ntccrt
user-friendly
tool
providing
graphical
interface
describe
ntcc
processes
easily
compile
models
ccfomi
efficient
c++
programs
capable
real-
time
user
interaction
also
showed
approach
design
ntccrt
offers
better
performance
using
threads
event-driven
programming
represent
processes
reader
may
argue
although
synchronize
ntccrt
external
clock
provided
max
solve
problem
simulating
models
clock
step
smaller
time
necessary
compute
time-unit
addition
reader
may
argue
encourage
formal
verification
ntcc
pntcc
models
existing
tool
verify
models
automatically
even
semi-automatically
reader
right
reason
currently
avispa
research
group
sponsored
pontificia
universidad
javeriana
cali
developing
interpreter
extension
ntcc
capable
modeling
time-units
fixed
duration
addition
avispa
proposing
colciencias
project
called
robust
theories
emerging
applications
concurrency
theory
processes
logic
used
emergent
systems
react-plus
react-plus
focus
developing
verification
tools
ntcc
pntcc
process
calculi
addition
project
continue
developing
faster
easier
use
interpreters
invite
reader
read
following
section
know
future
work
thoughts
propose
addition
reader
may
find
information
react-plus
proposal
http
//www.lix.polytechnique.fr/comete/pp.html
8.3
future
work
future
propose
extending
research
following
directions
8.4
extending
model
propose
capturing
new
elements
music
sequences
instance
considering
music
timbre
music
pitch/amplitude
variation
e.g.
vibrato
bending
acciaccatura
resonance
effects
e.g.
delay
reverb
chorus
8.5
improvisation
set-ups
several
concurrent
improvisation
situation
set-ups
proposed
none
implemented
real-time
music
improvisation
rueda
propose
following
set-ups
performers
oracles
learning
performing
one
performer
one
oracle
learning
several
improvisation
processes
running
concurrently
oracle
one
performer
several
oracles
learning
different
viewpoints
performance
8.6
using
gelisp
ntccrt
currently
using
lisp
generate
c++
code
however
possible
embed
lisp
code
interpreter
work
around
propose
using
gelisp
writing
new
interpreter
taking
advantage
call-back
functions
provided
foreign
function
interface
ffi
call
lisp
functions
c++
way
process
trigger
execution
lisp
function
8.7
adding
support
cells
ntccrt
idea
real-time
capable
implementation
cells
extend
implementation
persistent
assignation
cells
way
persistent
assignation
require
pass
domain
variable
current
time-unit
future
time-unit
8.8
developing
interpreter
pntcc
pérez
rueda
already
propose
interpreter
pntcc
achieve
probabilistic
choice
ntccrt
propose
extending
idea
used
non-deterministic
choice
agent
model
enough
determining
first
condition
deduced
activate
process
associated
probabilistic
choice
need
check
conditions
calculating
fixpoint
need
know
conditions
entailed
calculating
probabilistic
distribution
multiple
probabilistic
choice
operators
nested
need
calculate
fixpoint
nested
level
8.9
developing
interpreter
rtcc
way
describe
behavior
ntcc
time-unit
fixed
time
less
time
required
execute
processes
scheduled
reason
propose
developing
interpreter
real
time
concurrent
constraint
rtcc
calculus
rtcc
extension
ntcc
capable
dealing
strong
time-outs
strong
time-outs
allow
execution
process
interrupted
exact
instant
internal
transitions
cause
constraint
inferred
store
rtcc
also
capable
delays
inside
single
time
unit
delays
inside
single
time
unit
allows
express
things
like
process
must
start
seconds
another
starts
sarria
proposed
developing
interpreter
rtcc
believe
extend
ntccrt
simulate
rtcc
models
8.10
adding
graphical
interfaces
ntccrt
work
conducted
tests
mac
using
stand-alone
programs
since
using
gecode
flext
generate
externals
could
easily
compiled
platforms
max
used
openmusic
define
iconic
representation
ntcc
models
future
also
propose
exploring
way
making
graphical
specifications
ntcc
similar
graphical
representation
data
structures
8.11
developing
model
checking
tools
ntccrt
valencia
proposed
using
model
checking
tools
verifying
properties
complex
ntcc
models
addition
pérez
rueda
proposed
developing
model
checking
tools
pntcc
instance
propose
exploring
automatic
generation
models
prism
based
pntcc
model
propose
generating
models
existing
model
checkers
automatically
prove
properties
systems
simulating
ntccrt
acknowledgements
removed
double-blind
reviewing
references
cyril
allauzen
maxime
crochemore
mathieu
raffinot
factor
oracle
new
structure
pattern
matching
conference
current
trends
theory
practice
informatics
pages
295–310
1999.
music
collazos
juan
manuel
improvisation
interview
darrell
conklin
ian
witten
multiple
viewpoint
systems
music
antoine
allomber
gérard
assayag
desainte-catherine
camilo
rueda
concurrent
constraint
models
interactive
scores
proc
3rd
sound
music
computing
conference
smc
gmem
marseille
may
2006
antoine
allombert
myriam
desainte-catherine
mauricio
toro
modeling
temporal
constrains
system
interactive
score
gérard
assayag
charlotte
truchet
editors
constraint
programming
music
chapter
pages
23.
wiley
2011
jesús
aranda
gérard
assayag
carlos
olarte
jorge
pérez
camilo
rueda
mauricio
toro
frank
valencia
overview
forces
inria
project
declarative
formalisms
emergent
systems
patricia
hill
david
scott
warren
editors
logic
programming
25th
international
conference
iclp
2009
pasadena
usa
july
14-17
2009.
proceedings
volume
5649
lecture
notes
computer
science
pages
509–513
springer
2009.
gérard
assayag
georges
bloch
navegating
oracle
heuristic
approach
international
computer
music
conference
pages
405–412
copenhagen
denmark
august
2007
gèrard
assayag
shlomo
dubnov
improvisation
planning
jam
session
design
using
concepts
sequence
variation
flow
experience
sound
music
computing
2005
salerno
italie
novembre
2005
videorecording
internet
2007
prediction
journal
new
music
research
24:51–73
1995
arshia
cont
antescofo
anticipatory
synchronization
control
interactive
parameters
computer
music
proceedings
international
computer
music
conference
icmc
belfast
august
2008.
arshia
cont
shlomo
dubnov
gérard
assayag
framework
anticipatory
machine
improvisation
style
imitation
anticipatory
behavior
adaptive
learning
systems
abials
rome
italy
septembre
2006
arshia
cont
shlomo
dubnov
g.assayag
anticipatory
model
musical
style
imitation
using
collaborative
competitive
reinforcement
learning
butz
m.v.
sigaud
pezzulo
baldassarre
editors
anticipatory
behavior
adaptive
learning
systems
volume
4520
lecture
notes
computer
science
artificial
intelligence
lnai
pages
285–306
springer
verlag
berlin
2007
musique
pages
175–194
hermes
2004
hubert
garavel
reflections
future
concurrency
theory
general
process
calculi
particular
electron
notes
theor
comput
sci.
209:149–164
2008
improvisation
soft
comput.
:604–610
2004
international
linux
audio
conference
lac2007
2007
julian
gutiérrez
jorge
pérez
camilo
rueda
frank
valencia
timed
concurrent
constraint
programming
analyzing
biological
systems
electron
notes
theor
comput
sci.
171
:117–137
2007.
ottó
károlyi
introducción
música
alianza
editorial
madrid
1981
kwiatkowska
norman
parker
sproston
modeling
verification
real-time
systems
formalisms
software
tools
chapter
verification
real-time
probabilistic
systems
pages
249–288
john
wiley
sons
2008
lefebvre
lecroq
computing
repeated
factors
factor
oracle
brankovic
ryan
editors
proceedings
11th
australasian
workshop
combinatorial
algorithms
pages
145–158
hunter
valley
australia
2000.
albert
graef
interfacing
pure
data
faust
lac
editor
5th
letz
fober
orlarey
midishare
une
architecture
logicielle
pour
g.assayag
sholomo
dubnov
using
factor
oracles
machine
françois
pachet
playing
virtual
musicians
continuator
practice
orlarey
fober
letz
syntactical
semantical
aspects
olarte
rueda
stochastic
non-deterministic
temporal
concurrent
hugo
lópez
catuscia
palamidessi
jorge
andrés
pérez
camilo
rueda
frank
valencia
declarative
framework
security
secure
concurrent
constraint
programming
iclp
pages
449–450
2006
m.p
muñoz
a.r
hurtado
lman
ntcc
abstract
machine
concurrent
programming
lego
robots
spanish
b.sc
thesis
department
computer
science
engineering
pontifica
universidad
javeriana
cali
2004
pilar
muñoz
andrés
hurtado
programming
robot
devices
timed
concurrent
constraint
programming
principles
practice
constraint
programming
cp2004
lncs
3258
page
803.springer
2004.
nationsmaster.com
encyclopedia
musical
improvisation
2008
nielsen
palamidessi
valencia
temporal
concurrent
constraint
programming
denotation
logic
applications
nordic
journal
computing
2002
constraint
calculus
sccc
0:30–36
2005
carlos
olarte
camilo
rueda
gerardo
sarria
mauricio
toro
frank
valencia
concurrent
constraints
models
music
interaction
gérard
assayag
charlotte
truchet
editors
constraint
programming
music
chapter
pages
133–153
wiley
hoboken
usa.
2011
faust
soft
comput.
:623–632
2004
ieee
multimedia
9:77–82
2002
jorge
pérez
camilo
rueda
non-determinism
probabilities
timed
concurrent
constraint
programming
maria
garcia
banda
enrico
pontelli
editors
logic
programming
24th
internatinoal
conference
iclp
2008
udine
italy
december
9-13
2008
proceedings
volume
5366
lecture
notes
computer
science
pages
677–681
pntcc
probabilities
non-determinism
2008
anna
philippou
mauricio
toro
process
ordering
process
calculus
spatially-explicit
ecological
models
proceedings
mokmasd
lncs
8368
pages
345–361
springer
2013
anna
philippou
mauricio
toro
margarita
antonaki
simulation
verification
process
calculus
spatially-explicit
ecological
models
scientific
annals
computer
science
:119–167
2013
conference
san
francisco
1996
1996
msp
proceedings
international
computer
music
conference.
1998
viswanath
ramachandran
pascal
van
hentenryck
incremental
algorithms
constraint
solving
entailment
rational
trees
proceedings
13th
conference
foundations
software
technology
theoretical
computer
science
pages
205–217
london
1993.
springer-verlag
internet
2007
andreas
rossberg
guido
tack
leif
kornstaedt
status
report
hot
pickles
serve
claudio
russo
derek
dreyer
editors
2007
acm
sigplan
workshop
pages
25–36
acm
2007.
peter
van
roy
editor
multiparadigm
programming
mozart/oz
second
international
conference
moz
2004
charleroi
belgium
october
7-8
2004
revised
selected
invited
papers
volume
3389
lecture
notes
computer
science
springer
2005
ccp
soft
comput.
:641–648
2004.
puckette
pure
data
proceedings
international
computer
music
puckette
apel
zicarelli
real-time
audio
analysis
tools
alberto
riascos
interview
music
improvisation
videorecording
rueda
valencia
validity
modelization
musical
problems
camilo
rueda
carlos
olarte
using
stochastic
ntcc
model
biological
camilo
rueda
research
report
technical
report
2006-1
ircam
paris
camilo
rueda
frank
valencia
temporal
concurrent
constraint
calculus
vijay
saraswat
concurrent
constraint
programming
mit
press
1992.
gerardo
sarria
formal
models
timed
musical
processes
phd
thesis
france
2006
camilo
rueda
gérard
assayag
shlomo
dubnov
concurrent
constraints
factor
oracle
model
music
improvisation
xxxii
conferencia
latinoamericana
informtica
clei
2006
santiago
chile
aot
2006
systems
clei
2005
31st
latinoamerican
conference
informatics
2005
audio
processing
framework
smc
2005
camilo
rueda
frank
valencia
formalizing
timed
musical
processes
temporal
concurrent
constraint
programming
calculus
proc
musical
constraints
workshop
cp2001
2002
universidad
del
valle
colombia
2008
christian
schulte
programming
deep
concurrent
constraint
combinators
practical
aspects
declarative
languages
second
international
workshop
padl
2000
volume
1753
lecture
notes
computer
science
pages
215–229
springer-
verlag
2000
jeffrey
mark
siskind
david
allen
mcallester
nondeterministic
lisp
substrate
constraint
logic
programming
proceedings
11th
national
conference
artificial
intelligence
july
1993
mauricio
toro
exploring
possibilities
limitations
concurrent
programming
multimedia
interaction
graphical
representations
solve
musical
csp
technical
report
2008-3
ircam
paris
france
2008
mauricio
toro
probabilistic
extension
factor
oracle
model
music
improvisation
master
thesis
pontificia
universidad
javeriana
cali
colombia
2009
mauricio
toro
towards
correct
efficient
implementation
simulation
verification
tools
probabilistic
ntcc
technical
report
pontificia
universidad
javeriana
may
2009
mauricio
toro
structured
interactive
musical
scores
manuel
hermenegildo
torsten
schaub
editors
technical
communications
26th
international
conference
logic
programming
iclp
2010
july
16-19
2010
edinburgh
scotland
volume
lipics
pages
300–302
schloss
dagstuhl
leibniz-zentrum
fuer
informatik
2010.
mauricio
toro
structured
interactive
scores
simple
structural
description
multimedia
scenario
real-time
capable
implementation
formal
semantics
phd
thesis
univeristé
bordeaux
france
2012
2015
mauricio
toro
carlos
agón
gérard
assayag
camilo
rueda
ntccrt
concurrent
constraint
framework
real-time
interaction
proc
icmc
montreal
canada
2009
mauricio
toro
myriam
desainte-catherine
concurrent
constraint
conditional
branching
interactive
scores
proc
smc
barcelona
spain
2010
mauricio
toro
myriam
desainte-catherine
baltazar
model
interactive
scores
temporal
constraints
conditional
branching
proc
journées
informatique
musical
jim
may
2010
mauricio
toro
myriam
desainte-catherine
julien
castet
extension
interactive
scores
multimedia
scenarios
temporal
relations
micro
macro
controls
proc
sound
music
computing
smc
copenhagen
denmark
july
2012.
mauricio
toro
structured
interactive
music
scores
corr
abs/1508.05559
available
mauricio
toro
myriam
desainte-catherine
camilo
rueda
formal
semantics
interactive
music
scores
framework
design
specify
properties
execute
interactive
scenarios
journal
mathematics
music
:93–112
2014
mauricio
toro
anna
philippou
sair
arboleda
carlos
vélez
maría
puerta
mean-field
semantics
process
calculus
spatially-explicit
ecological
models
technical
report
department
informatics
systems
universidad
eafit
http
//blogs.eafit.edu.co/giditic-
2015.
software/2015/10/01/mean-field/.x
mauricio
toro
anna
philippou
christina
kassara
spyros
sfenthourakis
synchronous
parallel
composition
process
calculus
ecological
models
gabriel
ciobanu
dominique
méry
editors
proceedings
11th
international
colloquium
theoretical
aspects
computing
ictac
2014
bucharest
romania
september
17-19
volume
8687
lecture
notes
computer
science
pages
424–441
springer
2014
first-order
ltl
theor
comput
sci.
330
:557–607
2005.
frank
valencia
decidability
infinite-state
timed
ccp
processes
appendix
9.1
algorithms
following
present
four
algorithms
factor
oracle
on-line
algorithm
algorithm
calculates
context
first
approach
extend
algorithm
probabilistic
choice
example
current
dynamics
algorithm
9.1.1
factor
oracle
on-line
algorithm
on-line
algorithm
build
presented
add-letter
create
new
state
m+1
create
new
transition
m+1
labeled
transition
create
new
transition
m+1
k==−1
else
leads
transition
m+1
return
oracle
oracle-on-line
create
oracle
one
single
state
oracle
add-letter
oracle
theorem
complexity
oracle-on-line
time
space
9.1.2
factor
oracle
on-line
algorithm
calculates
context
following
present
algorithm
calculates
context
preserving
linear
time
space
complexity
taken
algorithm
add
new
symbol
newaddletter
oracle
1..i
create
new
state
i+1
i+1
undefined
i+1
j=−1
else
lrs
i+1
lengthreppeatedsuffix
return
oracle
1..i
finding
length
repeated
suffix
i..i+1
lengthreppeatedsuffix
s=0
return
return
lengthcommonsuffix
finding
common
suffix
1..i
1..s
i+1
lengthcommonsuffix
return
else
return
9.1.3
example
current
dynamics
algorithm
example
executing
current
dynamics
algorithm
fig
presented
chapter
sequence
28,28,38,25,40,30
0.9
0.9
0.9
0.9
0.9
0.9
figure
current
dynamics
28,28,38,25,40,30
τ=4
9.2
previous
approaches
model
following
present
previous
approaches
model
probabilistic
choice
changing
attributes
notes
improvisation
probabilistic
choice
discarded
compatible
real-time
hand
changing
pitch
duration
improvisation
discarded
suitable
music
genres
e.g.
music
genres
based
music
scales
requires
elaborate
training
9.2.1
extension
probabilistic
choice
idea
behind
extension
change
values
leaving
state
adding
new
transition
leaving
state
addition
choosing
transition
improvisation
phase
necessary
change
value
transitions
leaving
state
posses
big
problem
change
value
changes
complexity
on-line
transitions
leaving
state
algorithm
linear
quadratic
time
reason
extension
discarded
9.2.2
adding
new
transition
let
take
values
range
0..1
constant
regulates
priority
new
transitions
added
figure
represents
process
adding
new
transition
0.6
0.2
0.6
figure
adding
new
transition
9.2.3
choosing
transition
improvisation
let
take
values
range
0..1
constant
regulating
change
probabilities
choosing
transition
process
changing
probabilities
choosing
transition
represented
figure
0.6
0.2
0.6
figure
choosing
transition
improvisation
9.2.4
pitch
variation
idea
finding
scale
user
playing
based
supposition
generate
new
pitches
belong
scale
two
problems
first
necessary
calculate
scale
user
playing
second
necessary
rank
notes
scale
give
higher
priority
notes
scale
others
9.2.5
probability
certain
music
scale
order
know
music
scale
improvisation
learned
user
count
notes
played
user
contained
scale
considering
five
types
scales
used
western
music
major
minor
pentatonic
major
harmonic
minor
harmonic
scales
corresponding
therefore
considering
different
scales
goal
find
scales
user
playing
instance
fragment
happy
birthday
fig
analyzed
possible
scales
found
multiple
scales
result
show
table
differentiate
major
major
harmonic
minor
tried
ranking
degree
scale
multiplying
degree
scale
factor
partially
solves
problem
differentiate
among
scales
value
factors
calculated
would
required
additional
training
specific
music
genres
reason
discarded
development
extension
scale
major
minor
major
harmonic
minor
pentatonic
major
formula
result
table
automatically
finding
scale
happy
birthday
fragment
addition
idea
compatible
music
genres
based
music
scales
proposed
9.2.6
duration
variation
order
preserve
style
learned
going
replace
note
duration
sequence
notes
already
played
user
whose
total
duration
equal
duration
instance
happy
birthday
fragment
replace
b,1000,60
sequence
already
played
g,500,90
c,500,100
g,375,80
g,125,60
a,500,100
a,500,100
g,500,90
preserving
original
duration
case
9.3
previous
prototypes
ntcc
interpreter
developing
ntccrt
explored
combinations
programming
languages
c++
common
lisp
concurrency
models
threads
event-
driven
programming
first
problem
faced
designing
interpreter
interfacing
gecode
common
lisp
since
openmusic
written
common
lisp
first
redesigned
gecol
library
work
gecode
2.2.0
current
version
gecode
gecol
opensource
interface
gecode
1.3.2
originally
developed
killian
sprote
unfortunately
gecol
still
low-level
api
gecol
reason
using
requires
deep
knowledge
gecode
difficult
syntax
fix
inconvenient
decided
upgrade
gelisp
library
originally
developed
rueda
gecode
1.3.2
gecode
2.2.2.
successfully
used
library
solve
constraint
satisfaction
problems
csp
computer
music
domain
library
easy
use
could
foundation
new
version
ntccrt
9.3.1
threaded
interpreters
lisp
c++
using
gecol
developed
prototype
ntcc
interpreter
lispworks
5.0.1
professional
using
lispworks
processes
based
pthreads
mac
similar
way
made
another
interpreter
using
c++
gecode
pthreads
concurrency
control
threaded
prototypes
tell
agents
modeled
threads
adding
constraint
store
access
controlled
lock
hand
processes
threads
waiting
store
free
asking
condition
deduced
store
deduce
condition
execute
continuation
else
keep
asking
fig
conditions
processes
represented
boolean
variables
linked
reified
propagators
fortunately
gecode
provides
reified
propagators
constraints
used
multimedia
interaction
e.g
equality
boolean
constraints
0.5
figure
threaded
ntcc
interpreters
using
lispworks
using
c++
since
gecode
thread-safe
protect
access
store
lock
synchronizing
access
gecode
library
thread-safe
supports
concurrent
access
variables
functions
however
still
problem
time
want
ask
condition
deduced
store
calculate
fixpoint
propagators
gecode
lazy
act
demand
drawback
threaded
implementations
c++
lispworks
overhead
calculating
fixpoint
time
want
query
condition
deduced
making
extensive
use
fixpoints
would
inefficient
even
use
efficient
lightweight
threads
library
boost
http
//www.boost.org
c++
9.3.2
event-driven
interpreter
lisp
discarding
threading
model
found
concurrency
model
giving
better
performance
chose
event-driven
programming
implementation
next
prototype
model
good
ntcc
interpreter
use
synchronous
i/o
operations
synchronization
made
ask
processes
unless
using
constraint
entailment
reader
may
see
comparison
event-driven
prototype
threaded
prototype
chapter
prototype
works
simple
way
event
queue
ntcc
processes
processes
represented
events
dispatcher
handling
events
handler
events
checks
boolean
variable
representing
waiting
condition
assigned
assigned
adds
event
queue
else
checks
value
true
adds
continuation
events
event
queue
otherwise
actions
taken
hand
handler
tell
events
add
constraint
store
finally
handler
parallel
events
adds
sub-processes
event
queue
fig
using
event-driven
programming
led
faster
easier
implementation
ntcc
approaches
presented
however
realized
instead
creating
handlers
tell
ask
parallel
dispatcher
processing
events
could
improve
interpreter
performance
taking
advantage
dispatcher
event
queues
provided
gecode
scheduling
propagators
encoding
ntcc
processes
gecode
propagators
0.5
figure
ntcc
interpreter
using
event-driven
programming
gecol
9.4
applications
ran
ntccrt
section
present
applications
ran
ntccrt
besides
ccfomi
applications
specified
using
graphical
interface
provided
openmusic
tested
pure
data
using
external
generated
ntccrt
details
obtained
9.4.1
dining
philosophers
synchronization
multiple
operations
easy
task
instance
consider
problem
dining
philosophers
proposed
edsger
dijkstra
consists
philosophers
sitting
circular
table
chopsticks
located
philosopher
thinking
gets
hungry
gets
hungry
take
control
chopsticks
immediate
left
right
eat
done
eating
restarts
thinking
dining
philosophers
problem
mentioned
constraints
philosophers
talk
require
chopsticks
eat
furthermore
solution
problem
must
allow
deadlocks
could
happen
philosophers
take
chopstick
wait
forever
chopstick
released
additionally
must
allow
starvation
could
happen
one
philosophers
never
able
eat
propose
solution
problem
philosophers
using
ntcc
formalism
synchronization
made
reasoning
information
entailed
i.e.
deduced
store
information
deduced
using
unless
agent
way
simple
model
problem
synchronization
made
declarative
recursive
definition
philosopher
represents
philosopher
living
forever
philosopher
three
different
states
thinking
hungry
eating
philosopher
thinking
eating
state
choose
non-
deterministically
change
next
state
remain
state
next
time-unit
means
choose
thinking
hungry
eating
thinking
hand
philosopher
hungry
state
wait
control
first
chopstick
left
even
numbered
right
odd
numbered
soon
controls
first
chopstick
wait
control
second
chopstick
controls
chopsticks
change
eating
state
next
time
unit
9.4.2
formal
definition
philosopher
next
tell
tell
next
tell
|tell
|tell
unless
next
tell
tell
tell
unless
next
tell
tell
next
tell
tell
tell
tell
tell
tell
2=0
tell
i−1
tell
i+1
2=1
tell
i+1
tell
i−1
next
philosopher
chopstick
process
chooses
non-
deterministically
one
philosophers
waiting
control
controlled
process
chopstick
unless
next
donext
tell
next
chosptick
finally
system
modelled
philosophers
chopsticks
running
parallel
philosophers
start
lives
thinking
state
chopsticks
free
system
philosopher
chopstick
9.4.3
implementation
figure
shows
program
philosophers
represented
bangs
graphical
object
design
send
message
user
clicks
receives
message
another
object
concurrency
control
made
ntccrt
external
philosophers
start
eating
ntccrt
external
sends
message
bang
changing
color
chopsticks
represented
commentaries
simplicity
0.6
figure
synchronizing
dining
philosophers
using
ntccrt
external
9.4.4
signal
processing
ntcc
used
past
audio
processing
framework
work
valencia
rueda
showed
modeling
formalism
gives
compact
precise
definition
audio
stream
systems
argued
possible
model
audio
system
prove
temporal
properties
using
temporal
logic
associated
ntcc
proposed
time-unit
associated
processing
current
sample
sequential
stream
unfortunately
practice
possible
since
require
execute
44000
time
units
per
second
process
44khz
audio
stream
additionally
poses
problems
find
constraint
system
appropriate
processing
signals
another
approach
give
formal
semantics
audio
processing
visual
audio
processing
language
faust
faust
semantics
based
algebra
block
diagrams
gives
formal
precise
meaning
operation
programmed
faust
also
interfaced
approach
different
since
use
ntcc
program
external
max
synchronize
graphical
objects
charge
audio
video
midi
processing
instance
ntcc
external
decides
triggering
graphical
object
charge
applying
delay
filter
audio
stream
allow
graphical
objects
apply
filter
audio
stream
delay
filter
finishes
work
illustrate
idea
consider
system
composed
collection
processes
graphical
objects
applying
filters
objects
midi
audio
video
streams
process
working
object
another
process
work
done
process
activated
condition
input
true
system
variables
represents
identifier
process
working
object
represents
object
finished
work
values
updated
time
unit
information
environment
represents
conditions
necessary
launch
process
based
information
received
environment
finally
represents
set
processes
waiting
work
object
objects
represented
idleobject
busyobject
definitions
object
idle
non
deterministically
chooses
process
variable
remain
busy
constraint
deduced
store
9.4.5
formal
definition
idleobject
next
busyobject
unless
next
idleobject
tell
busyobject
idleobject
unless
next
busyobject
process
working
object
represented
following
definitions
process
idle
deduce
based
information
environment
idleprocess
waitprocess
unless
next
idleprocess
process
waiting
information
launching
deduced
store
control
object
goes
busy
state
waitingprocess
bussyprocess
unless
next
waitingprocess
tell
process
busy
deduce
based
information
environment
process
finished
working
object
associated
busyprocess
idleprocess
unless
next
busyprocess
system
models
situation
objects
processes
implementation
external
adapted
kind
objects
processes
represented
graphical
objects
ntcc
triggers
execution
process
receives
input
process
done
another
input
conditions
execute
process
satisfied
system
idleobject
idleobject
idleprocess
1,1
idleprocess
1,2
idleprocess
2,1
idleprocess
2,2
9.4.6
implementation
system
described
openmusic
using
graphical
boxes
provide
present
graphical
description
processes
idleprocess
busyprocess
waitingprocess
see
fig
0.13
figure
writing
synchronization
ntccrt
external
openmusic
9.4.7
finding
paths
graph
concurrently
following
describe
application
use
ntccrt
find
concurrently
paths
graph
idea
one
ntccrt
process
edge
sends
forward
signals
successors
back
signals
predecessors
receives
back
signal
forward
signal
tells
store
path
adds
set
finite
set
variable
containing
successors
vertex
propagation
finishes
iterate
resulting
sets
find
different
paths
instance
build
path
graph
getting
lower-bound
variable
9.4.8
formal
definition
represents
edge
graph
tell
tell
tell
tell
main
process
finds
path
vertices
graph
represented
edges
set
pairs
representing
graph
edges
main
process
calls
∈edges
concurrently
sends
forward
signals
processes
form
back
signals
processes
form
notice
sending
receiving
signals
greatly
simplified
using
tell
ask
ntcc
store
main
edges
tell
tell
9.4.9
example
following
give
intuition
system
works
find
path
vertices
fig
starts
sending
forward
signals
processes
form
back
signals
processes
form
soon
receives
back
signal
forward
signal
tells
store
path
i.e.
tell
0.8
figure
example
finding
paths
graph
concurrently
additionally
reader
may
notice
path
vertices
figure
27.
example
back
signals
sent
processes
received
process
therefore
none
receives
back
forward
signal
calculating
fixpoint
ask
constraint
system
value
since
variable
bounded
infer
path
0.8
figure
example
finding
paths
graph
concurrently
9.5
operational
semantics
ntcc
pntcc
operational
semantics
defines
states
programs
execution
semantics
called
way
dynamic
sees
system
sequence
operations
occurrence
operation
called
transition
transition
system
structure
set
configurations
⟶⊆γ×γ
transition
relation
notation
γ⟶γ
defines
transition
configuration
configuration
transitions
often
divided
internal
external
depending
system
behavior
normally
external
transitions
denoted
9.5.1
operational
semantics
ntcc
following
present
description
given
rule
obs
says
observable
transition
labeled
obtained
performing
sequence
internal
transitions
initial
configuration
final
configuration
internal
evolution
possible
residual
process
executed
next
time
interval
equivalent
future
process
defined
obtained
removing
summations
trigger
activity
within
current
time
interval
local
information
stored
unfolding
sub-terms
within
next
unless
expressions
unfolding
specifies
evolution
across
time
intervals
processes
form
next
unless
next
following
present
internal
reduction
presented
observable
reduction
represented
relations
smallest
obey
form
rule
states
whenever
given
conditions
obtained
course
derivation
specified
conclusion
may
taken
granted
well
tell
sum
par
unl
loc
star
rep
str
obs
future
function
let
partial
function
defined
sorry
ignored
\begin
cases
...
\end
cases
9.5.2
operational
semantics
pntcc
following
present
description
given
pntcc
observable
transition
assumes
particular
internal
sequence
leading
state
computation
possible
obtained
removing
summations
trigger
activity
local
information
stored
unfolding
sub-terms
within
next
unless
expressions.
next
present
internal
reduction
presented
observable
reduction
represented
tell
psum
par
unl
loc
rep
str
obs
future
function
let
partial
function
defined
sorry
ignored
\begin
cases
...
\end
cases
9.6
tests
ccfomi
detail
detailed
information
tests
found
http
//ntccrt.sourceforge.net/
9.7
tests
model
find
paths
graph
detail
detailed
information
tests
found
http
//ntccrt.sourceforge.net/
